/*** *	Expense.c ***/#include "GlobalDefines.h"#include "Windows.h"#include "xRsrcDefines.h"#include "Geos.h"#include "Memo.h"#include "Expense.h"#include "Telephone.h"#include "DialogLib.h"#include "Scheduler.h"#include "WindowsGlobal.h"#include "List.h"#include <stdlib.h>#include <stdio.h>#include "Editor.h"/*** *	Window öffnen ***/OSErr	OpenExpenseWindows(void)		/* Window für Expense-Manager öffnen */{	REG WindPtr	w1;	w1 = MyOpenWind(FULLER | (1L<<noOrigin),WindExpense,strExpense,EXPENSE);	/* Window mit Slidern */	if(!w1) 		return(memFullErr);				// Fehler beim Öffnen 	MultiOpen(w1,EXPENSE);	WFUNC(w1,menuupdate,telupdate);		// Darstellung disabeln etc.	return(noErr);								// alles ok!}////	Dieses Unterprogramm addiert entsprechend der übergebenen Periodenlänge//	einen Zeitoffset zu einer Zeit in Sekunden//void AddSecondsByPeriod(periodType period, long *theTime){	DateTimeRec		theDate;	switch(period)					// Endzeit für auszugebende Periode berechnen	{	case pDay:		*theTime+=86400;			// Tageslänge [s]		break;	case pWeek:		*theTime+=604800;			// Wochenlänge [s]		break;	case pMonth:		Secs2Date(*theTime,&theDate);// Monatslänge		theDate.month++;		Date2Secs(&theDate,(unsigned long*)theTime);		break;	}}////	Dieses Unterprogramm subtrahiert entsprechend der übergebenen Periodenlänge//	einen Zeitoffset von einer Zeit in Sekunden//void SubSecondsByPeriod(periodType period, long *theTime){	DateTimeRec		theDate;	switch(period)					// Endzeit für auszugebende Periode berechnen	{	case pDay:		*theTime-=86400;			// Tageslänge [s]		break;	case pWeek:		*theTime-=604800;			// Wochenlänge [s]		break;	case pMonth:		Secs2Date(*theTime,&theDate);// Monatslänge		if(!(--theDate.month))		{			theDate.month=12;			theDate.year--;		}		Date2Secs(&theDate,(unsigned long*)theTime);		break;	}}////	Ausgabenübersicht//void	DoExpenseList(void){	DialogPtr		d;	short			item;	periodType		period=pDay;		// Anzeigeperiode: Tagesübersicht	ControlHandle	iHandle;	Str255			s;	ListHandle		l;	unsigned long	startDate;	char			dayTemp,monthTemp;	DateTimeRec		theDate;		d = GetCenteredDialog(DLOGAusgaben,nil);	if (d) {								// Dialog vorhanden?		theDate.second=theDate.minute=theDate.hour=0;		iHandle=GetCH(d,expDate);		startDate=GetDefaultDate(s);		// Periodenanfang holen		SetIText((Handle)iHandle,s);		// ins Edit-Feld schreiben		SelIText(d,expDate,0,32767);		// Und selektieren		l=NewList(d,expUser,false,true,129);	// UserItem, HSlider, VSlider		if(!l)		{			SysBeep(BEEPTIME);			DisposeDialog(d);			return;		}		(*l)->selFlags = lOnlyOne;			// Nur einer darf selektiert werden		AddItemsToExpenseList(startDate,period,l,d);	// Anfangswerte in die Liste		do{			PushRadioButton(d,period+expDay,expDay,expMonth); // Radio-Buttons für Anzeigeperiode			ModalDialog((ModalFilterProcPtr)OwnDialogFilter,&item);			if((item>=expDay) && (item<=expMonth) && (item-expDay!=period))	// Periodenlänge geändert?			{				period=item-expDay;			// Neue Periodenlänge				AddItemsToExpenseList(startDate,period,l,d);	// Liste entsprechend updaten			}			switch(item)			{			case expEnter:					// Neuer Periodenanfang				GetIText((Handle)iHandle,s);				PtoCstr(s);				if(!DateToList((char*)s,Strlen((char*)s),&theDate.year,&monthTemp,&dayTemp,true))				{					theDate.month=monthTemp;					theDate.day=dayTemp;					Date2Secs(&theDate,&startDate);					GetDateString(s,startDate,shortDate);					SetIText((Handle)iHandle,s);				// ins Edit-Feld schreiben					SelIText(d,expDate,0,32767);		// Und selektieren					AddItemsToExpenseList(startDate,period,l,d);	// Liste entsprechend updaten				}				break;			case expPlus:										// Um eine Periode zurückblättern				AddSecondsByPeriod(period,(long*)&startDate);				GetDateString(s,startDate,shortDate);			// Datum in Text wandeln				SetIText((Handle)iHandle,s);							// Neues Datum ins Textfeld				SelIText(d,expDate,0,32767);					// Und selektieren				AddItemsToExpenseList(startDate,period,l,d);	// Liste entsprechend updaten				break;			case expMinus:										// Um eine Periode vorblättern				SubSecondsByPeriod(period,(long*)&startDate);				GetDateString(s,startDate,shortDate);			// Datum in Text wandeln				SetIText((Handle)iHandle,s);							// Neues Datum ins Textfeld				SelIText(d,expDate,0,32767);					// Und selektieren				AddItemsToExpenseList(startDate,period,l,d);	// Liste entsprechend updaten				break;			}		}while(item!=expOK);		DisposeObjects(d);		DisposDialog(d);	}}////	Holt ein Default-Datum als Pascal-String. Wenn ein Kalender oben ist, in dem ein//	Tag selektiert ist, so ist dieser das Default-Datum, sonst das heutige Datum.//unsigned long	GetDefaultDate(Str255 s){	unsigned long	date;	Handle			xWindow;	DateTimeRec		theDate;		GetTime(&theDate);							// default ist akt. Datum	if(IsAppWindow((WindowPtr)gTopWindow))	{		xWindow=gTopWindow->MoreMem;		if(XWIN->windowType==ANN1 &&		((XWIN->theUnion.schedule.theSelectedDay)||(XWIN->floatVar==flDay)))		{			theDate.year=XWIN->theUnion.schedule.year;			theDate.month=XWIN->theUnion.schedule.month;			if(XWIN->floatVar==flDay)				theDate.day=XWIN->theUnion.schedule.day;			else				theDate.day=XWIN->theUnion.schedule.theSelectedDay;		}	}	theDate.hour=theDate.minute=theDate.second=0;	Date2Secs(&theDate,&date);	GetDateString(s,date,shortDate);	return(date);}////	Packt eine Übersicht aller Ausgaben in eine Liste//void	AddItemsToExpenseList(unsigned long date,periodType period,ListHandle l,DialogPtr d){	short			iType,kategorien=0,i,j,k;	Handle			iHandle;	Rect			iRect;	unsigned long	endDate=date,tempDate;	double			betrag;	DateTimeRec		theDate;	summenListe		*liste;	char			kategorie[50],c,s[80];	ListH			lHandle;	Boolean			found;	GrafPtr			oldPort;			LDoDraw(false,l);				// Momentan keine Redraws (kommen erst am Ende)	LDelRow(0,0,l);					// Liste erstmal löschen	AddSecondsByPeriod(period,(long*)&endDate);	// Endzeit für auszugebende Periode berechnen		CLCount=0;						// Alle Ausgaben zählen	MySearchOList(EXPENSE,"c00=1");	liste=(summenListe*)NewPtr(sizeof(summenListe)*CLCount);	// Soviele Kategorien gibt's maximal	if(!liste)	{		DoDialog(DLOGOutOfMemory,1);		return;	}		theDate.second=theDate.minute=theDate.hour=0;		lHandle=ORG.expense;			// Alle Ausgaben durchgrasen	while(lHandle)	{		theDate.year=(*lHandle)->t.expense.year;	// Erstmal testen, ob die Ausgabe		theDate.month=(*lHandle)->t.expense.month;	// im fraglichen Bereich liegt		theDate.day=(*lHandle)->t.expense.day;		Date2Secs(&theDate,&tempDate);				if((tempDate>=date) && (tempDate<endDate))		{			found=false;				// Kategorie existiert noch nicht			j=0;						// Kategorienamen rauskopieren			c=(*lHandle)->d[0];			while(c && c!=RETURN)		// Bis Null-Byte oder Return (Feldtrenner)			{				kategorie[j++]=c;				c=(*lHandle)->d[j];			}			kategorie[j]=0;				// Noch nullterminieren			for( i=0 ; i<kategorien ; i++ )	// Alle Kategorien durchsuchen				if(!Strcmp(kategorie,(liste[i]).kategorie))				{					found=true;				// Kategorie gab's schon					k=0;					c=(*lHandle)->d[++j];					while(c && c!=RETURN)	// Betrag extrahieren					{						kategorie[k++]=c;						c=(*lHandle)->d[++j];					}					kategorie[k]=0;					betrag=atof(kategorie);//					{short index=1; Boolean valid;//					Str2Dec(kategorie,&index,&betrag,&valid);//					}					(liste[i]).summe+=betrag;		// Und addieren					break;				}			if(!found)							// Kategorie gab's noch nicht			{				if(kategorien!=i)					DebugStr("\pMist passiert: i≠Kategorie");									Strcpy((liste[i]).kategorie,kategorie);				k=0;				c=(*lHandle)->d[++j];				while(c && c!=RETURN)			// Betrag extrahieren				{					kategorie[k++]=c;					c=(*lHandle)->d[++j];				}				kategorie[k]=0;				betrag=atof(kategorie);				(liste[i]).summe=betrag;		// Und reinschreiben				kategorien++;					// Jetzt gibt's eine Kategorie mehr			}		}		lHandle=(*lHandle)->next;				// Nächsten Datensatz testen	}		betrag=0;	for( i=0 ; i<kategorien ; i++ )				// Alle Kategorien in Liste hängen	{		sprintf(s,"%-30s\t%10.2f",liste[i].kategorie,liste[i].summe);		betrag+=liste[i].summe;		AddListMgr(s,l);						// an die Liste anhängen	}	GetIndString((unsigned char*)kategorie,strExpenseTxt,strExpSumme);	PtoCstr((unsigned char*)kategorie);	sprintf(s,"%s\t%10.2f",kategorie,betrag);	AddListMgr(s,l);						// an die Liste anhängen		LDoDraw(true,l);	GetPort(&oldPort);	SetPort((GrafPtr)d);	GetDItem(d,expUser,&iType,&iHandle,&iRect);	iRect.right-=SBarWidth;	EraseRect(&iRect);	InvalRect(&iRect);	SetPort(oldPort);	DisposePtr((Ptr)liste);}