//// Options.c  -  Optionen-Menü//#include "GlobalDefines.h"#include "Memo.h"#include "Geos.h"#include "xRsrcDefines.h"#include "rsrcDefines.h"#include "DialogLib.h"#include "Options.h"#include "AktDocStruct.h"#include "Install.h"#include "Sharp.h"#include "Telephone.h"#include "MoreOptions.h"#include "Utilities.h"#include <Gestalt.h>#include "GlobalLib.h"#include "WindowsGlobal.h"#include "Expense.h"#if BETA#include "MySound.h"#include "GeosMore.h"#include <stdio.h>#include "List.h"#endifextern IQFileType	gRedrawIQType;extern RedrawType	gRedrawRdType;extern ListH		gClipboardList;					// Aus MoreOptions.c#if BETA && CACHEBoolean	gCacheDisabled=FALSE;#endif////	Menüs disablen, wenn kein Window liegt…//void	OptionsMenuEnable(Boolean*){	MenuHandle	mh = GetMHandle(mOptionen);	Handle		xWindow;	Boolean		enableEdit;		if(gTopWindow && IsAppWindow(FrontWindow()))	// Ist das oberste Window unsers?	{		mh = GetMHandle(mFenster);		EnableItem(mh,FloatMenuNumber);		// Float kann geöffnet werden				enableEdit=false;		xWindow=gTopWindow->MoreMem;		// Und (Un)Mark*ed nur enabeln		if(xWindow && (XWIN->selectedNo>0))			enableEdit=true;		mh=GetMHandle(mBearbeiten);			// Bearbeiten: 4/8-zeilig		if(!xWindow || (XWIN->windowType==ANN1) || (XWIN->windowType==OUTLINE))	// Kalender: Nix zu selektieren		{			DisableItem(mh,mEditSelectAll);	// Select All nur bei Window			DisableItem(mh,mEditSelectNone);	// Select All nur bei Window		}		else		{			EnableItem(mh,mEditSelectAll);	// Select All nur bei Window			EnableItem(mh,mEditSelectNone);	// Select All nur bei Window		}		if(!xWindow || XWIN->windowType==OUTLINE)			DisableItem(mh,mEditNewEntry);		else			EnableItem(mh,mEditNewEntry);		mh=GetMHandle(mAblage);		DisableItem(mh,iImport);		DisableItem(mh,iExport);		// Memo und Visitenkarten.		if(xWindow) {			switch(XWIN->windowType) {			case TEL1DATA:		// Import nur bei einigen Bereichen			case MEMO:			case BUSINESS:					EnableItem(mh,iImport);			}			switch(XWIN->windowType) {			case SCHEDULE:			case ANN1:			case TEL1DATA:		// Export nur bei einigen Bereichen			case MEMO:			case BUSINESS:			case DOLIST:			case EXPENSE:			case TIME:			case TODO:			case USERFILE1:					EnableItem(mh,iExport);			}		}	}else	{		enableEdit=false;		DisableItem(mh,optLayout);			// Darstellung nur bei Windows möglich		mh = GetMHandle(mFenster);		DisableItem(mh,FloatMenuNumber);	// Float kann nicht geöffnet werden		mh=GetMHandle(mBearbeiten);			// Bearbeiten: 4/8-zeilig		DisableItem(mh,mEditSelectAll);		// Select All nur bei Window		DisableItem(mh,mEditSelectNone);		DisableItem(mh,mEditNewEntry);		mh=GetMHandle(mAblage);		DisableItem(mh,iImport);			// Import und Export nur bei Telefon,		DisableItem(mh,iExport);			// Memo und Visitenkarten.	}		mh=GetMHandle(mBearbeiten);				// Bearbeiten: 4/8-zeilig	if(enableEdit)							// Wenn was selektiert ist.	{		EnableItem(mh,mEditCaps);		EnableItem(mh,mEditAttribute);		EnableItem(mh,mEditCut);		EnableItem(mh,mEditCopy);		EnableItem(mh,mEditClear);		mh=GetMHandle(mAttribute);			// Handle vom Attribut-Menü		if (mh) {			Str255 xxx; USTR s=xxx; REG WORD i; Str255	s2;			for(i=1;i<999;i++) {				GetIndString(s,strAttributes,i);				if (!s[0])		 continue;	// Kein String, dann weiter				if (s[1] == '!') s++;		// '!' (Redrawanforderung) wegcutten				if (s[1] == '*') break;		// Ende des Menüs				if (s[1] != '-') continue;	// nicht besonders disabled				EnableItem(mh,i);				if (s[4] == 'c') {			// Aufruf der Suchsprache					s2[0] = 0;					switch((s[5]-'0')*10+s[6]-'0') {	// Funktionsnummer					case 7:	GetTelName(TEL1FILE,s2);							break;					case 8:	GetTelName(TEL2FILE,s2);							break;					case 9:	GetTelName(TEL3FILE,s2);							break;					case 14: GetTelName(USER1FREE,s2);							break;					case 15: GetTelName(USER2FREE,s2);							break;					case 16: GetTelName(USER3FREE,s2);							break;					}					if (s2[0]) SetItem(mh,i,s2);				}				if (XWIN->windowType != ((s[2]-'0')*10+s[3]-'0'))					DisableItem(mh,i);			}		}	}else	{		DisableItem(mh,mEditCaps);		DisableItem(mh,mEditAttribute);		DisableItem(mh,mEditCut);		DisableItem(mh,mEditCopy);		DisableItem(mh,mEditClear);	}	mh=GetMHandle(mBearbeiten);	if(gClipboardList)						// Liegt was im Clipboard?		EnableItem(mh,mEditPaste);			// Dann geht Paste	else		DisableItem(mh,mEditPaste);			// Sonst nicht		DoMoreEnable(mh = GetMHandle(mOptionen));	SharpMUpdate();						// Andere wollen auch mal…}void	FontMenu(int entry){	MenuHandle		m;	Str255			s,s2;	long			num;	short			i,anz,size,font;	// Fonts testen und aktuellen abhaken	m = GetMHandle(mFont);					// Handle des Font-Menüs	anz=CountMItems(m);	for( i=1 ; i<=anz ; i++ )	{		if(entry==i)		{			CheckItem(m,i,true);			// angeklickter Font? Dann abhaken			GetItem(m,i,s2);				// Menu-Text holen		}else			CheckItem(m,i,false);			// Sonst Haken löschen	}	if(gDoc)								// Dokument offen?		CopyPString(ADOC.font,s2);			// Dann Font im Dokument ändern	CopyPString(gS.font,s2);				// Auf jeden Fall in den Prefs	gSaveSettings=true;						// Preferences dirty	if(gDoc)		size=ADOC.fontSize;					// Größe bleibt gleich	else		size=gS.fontSize;	// FontSizes testen und Style festlegen	m = GetMHandle(mFontsize);				// Handle des FontSize-Menüs	GetFNum(s2,&font);	anz=CountMItems(m)-1;					// Alle Items exkl. "Other…"	for( i=1 ; i<anz ; i++ )	{		GetItem(m,i,s);						// Menu-Text holen		StringToNum(s,&num);		if(RealFont(font,(short)num))		// Existiert die Font-Größe?			SetItemStyle(m,i,outline);		// Dann Outlined darstellen		else			SetItemStyle(m,i,0);			// Sonst "normal"		if((short)num==size)			CheckItem(m,i,true);			// aktuelle Größe? Dann abhaken		else			CheckItem(m,i,false);	}//	if(RealFont(font,1))					// 1pt existiert = Outline-Font//		SetItemStyle(m,anz+1,outline);		// Dann outlined darstellen		if(gDoc)	{		GrafPtr	oldPort;				GetPort(&oldPort);		SetPort((GrafPtr)gTopWindow);		TextSize(ADOC.fontSize);		CalcSecondColumn((GrafPtr)gTopWindow);		// Position der 2. Spalte berechnen		SetPort(oldPort);		AppDocumentDirty(gDoc,true);				// Document ist jetzt dirty	}	// Redraw in allen Windows des aktuellen Dokuments	ForAllWindows(DoFontChange,gDoc,false);}////	Routine für ForAllWindows: Font und Fontgröße ändern//Boolean	DoFontChange(void){	Str255			s;	Handle			xWindow;	short			font;		xWindow=gMacWind->MoreMem;				// Redraw erzwingen und Slider neu berechnen	if(!xWindow)		return false;	if(XWIN->windowType!=ANN1)	{		GetFNum(ADOC.font,&font);			// Fontname aus AktDocStruct		TextFont(font);						// Font setzen		TextSize(ADOC.fontSize);			// Größe setzen			gRedrawIQType=XWIN->windowType;		gRedrawRdType=redrawAndRecalc;		DoMultiRedrawSub();								return(false);						// Weitere Fenster durchsuchen	}}void	CalcSecondColumn(GrafPtr w){	short			breite,i,tempBreite,font,saveFont,saveSize,k;	datasetH		actset;	datasetP		actsetP;	IQFileType		j;	GrafPtr			oldPort;		#define MAX_TEST_TYPES	4		IQFileType		test[MAX_TEST_TYPES]={BUSINESS,EXPENSE,DOLIST,TODO};		if(w)	// Wir brauchen einen GrafPort, damit wir Textattribute setzen dürfen	{//		GetPort(&oldPort);//		saveFont=oldPort->txFont;				// Zumindest für Calendar keinen Font verstellen//		saveSize=oldPort->txSize;//		SetPort(w);					// Offset für rechte Spalte = Länge des längsten Feldnamens		actset=(datasetH)NewHandle(sizeof(dataset));	// Temporärer Buffer für Feldnamen		if(!actset)								// Kein Speicher, keine Ausgabe		{			SysBeep(20);			ADOC.columnOffset=SECOND_COLUMN_OFFSET;	// Dann fixen Wert nehmen			return;		}//		GetFNum(ADOC.font,&font);				// Fontname aus AktDocStruct//		TextFont(font);							// Font setzen//		TextSize(ADOC.fontSize);				// Größe setzen			HLock((Handle)actset);		actsetP=*actset;		breite=0;				for( k=0 ; k<MAX_TEST_TYPES ; k++ )		{					FillOut(test[k],actset);	// Feldnamen eintragen			for( i=0 ; (i<=MAX_NAMES) && (actsetP->text[i][0]!=END_OF_LIST) ; i++ )			{				// Breite eines jeden Feldnamens ermitteln				tempBreite=TextWidth(&(actsetP->text[i]),0,(actsetP->text[i])[0]);				breite=breite>tempBreite?breite:tempBreite;	// Größten raussuchen			}		}		// Und jetzt nochmal für alle Telefonfreifelder		for( j=TEL1DATA ; j<=TEL3DATA ; j++ )		{			GetFreeFields(actset,ORG.telfree,j,TEL1FREE,TEL1DATA,3);			for( i=3 ; (i<=MAX_NAMES) && (actsetP->text[i][0]!=END_OF_LIST) ; i++ )			{				// Breite eines jeden Feldnamens ermitteln				tempBreite=TextWidth(&(actsetP->text[i]),0,(actsetP->text[i])[0]);				breite=breite>tempBreite?breite:tempBreite;	// Größten raussuchen			}		}			// Und jetzt nochmal für alle Anwenderdatei-Freifelder		for( j=USERFILE1 ; j<=USERFILE3 ; j++ )		{			GetFreeFields(actset,ORG.userfree,j,USER1FREE,USERFILE1,0);			for( i=0 ; (i<=MAX_NAMES) && (actsetP->text[i][0]!=END_OF_LIST) ; i++ )			{				// Breite eines jeden Feldnamens ermitteln				tempBreite=TextWidth(&(actsetP->text[i]),0,(actsetP->text[i])[0]);				breite=breite>tempBreite?breite:tempBreite;	// Größten raussuchen			}		}		// Zum Schluß noch mit "Notizblock" vergleichen		GetIndString((*actset)->text[0],strNotiz,strNotizeintrag);		tempBreite=TextWidth(&(actsetP->text[0]),0,(actsetP->text[0])[0]);		breite=breite>tempBreite?breite:tempBreite;		HUnlock((Handle)actset);		DisposHandle((Handle)actset);		ADOC.columnOffset=breite+CharWidth('8')+COLUMN_LINE_OFFSET;	// Und der isses dann	//		TextFont(saveFont);//		TextSize(saveSize);//		SetPort(oldPort);	}else		ADOC.columnOffset=SECOND_COLUMN_OFFSET;	// Sonst fixen Wert nehmen}void	FontSizeMenu(int entry){	MenuHandle		m;	Str255			s;	long			num;	short			i,anz,size,font,iType,oldSizeGDoc,oldSizePrefs;	Handle			iHandle;	Rect			iRect;	Boolean			setSomething;	oldSizePrefs=gS.fontSize;					// Alte Werte merken, um dirty	if(gDoc)									// bestimmen zu können		oldSizeGDoc=ADOC.fontSize;	m = GetMHandle(mFontsize);					// Handle des FontSize-Menüs	anz=CountMItems(m)-1;						// Alle Items exkl. "Other…"	if(entry==anz+1)							// Other wurde angeklickt	{		DialogPtr	d;		short		item,saveFont,saveSize,gestaltAnswer;		GrafPtr		oldPort;		long		tempSize,temp;		RgnHandle	tempRgn;		d = GetCenteredDialog(DLOGFontOther,nil);		if (d) {							// Dialog vorhanden?			GetPort(&oldPort);			SetPort((GrafPtr)d);			// GrafPort auf Dialogbox			GetFNum(ADOC.font,&font);		// Aktuellen Font setzen			tempSize=ADOC.fontSize;			tempRgn=NewRgn();				// Region für alte Clip-Region			gestaltAnswer = GetGestaltResult(gestaltFontMgrAttr);	// Gibt's Outline-Fonts = Größen über 127			do{				GetDItem(d,butSample,&iType,&iHandle,&iRect);	// Quick-Fox-Feld				EraseRect(&iRect);					// Erstmal löschen				TextSize((short)tempSize);			// In aktueller Größe ausgeben				MoveTo(iRect.left,iRect.bottom-5);	// 5 Pixel vom unteren Rand				saveFont=((GrafPtr)d)->txFont;		// Alten Font merken				saveSize=((GrafPtr)d)->txSize;				GetClip(tempRgn);				ClipRect(&iRect);					// Clip-Rectangle = UserItem				TextFont(font);				GetIndString(s,strQuickFox,1);		// Quick-Fox holen				DrawString(s);						// Und raus damit				TextFont(saveFont);				TextSize(DIALOG_FONT_SIZE);				SetClip(tempRgn);					// Alte Clip-Region restaurieren				GetDItem(d,butEdit,&iType,&iHandle,&iRect);				NumToString(tempSize,s);			// Bisherige Font-Größe				SetIText(iHandle,s);				// ins Edit-Feld schreiben				SelIText(d,butEdit,0,32767);		// Und selektieren				ModalDialog((ModalFilterProcPtr)OwnDialogFilter,&item);				if(item!=butCancel)				{					GetIText(iHandle,s);					if(!Numeric(s))					// Alpha-Zeichen drin?						temp=0;						// Dann Fontgröße = 0					else						StringToNum(s,&temp);		// Sonst der eingetippte Wert					if((temp<0) || (temp>MAX_FONT_SIZE) || ((temp>127) && BTstQ(gestaltAnswer,gestaltOutlineFonts)))						SysBeep(20);				// Bei illegalen Werten fiepen					else						tempSize=temp;				// Sonst übernehmen				}			}while((item!=butOK) && (item!=butCancel));			if(item==butOK)			{				setSomething=false;				ADOC.fontSize=tempSize;				for( i=1 ; i<anz ; i++ )				{					GetItem(m,i,s);						// Menu-Text holen					StringToNum(s,&num);					if((short)num==tempSize)					{						CheckItem(m,i,true);			// aktuelle Größe? Dann abhaken						setSomething=true;					}					else						CheckItem(m,i,false);				}				if(!setSomething)					CheckItem(m,anz+1,true);			}			SetPort(oldPort);			DisposeRgn(tempRgn);			DisposDialog(d);		}	}else	{		setSomething=false;						// Noch kein Haken gesetzt		for( i=1 ; i<anz ; i++ )		{			if(i==entry)			{				CheckItem(m,i,true);			// aktuelle Größe? Dann abhaken				GetItem(m,i,s);					// Menu-Text holen				StringToNum(s,&num);				if(gDoc)					ADOC.fontSize=(short)num;				gS.fontSize=(short)num;				setSomething=true;			}else				CheckItem(m,i,false);			// aktuelle Größe? Dann abhaken		}		if(!setSomething)						// Kein Haken gesetzt?			CheckItem(m,anz+1,true);			// Dann "Other" abhaken		else			CheckItem(m,anz+1,false);			// Sonst nicht	}	if(gDoc && (oldSizeGDoc!=ADOC.fontSize))	// Dokument vorhanden und Fontgröße hat sich geändert?	{		if(gTopWindow)		{			GrafPtr	oldPort;			Handle	xWindow=gTopWindow->MoreMem;						if(XWIN->windowType!=ANN1)			{				GetPort(&oldPort);				SetPort((GrafPtr)gTopWindow);				TextSize(ADOC.fontSize);				CalcSecondColumn((GrafPtr)gTopWindow);		// Position der 2. Spalte berechnen				SetPort(oldPort);			}		}		AppDocumentDirty(gDoc,true);			// Document ist jetzt dirty		// Redraw in allen Windows des aktuellen Dokuments		ForAllWindows(DoFontChange,gDoc,false);	}	if(oldSizePrefs!=gS.fontSize)				// Hat sich was an den Preferences geändert?		gSaveSettings=true;						// Dann Preferences dirty}void	OptionsMenu(int	entry){	switch(entry) {	case optLayout:			DoLayout();			break;	case optExpense:			DoExpenseList();			break;#if BETA && CACHE	case optCacheDisable:			SwitchCacheDisable();			break;	case optClearCache:			DoClearCache();			break;	case optCheckCache:			DoCheckCache();			break;#endif	default:			DoMoreOptions(entry);			break;	}}void	DoLayout(void){	OSErr		err;	DialogPtr	d;						// Ptr auf diverse Dialoge	short		button,temp;			// Exit-Button	ListHandle	l;						// für die Auswahllisten	Handle		xWindow;	WindPtr		firstWind;	datasetH	actset;	char		index[MaxIQFileType];	// Übersetzungstabelle: ListIndex => IQIndex	firstWind=gTopWindow;				// Windowtyp = Feldnamen	if(!firstWind)	{		SysBeep(20);		return;	}	xWindow=firstWind->MoreMem;	d = GetCenteredDialog(DLOGDarstellung,nil);	if (!d) return;						// Dialog nicht zu öffnen	actset=(dataset**)NewHandle(sizeof(dataset));	// Temporärer Buffer für Feldnamen	if(!actset)							// Kein Speicher, keine Ausgabe	{		DisposDialog(d);		SysBeep(20);		return;	}	HLock((Handle)actset);	FillOut(XWIN->windowType,actset);	// Feldnamen eintragen	l=NewList(d,4,false,true,0);			// UserItem, HSlider, VSlider	(*l)->selFlags = lNoExtend|lUseSense|lExtendDrag;	// Flags für Mehrfachselektierung	{	short i,j; Str255 s; Cell c;		temp=ADOC.display[XWIN->windowType];	// Alte Belegung (Bitarray)		for(i=0;i<MAX_NAMES;i++) {			if ((*actset)->text[i][0]==END_OF_LIST) break;// Ende der Liste			j = AddListMgr((char *)(PtoCstr((*actset)->text[i])),l);	// an die Liste anhängen			index[i-1] = j;						// Index merken			c.h = 0; c.v = j;			LSetSelect(BTstBool(temp,i),c,l);	// Zelle selecten, wenn nötig		}	}	DisposHandle((Handle)actset);	LDoDraw(true,l);	while (d) {		ModalDialog((ModalFilterProcPtr)OwnDialogFilter,&button);		if ((button==1)||(button==3)) break;	}	if (button == 1) {					// OK angeklickt		short	i; Cell c;				temp=0;		for(i=0;i<MAX_NAMES;i++) {			c.h = 0; c.v = i;		// ausgewählte Zellen merken			if(LGetSelect(false,&c,l)) // Zelle angewählt?				temp |= 1<<i;		// Dann Eintrag anzuzeigen		}		ADOC.display[XWIN->windowType]=temp;	// Neue Belegung (Bitarray)		BlockMoveData(ADOC.display,gS.display,sizeof(gS.display));	// selektierte Einträge		gSaveSettings = true;			// Einstellungen dirty				DoMultiRedraw(XWIN->windowType,redrawAndRecalc,nil);	// Redraw für alle Windows dieses Dokuments		AppDocumentDirty(gDoc,true);	// Document ist jetzt dirty	}	DisposeObjects(d);	DisposDialog(d);}////	Testet, ob übergebener Pascal-String was anderes als Ziffern enthält//Boolean	Numeric(Str255 s){	short		i;	Boolean		result=true;		for( i=1 ; result && (i<=s[0]) ; i++ )	{		if((s[i]<'0') || s[i]>'9')			result=false;	}	return(result);}#if BETA && CACHEvoid	SwitchCacheDisable(void){	MenuHandle	m=GetMHandle(mOptionen);	if((gCacheDisabled=!gCacheDisabled) == true)		CheckItem(m,optCacheDisable,true);	else		CheckItem(m,optCacheDisable,false);}void	DoClearCache(void){	REG Handle	xWindow;	REG short	err;	Str255		s;		if(!gTopWindow)	{		OwnBeep(negative);		return;	}	xWindow=gTopWindow->MoreMem;	if(!XWIN->cacheEnable)	{		OwnBeep(negative);		alert(1,"[1][Zu diesem Window existiert|kein Cache!][ Soso ]");		return;	}	if(!XWIN->theUnion.cache)	{		OwnBeep(negative);		alert(1,"[1][Zu diesem Window ist|momentan kein Cache|angelegt!][ Soso ]");		return;	}	DisposHandle((Handle)XWIN->theUnion.cache);	err=MemError();	if(err)	{		OwnBeep(negative);		sprintf((char*)s,"[1][Fehler beim Cache-|Freigeben. Wahrscheinlich|ungültige Handle:|%lX, Fehler %d][ Soso ]",XWIN->theUnion.cache,err);		alert(1,(char*)s);	}else		OwnBeep(positive);	XWIN->theUnion.cache=nil;}void	DoCheckCache(void){	REG Handle			xWindow;	Str255				s;	REG positionCacheP	actual;				// Pointer auf aktuell aufgebauten Cache-Eintrag	REG short			temp;				// Zahl der selektierten Einträge (xWindStruct)	ListH				lHandle;	Boolean				beeped=false;		if(!gTopWindow)	{		OwnBeep(negative);		alert(1,"[1][Kein Window offen,|also gibt's keinen|Cache!][ Ach ja! ]");		return;	}	xWindow=gTopWindow->MoreMem;	if(!XWIN->cacheEnable)	{		OwnBeep(negative);		alert(1,"[1][Zu diesem Window existiert|kein Cache!][ Soso ]");		return;	}	if(!XWIN->theUnion.cache)	{		OwnBeep(negative);		alert(1,"[1][Zu diesem Window ist|momentan kein Cache|angelegt!][ Soso ]");		return;	}	if(!*(XWIN->theUnion.cache))	{		OwnBeep(negative);		alert(1,"[1][Hier gibt's prinzipiell|einen Cache, der aber|gelöscht wurde!][ Aha ]");		return;	}		// Hier beginnt der eigentliche Check	biene();	HLock((Handle)XWIN->theUnion.cache);	// Locken, weil wir einen Pointer darauf brauchen	actual=*XWIN->theUnion.cache;			// Da isser schon	lHandle=GetListH(GetOrgH(gDoc),XWIN->windowType);	while(lHandle)				// Solange suchen, bis alle Zeilen durch	{		if(CheckEntry(lHandle,gTopWindow))		// Ist dieser Eintrag sichtbar?		{			HLock((Handle)lHandle);			if(actual->theLine!=EntryLength(lHandle,XWIN->windowType)+1)			{				if(!beeped)					OwnBeep(shit);				beeped=true;				sprintf((char*)s,"[0][Indifferenz bei|%lX: %ld≠%d][ Weiter | Löschen ]",lHandle,actual->theLine,EntryLength(lHandle,XWIN->windowType)+1);				if(alert(1,(char*)s)==2)				{					DisposHandle((Handle)XWIN->theUnion.cache);					HUnlock((Handle)lHandle);					HUnlock((Handle)XWIN->theUnion.cache);					pfeil();					return;				}			}; // 1 für Linie			if(actual++->theHandle!=lHandle)			{				if(!beeped)					OwnBeep(shit);				beeped=true;				sprintf((char*)s,"[0][Falsche Handle gecached:|%lX≠%lX][ Weiter | Löschen ]",(actual-1)->theHandle,lHandle);				if(alert(1,(char*)s)==2)				{					DisposHandle((Handle)XWIN->theUnion.cache);					HUnlock((Handle)lHandle);					HUnlock((Handle)XWIN->theUnion.cache);					pfeil();					return;				}			}			HUnlock((Handle)lHandle);		}		lHandle=NextListH(lHandle,getTheNextOne);	}	if(actual->theHandle || actual->theLine)	{		OwnBeep(shit);		beeped=true;		sprintf((char*)s,"[0][Cache falsch terminiert:|%lX,%d][ Ad acta ]",actual->theHandle,actual->theLine);		alert(1,(char*)s);	}	HUnlock((Handle)XWIN->theUnion.cache);			// Locken, weil wir einen Pointer darauf brauchen	pfeil();	if(!beeped)		OwnBeep(positive);}#endif