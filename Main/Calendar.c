////	Funktion zum Öffnen der Windows zum Dokument.//#include "GlobalDefines.h"#include "Geos.h"#include "xRsrcDefines.h"#include "Calendar.h"#include "Float.h"#include "Scheduler.h"#include "Utilities.h"#include "STDio.h"#include "AktDocStruct.h"#include "Options.h"#include "Memo.h"#include "String.h"#include "DialogLib.h"#include "MyPrint.h"#include "DoEvent.h"#include "Editor.h"#include "WindowsGlobal.h"#include "Windows.h"#include <Gestalt.h>#include <Balloons.h>#include "GlobalLib.h"WindPtr			gCalendarWindPtr;		// WindPtr während des Calendar-RedrawsBoolean			gCalendarMode=true;		// Mon to Sun // Bitbelegung im Calendar-Array — mit CalcMarks zu berechnen#define	VORMITTAG		1#define	NACHMITTAG		2#define	WITH_ANN1		4#define WITH_ANN2		8#define	PERIOD_START	16#define	PERIOD_MIDDLE	32#define	PERIOD_END		64#define TODO			128#define CAL_OFFSET		30		// Linker Rand des Kalenders#define TOP_OFFSET		20		// = Zeile der Wochentagsleiste#define TOP_DAY_OFFSET	20		// + TOP_OFFSET = Zeile des Kalenders#define BOX_HEIGHT		3		// Größe des Kästchens bei Terminen	OSErr	OpenCalendarWindows(void)		// Window öffnen {	WindPtr		w1;	short		theType;	Handle		dummy,xWindow;	DateTimeRec	actDate;	Rect		r;	w1 = MyOpenWind(TRUEDIALOG+128 | (1L<<noHSlider) | (1L<<noVSlider) | (1L<<noSizer) | (1L<<noShowWind),WindCalendar,strCalendar,ANN1);	// Window ohne alles 	if(!w1) 		return(memFullErr);						// Fehler beim Öffnen 		GetTime(&actDate);							// aktuelles Datum holen 	xWindow=w1->MoreMem;	XWIN->theUnion.schedule.day=actDate.day;	XWIN->theUnion.schedule.month=actDate.month;	XWIN->theUnion.schedule.year=actDate.year;	XWIN->theUnion.schedule.theSelectedDay=0;	// Kein Tag selektiert!	XWIN->theUnion.schedule.l=nil;				// Noch keine Liste angelegt!	XWIN->theUnion.schedule.list=nil;			// Noch keine Liste angelegt!	XWIN->theUnion.schedule.arrayCounter=0;		// Noch keine Liste angelegt!	XWIN->floatVar=MONTH_DEFAULT;				// Default = Monat	XWIN->floatDisp=ALL_DEFAULT;				// Default = Alles anzeigen	XWIN->lastKlick=-1;							// Noch nix angeklickt	XWIN->selectedNo=0;							// Nix selektiert	OpenFloatIfNecessary(w1);		// Redraw-Routine fürs User-Item	GetDItem((DialogPtr)w1,schUserItem,&theType,&dummy,&r);	SetDItem((DialogPtr)w1,schUserItem,theType,(Handle)calendardraw,&r);	SelectWind(w1);		WFUNC(w1,close,testclose);			// Schließroutine 	WFUNC(w1,button,calendarbutton);	WFUNC(w1,key,calendarkey);	WFUNC(w1,activ,testactivate);		// Zum Float-Update nötig	WFUNC(w1,menuupdate,calendarupdate);	// Darstellung enabeln etc.	WFUNC(w1,klick,calendarclick);	WFUNC(w1,rename,WindRename);		// Nach "Save as…"	return(noErr);						// alles ok! }////	Menüeinträge enabeln//void	calendarupdate(void){	MenuHandle	mHandle;		mHandle=GetMHandle(mOptionen);	DisableItem(mHandle,optLayout);		// Beim Calendar gibt es kein Darstellungs-Menü}////	Klick in den Kalender produziert Selektion oder Editor//void	calendarclick(void){	Point		location;	char		theDay,breite,**marks,notAgain;	Handle		xWindow,iHandle;	RgnHandle	oldClip;	short		zeilenHoehe,maxDays,iType;	Rect		theRect;	Boolean		schonBelegt,invalid;	long		whichIsSelected;	Cell		cell;			ListH		lHandle;	EditRetType	result;		if(!gMacWind)						// Klick in nicht existentes Fenster?	{		SysBeep(20);		return;	}	xWindow=gMacWind->MoreMem;	zeilenHoehe=XWIN->theUnion.schedule.zeilenHoehe;	breite=XWIN->theUnion.schedule.breite;		if(!breite || !zeilenHoehe)			// Klick ins Fenster, bevor zum ersten mal was		return;							// gezeichnet wurde? Dann raus…		maxDays=ndays[XWIN->theUnion.schedule.month-1];	// Wieviele Tage hat der akt. Monat?	if((XWIN->theUnion.schedule.month==2) && (!(XWIN->theUnion.schedule.year%4)))		maxDays++;									// Februar und Schaltjahr gibt einen Bonustag		location=gTheEvent.where;						// Wohin wurde geklickt?	GlobalToLocal(&location);	GetDItem((DialogPtr)gMacWind,schUserItem,&iType,&iHandle,&theRect);	// Rechteck des Useritems	if(!PtInRect(location,&theRect))				// Der Klick war nicht ins UserItem?		return;	notAgain=theDay=0;			// Ständiges Flackern bei nicht bewegter Maus verhindern	do	{		invalid=false;		switch(XWIN->floatVar)		{		case flDay:						// In der Tagesübersicht macht der ListManager alles für uns			if(XWIN->theUnion.schedule.list)			{				if(LClick(location,gTheEvent.modifiers,XWIN->theUnion.schedule.list))				{					cell=LLastClick(XWIN->theUnion.schedule.list);					if((cell.v>=0) && (cell.v<=MAX_ITEMS_IN_DAY_LIST))					{						lHandle=(*(XWIN->theUnion.schedule.l))[cell.v];							result=Editor(lHandle,(*lHandle)->type,nil);	// Editor aufrufen						if(result.redrawNecessary)			// Noch ein Redraw nötig?							if(result.recalcNecessary)		// Hat sich evtl. die Länge geändert?							{								DoMultiRedraw(SCHEDULE,redrawAndRecalc,nil);								DoMultiRedraw(ANN1,redrawAndRecalc,nil);							}							else								DoMultiRedraw(SCHEDULE,redrawSingle,lHandle);						UnloadSeg(Editor);					}				}			}			invalid=true;			break;		case flWeek:			if((location.v-=TOP_OFFSET+zeilenHoehe)<0)	// Liegt der Klick im Kalender?				invalid=true;			if(location.v>zeilenHoehe*7-1)				// Zu weit unten				invalid=true;			if(!invalid)				theDay=location.v/zeilenHoehe+XWIN->theUnion.schedule.day;	//		if(theDay>maxDays)							// Tag liegt hinter dem letzten im Monat	//			if((++XWIN->theUnion.schedule.month)>12)	//				XWIN->theUnion.schedule.year++;			break;		case flMonth:			if((location.v-=TOP_OFFSET+TOP_DAY_OFFSET)<0)	// Liegt der Klick im Kalender?				invalid=true;			if((location.h-=CAL_OFFSET+breite)<0)		// Zu weit links…				invalid=true;			if(location.h>breite*7)						// …oder rechts…				invalid=true;			if(location.h%breite>breite*MONTH_SEL_RANGE-1)	// Zwischen zwei Feldern				invalid=true;			if(!invalid)				theDay=location.v/zeilenHoehe*7+location.h/breite+2-XWIN->theUnion.schedule.woTag;			if((theDay>maxDays) || (theDay<1))			// Tag liegt hinter dem letzten im Monat				invalid=true;			break;		}						if((gClicks==2) && !invalid)					// Beim Doppelklick den Editor starten		{			marks=CalcMarks(XWIN->theUnion.schedule.year,XWIN->theUnion.schedule.month,XWIN->theUnion.schedule.woTag);	// Termine für diesen Monat raussuchen			schonBelegt=marks && (*marks)[theDay-1] & (VORMITTAG+NACHMITTAG);		// Liegt auf dem Tag ein Termin?			EditSchedule(XWIN->theUnion.schedule.year,(char)XWIN->theUnion.schedule.month,theDay,schonBelegt);					if(marks)				DisposHandle((Handle)marks);				return;		}			if(notAgain!=theDay)		{			GetDItem((DialogPtr)gMacWind,schUserItem,&iType,&iHandle,&theRect);	// Rechteck des Useritems			theRect.top=theRect.bottom-zeilenHoehe;			EraseRect(&theRect);					switch(XWIN->floatVar)			{			case flWeek:				if(XWIN->theUnion.schedule.theSelectedDay && 				(XWIN->theUnion.schedule.theSelectedDay<XWIN->theUnion.schedule.day+7) &&				(XWIN->theUnion.schedule.theSelectedDay>=XWIN->theUnion.schedule.day))			// Ist ein Tag selektiert?				{					GetDItem((DialogPtr)gMacWind,schUserItem,&iType,&iHandle,&theRect);	// Rechteck des Useritems					oldClip=NewRgn();					if(MemError()!=noErr)						return;					GetClip(oldClip);					theRect.top+=TOP_OFFSET;					theRect.bottom=theRect.top+8*zeilenHoehe;					ClipRect(&theRect);					theRect.top=(XWIN->theUnion.schedule.theSelectedDay-XWIN->theUnion.schedule.day+1)*zeilenHoehe+TOP_OFFSET;					theRect.bottom=theRect.top+zeilenHoehe;					LMSetHiliteMode(LMGetHiliteMode() & ~(1<<hiliteBit));					InvertRect(&theRect);							// Selektierten Tag invertieren					SetClip(oldClip);					DisposeRgn(oldClip);				}				if(invalid)					XWIN->theUnion.schedule.theSelectedDay=0;				else				{					if(XWIN->theUnion.schedule.theSelectedDay==theDay)	// Gleichen Tag nochmal angeklickt?						XWIN->theUnion.schedule.theSelectedDay=0;		// Dann jetzt keiner mehr selektiert					else					{						XWIN->theUnion.schedule.theSelectedDay=theDay;						theRect.top=(XWIN->theUnion.schedule.theSelectedDay-XWIN->theUnion.schedule.day+1)*zeilenHoehe+TOP_OFFSET;						theRect.bottom=theRect.top+zeilenHoehe;						LMSetHiliteMode(LMGetHiliteMode() & ~(1<<hiliteBit));						InvertRect(&theRect);							// Selektierten Tag invertieren						XWIN->theUnion.schedule.theSelectedDay=theDay;						DisplayDaysLeft(gMacWind,theDay);					}				}				break;			case flMonth:				if((XWIN->theUnion.schedule.theSelectedDay>0) && (XWIN->theUnion.schedule.theSelectedDay<=maxDays))				{					theRect.top=(XWIN->theUnion.schedule.theSelectedDay+XWIN->theUnion.schedule.woTag-2)/7*zeilenHoehe+TOP_OFFSET+TOP_DAY_OFFSET;					theRect.bottom=theRect.top+zeilenHoehe;					theRect.left=(XWIN->theUnion.schedule.theSelectedDay+XWIN->theUnion.schedule.woTag-2)%7*breite+CAL_OFFSET+breite-1;					theRect.right=theRect.left+breite*MONTH_SEL_RANGE;					LMSetHiliteMode(LMGetHiliteMode() & ~(1<<hiliteBit));					InvertRect(&theRect);							// Selektierten Tag invertieren				}				if(invalid)					XWIN->theUnion.schedule.theSelectedDay=0;				else				{					if(XWIN->theUnion.schedule.theSelectedDay==theDay)	// Gleichen Tag nochmal angeklickt?						XWIN->theUnion.schedule.theSelectedDay=0;		// Dann jetzt keiner mehr selektiert					else					{						theRect.top=(theDay+XWIN->theUnion.schedule.woTag-2)/7*zeilenHoehe+TOP_OFFSET+TOP_DAY_OFFSET;						theRect.bottom=theRect.top+zeilenHoehe;						theRect.left=(theDay+XWIN->theUnion.schedule.woTag-2)%7*breite+CAL_OFFSET+breite-1;						theRect.right=theRect.left+breite*MONTH_SEL_RANGE;						LMSetHiliteMode(LMGetHiliteMode() & ~(1<<hiliteBit));						InvertRect(&theRect);							// Angeklickten Tag invertieren						XWIN->theUnion.schedule.theSelectedDay=theDay;						DisplayDaysLeft(gMacWind,theDay);					}				}				break;			}		}		GetMouse(&location);			// Neue Mausposition		notAgain=theDay;	}while(WaitMouseUp());				// Bis Button losgelassen}void	DisplayDaysLeft(WindPtr w,char theDay){	Handle		xWindow,iHandle;	Str255		s,s2;	FontInfo	inf;	GrafPtr		oldPort;	datumRec	actualDate;	short		iType,saveFont,saveSize;	Rect		infoRect;		xWindow=w->MoreMem;	GetDItem((DialogPtr)w,schUserItem,&iType,&iHandle,&infoRect);	// Rechteck des Useritems	infoRect.top=infoRect.bottom-XWIN->theUnion.schedule.zeilenHoehe;	actualDate.year=XWIN->theUnion.schedule.year;	actualDate.month=XWIN->theUnion.schedule.month;	actualDate.day=theDay;	CalcDate(&actualDate);							// Tag im Jahr berechnen	NumToString((long)actualDate.dayInYear,s);	s2[0]=1; s2[1]='[';								// String im Format "[1/364]" basteln	ConcatPString(s2,s);	s2[++s2[0]]='/';	NumToString((long)actualDate.daysLeft,s);	ConcatPString(s2,s);	s2[++s2[0]]=']';	infoRect.left=infoRect.right-TextWidth(s2,1,s2[0]);	GetPort(&oldPort);	saveFont=oldPort->txFont;	saveSize=oldPort->txSize;	TextFont(courier);						// Font setzen	TextSize(12);	GetFontInfo(&inf);	MoveTo(infoRect.left,infoRect.top+inf.ascent);	DrawString(s2);	TextFont(saveFont);	TextSize(saveSize);}pascal void calendardraw(WindPtr w,int item){	DateTimeRec	actDate;	Str63		s;	short		iType,font,saveFont,saveSize,merkTag;	Handle		iHandle,xWindow;	Rect		iRect;	RgnHandle	tempRgn;	GrafPtr		oldPort;	DocHandle	saveDoc = gDoc;		// aktuelles Dokument merken	if((gCalendarWindPtr=w)==nil)		return;	SetDoc(w->Doc);					// dazugehöriges Dokument setzen#if 0	GetDItem((DialogPtr)w, schWeek, &iType, &iHandle, &iRect);	PenMode(patBic);						// "Woche" sozusagen disabeln	PenPat(gray);	PaintRect(&iRect);	PenPat(black);	PenMode(patOr);#endif	GetDItem((DialogPtr)w, schUserItem, &iType, &iHandle, &iRect);	tempRgn=NewRgn();	GetClip(tempRgn);						// Clipping aufs UserItem	ClipRect(&iRect);	GetPort(&oldPort);	saveFont=oldPort->txFont;	saveSize=oldPort->txSize;	TextFont(courier);						// Font setzen	TextSize(12);	xWindow=w->MoreMem;	actDate.year=XWIN->theUnion.schedule.year;	actDate.month=XWIN->theUnion.schedule.month;	actDate.day=XWIN->theUnion.schedule.day;	merkTag=actDate.day;	actDate.day=1;	CalcDate((datumRec *)&actDate);			// Wochentag vom Monatsersten berechnen	actDate.day=merkTag;	switch(XWIN->floatVar)	{	case flDay:		DrawDay(w,(datumRec *)&actDate,&iRect);		break;	case flWeek:		DrawWeek(w,(datumRec *)&actDate,&iRect);		break;	case flMonth:		DrawCalendar(w,(datumRec *)&actDate,&iRect);		break;	}		TextFont(saveFont);	TextSize(saveSize);	SetClip(tempRgn);	DisposeRgn(tempRgn);	SetDoc(saveDoc);}Boolean calendarkey(void){	Str255		s;	char		*temp;	short		i;	static short	whichbutton[8]={schWeekPlus,schWeekMinus,schMonthPlus,		schMonthMinus,schYearPlus,schYearMinus,schEnter,schToday};		#define BUTTON_NO	7		// Anzahl der Buttons im Kalender -1		if(gTheEvent.modifiers & (controlKey | optionKey | cmdKey))		return(true);			// Umschalttaste? Dann nicht für uns		if(gTheEvent.what != keyDown)			// Kein Autokey		return(true);	GetIndString(s,strSearchStrings,strCalendarKeys);	// String mit den Tasten	PtoCstr(s);	temp=strchr((char*)s,(char)(gTheEvent.message & charCodeMask));		if(!temp)								// Taste nicht im String?		return(true);						// Dann nicht für uns		if((i=temp-(char*)s) > BUTTON_NO) return(true);	// String ist defekt		i=whichbutton[i];						// Eintragsnummer in Buttonnummer umrechnen	SelectControl(GetCH((DialogPtr)gTopWindow,i));	// Button selektieren	calendarbutton(i);						// Und ausführen	return(false);							// Taste fertig ausgewertet}void calendarbutton(long item){	short			day,month,year,dummy,maxDays;	char			dayTemp,monthTemp;	short			yearTemp,weeklength;	Handle			xWindow;	Str255			s;	DateTimeRec		shortDateTime;	unsigned long	date;	Point			location;		xWindow=gMacWind->MoreMem;	year=XWIN->theUnion.schedule.year;	month=XWIN->theUnion.schedule.month;	if((XWIN->theUnion.schedule.theSelectedDay>0) && (XWIN->floatVar==flMonth))		day=XWIN->theUnion.schedule.theSelectedDay;	else		day=XWIN->theUnion.schedule.day;		// Sonst der angezeigte Tag	if((XWIN->windowType==ANN1) && (XWIN->theUnion.schedule.list) &&		((item==schSecondUserItem) || (item==schUserItem)))	{		location=gTheEvent.where;				// Klick in die Tagesübersicht		GlobalToLocal(&location);		LClick(location,gTheEvent.modifiers,XWIN->theUnion.schedule.list);		return;	}		maxDays=ndays[month-1];	if((month==2) && !(year % 4))				// Schaltjahr 		maxDays++;		if(XWIN->floatVar==flDay)					// Tagesübersicht aktiviert?		weeklength=1;							// Dann tageweise blättern	else		weeklength=7;							// Sonst in Wochen…		switch(item)	{	case schWeekMinus:		if(XWIN->theUnion.schedule.theSelectedDay || (day && (XWIN->floatVar!=flMonth)))	// Nur, wenn überhaupt ein Tag selektiert ist		{			if(day>weeklength)					// Liegt der Zieltag noch in diesem Monat?				day-=weeklength;				// Dann einfach Wochenlänge abziehen			else			{				if(month>1)						// Sonst: Liegt er noch in diesem Jahr?				{					month--;					// Dann einen Monat vorher					maxDays=ndays[month-1];		// Wieviele Tage hat der Zielmonat?					if((month==2) && !(year % 4))	// Schaltjahr						maxDays++;					day=maxDays+day-weeklength;	// Zieltag errechnen				}else				if(year>MIN_YEAR)				// Letzter Versuch: Liegt er noch im gültigen Datumsbereich?				{					month=12;					// Dann liegt er im Dezember					year--;					maxDays=31;					day=31-weeklength+day;		// Dezember hat immer 31 Tage				}			}		}		break;	case schWeekPlus:		if(XWIN->theUnion.schedule.theSelectedDay || (day && (XWIN->floatVar!=flMonth)))	// Nur, wenn überhaupt ein Tag selektiert ist		{			if(day+weeklength<=maxDays)				day+=weeklength;			else			{				if(month<12)				{					month++;					day=day+weeklength-maxDays;					maxDays=ndays[month-1];					if((month==2) && !(year % 4))	// Schaltjahr 						maxDays++;				}				else					if(year<MAX_YEAR)					{						month=1;						year++;						day=day+weeklength-maxDays;						maxDays=31;					}			}		}		break;	case schMonthMinus:		if(month>1)			month--;		else			if(year>MIN_YEAR)			{				month=12;				year--;			}		break;	case schMonthPlus:		if(month<12)			month++;		else			if(year<MAX_YEAR)			{				month=1;				year++;			}		break;	case schYearMinus:		if(year>MIN_YEAR)			year--;		AlignWeek(xWindow);		break;	case schYearPlus:		if(year<MAX_YEAR)			year++;		break;	case schEnter:		GetDateTime(&date);							// default ist akt. Datum		GetDateString(s,date,shortDate);		if(GetUserDate(s))		{			PtoCstr(s);			if(!DateToList((char*)s,strlen((char*)s),&yearTemp,&monthTemp,&dayTemp,true))			{				year=yearTemp;				month=monthTemp;				day=dayTemp;			}		}		break;	case schToday:		GetDateTime(&date);				// Auf heutiges Datum setzen		Secs2Date(date,&shortDateTime);	// Jahr und Monat berechnen		year=shortDateTime.year;		month=shortDateTime.month;		day=shortDateTime.day;		break;	}		// Durch monats- oder jahresweises (Schaltjahr!) Blättern kann "day" ungültig sein.	maxDays=ndays[month-1];	if((month==2) && !(year % 4))			// Schaltjahr 		maxDays++;	if(day>maxDays)		day=maxDays;		if(XWIN->floatVar!=flMonth)			// Datum aus temporären Variablen in eigentliche		XWIN->theUnion.schedule.day=day;// Struktur zurückschreiben	else		if(XWIN->theUnion.schedule.theSelectedDay)			XWIN->theUnion.schedule.theSelectedDay=day;	XWIN->theUnion.schedule.month=month;	XWIN->theUnion.schedule.year=year;	if((XWIN->theUnion.schedule.theSelectedDay>maxDays) && (XWIN->floatVar!=flWeek))		XWIN->theUnion.schedule.theSelectedDay=maxDays;	// Nicht hinter dem letzten Tag selektieren		switch(XWIN->floatVar)	{	case flDay:		UpdateDay(gMacWind);		// Tagesübersicht? Dann auf neuen Tag anpassen		break;	case flWeek:		AlignWeek(xWindow);			// Wochenübersicht? Dann auf Wochenanfang setzen		break;	}	calendardraw(gMacWind,schUserItem);		// Redraw direkt ausführen}Boolean	GetUserDate(Str255 s){	DialogPtr	d;	short		item,iType;	Rect		iRect;	Handle		iHandle;	d = GetCenteredDialog(DLOGUserDate,nil);	if (d) {									// Dialog vorhanden?		GetDItem(d,userDateEdit,&iType,&iHandle,&iRect);		SetIText(iHandle,s);				// ins Edit-Feld schreiben		SelIText(d,userDateEdit,0,32767);	// Und selektieren		do{			ModalDialog((ModalFilterProcPtr)OwnDialogFilter,&item);			if(item!=userDateCancel)				GetIText(iHandle,s);		}while((item!=userDateOK) && (item!=userDateCancel));		DisposDialog(d);	}	return(item==userDateOK);}////	Editoraufruf für Scheduler-Eintrag; Startdatum wird übergeben//void	EditSchedule(short year,char month,char day,Boolean	schonBelegt){	EditRetType	result;	ListH		lHandle;	Handle		xWindow;	DateTimeRec	defaultDate;	unsigned long	secs;		if(schonBelegt)	{		lHandle=ORG.schedule;					// Nur normale Termine durchsuchen		if(!CheckEntry(lHandle,gMacWind))		// Erster Eintrag nicht sichtbar?			lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen		while(lHandle && (((*lHandle)->t.schedule.year!=year)	// Durchsuchen bis fündig…						|| ((*lHandle)->t.schedule.month!=month)						|| ((*lHandle)->t.schedule.day!=day)))			lHandle=NextListH(lHandle,getTheNextOne);				if(!lHandle)						// Doch nix gefunden = Systemfehler		{			SysBeep(20);			return;		}		result=Editor(lHandle,SCHEDULE,nil);	// Editor aufrufen		}else	{		defaultDate.second=defaultDate.minute=defaultDate.hour=0;		defaultDate.year=year;		defaultDate.month=month;		defaultDate.day=day;		Date2Secs(&defaultDate,&secs);			// Durch diese Wandlungen werden Überläufe		Secs2Date(secs,&defaultDate);			// (36.3.) korrigiert		result=Editor(nil,SCHEDULE,&defaultDate);	// Editor aufrufen	}		if(result.redrawNecessary)			// Noch ein Redraw nötig?		if(result.recalcNecessary)		// Hat sich evtl. die Länge geändert?			DoMultiRedraw(SCHEDULE,redrawAndRecalc,nil);		else			DoMultiRedraw(SCHEDULE,redrawSingle,lHandle);	UnloadSeg(Editor);}////	ShowDayNames zeigt alle Wochentagsnamen (2 Buchstaben) an//void	ShowDayNames(short zeile, short spalte, short breite, Boolean senkrecht){	Intl1Hndl	handle;	unsigned char	s[3];	REG int		i;		if(gS.language>=LANG_OFFSET)		handle=(Intl1Hndl)GetResource('itl1',MenuToLanguageCode(gS.language));	else		handle=(Intl1Hndl)GetResource('itl1',MenuToLanguageCode(LANG_OFFSET+3));	if(handle==nil)		return;		s[0]=2;							// Pascal-String generieren		for(i=gCalendarMode?1:0 ; i<7 ; i++ )	{		s[1]=(**handle).days[i][1];	// Erste 2 Zeichen kopieren 		s[2]=(**handle).days[i][2];				if(senkrecht)			zeile+=breite;		else			spalte+=breite;		MoveTo(spalte,zeile);		DrawString(s);	}	if(gCalendarMode)				// Montag … Sonntag -> noch Sonntag ausgeben 	{		s[1]=(**handle).days[0][1];	// Erste 2 Zeichen kopieren 		s[2]=(**handle).days[0][2];				if(senkrecht)			zeile+=breite;		else			spalte+=breite;		MoveTo(spalte,zeile);		DrawString(s);	}	ReleaseResource((Handle)handle);}////	CalcMarks berechnet die Termine, die in einem Monat anfallen, um//	entsprechende Markierungen zu zeichnen.//	Übergeben werden Jahr und Monat und der Wochentag des ersten Tags des//	fraglichen Monats//char **CalcMarks(short year, short month,short dayOfWeek){	char		**marks;				// Handle auf Markierungsarray	char		*markP;					// Pointer (damit's schneller geht)	short		i,j;					// div. Zähler	short		dateInMonths,sdate,edate;	// Für periodische	Boolean		foundOne;				// Zum Abkürzen des Listendurchsuchen	ListH		termin;					// Zum Durchhangeln durch alle Termine	unsigned long today,dayInQuestion;	// Für ToDo's	DateTimeRec	dateTime;		marks=NewHandle(31);				// Platz für 31 Tage	if(MemError()!=noErr)		return(nil);					// Kein Speicher, dann nil		HLockH(marks);						// Einmal dereferenzieren, da wir das	markP=*marks;						// Teil häufiger brauchen	for( i=0 ; i<31 ; markP[i++]=0) ;	// Löschen		foundOne=false;	termin=ORG.schedule;	while(termin && !CheckEntry(termin,gCalendarWindPtr))		termin=(*termin)->next;		// Nicht NextListH, da kein Gruppenwechsel erwünscht	while(termin)						// Erstmal alle normalen Termine	{		if(((*termin)->t.schedule.year==year) && ((*termin)->t.schedule.month==month))		{			foundOne=true;				// Gaudeamus igitur			if((*termin)->t.schedule.shour<12)	// Vormittagstermin?				markP[(*termin)->t.schedule.day-1]|=VORMITTAG;			else				markP[(*termin)->t.schedule.day-1]|=NACHMITTAG;		}else							// Nicht im akt. Monat, aber			if(foundOne)				// schon mal was gefunden?				termin=nil;				// Dann wird auch nix mehr kommen, da sortierte Liste				if(termin)			do{				termin=(*termin)->next;	// Nicht NextListH, da kein Gruppenwechsel erwünscht			}while(termin && !CheckEntry(termin,gCalendarWindPtr));	}	foundOne=false;	termin=ORG.ann1;	while(termin)						// Dann alle Anniversary 1	{		if((*termin)->t.ann1.month==month)		{			foundOne=true;				// Gaudeamus igitur			markP[(*termin)->t.ann1.date-1]|=WITH_ANN1;		}else							// Nicht im akt. Monat, aber			if(foundOne)				// schon mal was gefunden?				termin=nil;				// Dann wird auch nix mehr kommen, da sortierte Liste				if(termin)			termin=(*termin)->next;	// Nicht NextListH, da kein Gruppenwechsel erwünscht	}	foundOne=false;	termin=ORG.ann2;	while(termin)						// Nun kommen die Ann2	{		if((*termin)->t.ann2.month==month)		{			foundOne=true;				// Gaudeamus igitur			i=((*termin)->t.ann2.week)*7+(*termin)->t.ann2.day-dayOfWeek+1;			if((*termin)->t.ann2.day>=dayOfWeek-1)				i-=7;			markP[i]|=WITH_ANN2;		}else							// Nicht im akt. Monat, aber			if(foundOne)				// schon mal was gefunden?				termin=nil;				// Dann wird auch nix mehr kommen, da sortierte Liste				if(termin)			termin=(*termin)->next;	// Nicht NextListH, da kein Gruppenwechsel erwünscht	}	termin=ORG.period;	dateInMonths=year*12+month;	while(termin)						// Zu guter Letzt die periodischen	{		sdate=(*termin)->t.psched.syear*12+(*termin)->t.psched.smonth;		edate=(*termin)->t.psched.eyear*12+(*termin)->t.psched.emonth;		if((sdate<=dateInMonths) && (dateInMonths<=edate))		{			// Der Termin liegt irgendwie im akt. Monat			if(sdate==dateInMonths)			// Beginnt in diesem Monat			{				i=(*termin)->t.psched.sday;				markP[i-1]|=PERIOD_START;			}else				i=0;			if(edate==dateInMonths)			// Endet in diesem Monat			{				j=(*termin)->t.psched.eday-2;				markP[j+1]|=PERIOD_END;			}else				j=30;						for( ; i<=j ; markP[i++]|=PERIOD_MIDDLE ) ; // Und noch das dazwischen markieren		}				termin=(*termin)->next;	// Nicht NextListH, da kein Gruppenwechsel erwünscht	}	foundOne=false;	termin=ORG.todo;	while(termin && !CheckEntry(termin,gCalendarWindPtr))		termin=(*termin)->next;	while(termin)						// Erstmal alle normalen Termine	{		if(((*termin)->t.schedule.year==year) && ((*termin)->t.schedule.month==month))		{			foundOne=true;				// Gaudeamus igitur			markP[(*termin)->t.schedule.day-1]|=TODO;		}else							// Nicht im akt. Monat, aber			if(foundOne)				// schon mal was gefunden?				termin=nil;				// Dann wird auch nix mehr kommen, da sortierte Liste				if(termin)			do{				termin=(*termin)->next;			}while(termin && !CheckEntry(termin,gCalendarWindPtr));	}	// Sonderfallbehandlung: Wenn heute angezeigt wird und es terminlose oder verstrichene	// Aufgaben gibt, dann wird beim heutigen Tag ein Strich angezeigt.	GetDateTime(&today);									// Tag in Sekunden…	Secs2Date(today,&dateTime);								// … und als DateTimeRec holen	if((month==dateTime.month) && (year==dateTime.year) && (!(markP[j=(dateTime.day-1)]&TODO)))	// Liegt heute im untersuchten Monat?	{		foundOne=false;		termin=ORG.todo;		while(termin && !CheckEntry(termin,gCalendarWindPtr))			termin=(*termin)->next;		while(termin)		{			if((*termin)->t.todo.year<=0)				// Kein Termin?				foundOne=true;			else			{				if(((char)(*termin)->t.todo.prio)!=(char)'√')				{					dateTime.year=(*termin)->t.todo.year;		// Tag der Aufgabe in Sekunden wandeln					dateTime.month=(*termin)->t.todo.month;					dateTime.day=(*termin)->t.todo.day;					Date2Secs(&dateTime,&dayInQuestion);					if(today>dayInQuestion)						// Der Termin ist schon verstrichen?						foundOne=true;				}			}						if(foundOne)			{				markP[j]|=TODO;			// Markierung bei heute setzen (j wurde im IF definiert)				termin=nil;				// Dann wird auch nix mehr kommen, da sortierte Liste			}else				do{					termin=(*termin)->next;				}while(termin && !CheckEntry(termin,gCalendarWindPtr));		}	}		HUnlock((Handle)marks);	return(marks);}////	DrawCalendar zeichnet einen Kalender für einen Monat im aktuellen//  Fenster. Übergeben wird eine datumRec-Struktur für den 1. des Monats//	ACHTUNG: die datumRec-Struktur kann dabei verändert werden!//void	DrawCalendar(WindPtr w,datumRec *datum,Rect *iRect){	short		woTag,tage,i,x;		// Dies und das 	short		zeile,woche,zeilenHoehe,breite,iType;	FontInfo	inf;	Str63		s,s2;	ULONG		date;				// Heutiges Datum (da in fett darzustellen)	DateTimeRec	shortDateTime;	char		day;	char		**marks,todaysMark;	// Markierungs-Bits für Termine	Rect		theRect;			// Für Terminkästchen	Style		style;	Handle		xWindow,iHandle;		GetDItem((DialogPtr)w, schUserItem, &iType, &iHandle, &theRect);	EraseRect(&theRect);	marks=CalcMarks(datum->year,datum->month,datum->dayOfWeek);	// Termine für diesen Monat raussuchen		GetDateTime(&date);				// heutiges Datum abfragen	Secs2Date(date,&shortDateTime);	// in DateTimeRec wandeln	if((shortDateTime.year==datum->year) &&		(shortDateTime.month==datum->month))	// Liegt heute im angezeigtern Monat?			day=shortDateTime.day;				// Dann heutigen Tag merken		else			day=0;								// Sonst disablen	if(gCalendarMode)				//  Montag bis Sonntag erwünscht? 	{		if(!(woTag=--datum->dayOfWeek))	// Dann Mac-Format umrechnen 			woTag=7;				// 1=Montag … 7=Sonntag 	}else		woTag=datum->dayOfWeek;		tage=ndays[datum->month-1];		// Tage in diesem Monat 	if((datum->month==2) && !(datum->year % 4))	// Schaltjahr 		tage++;	#if 0//BETA	if(date>0xA7175BD4+86400*90)				// Ende des Beta-Tests…		Exit();#endif	breite=CharWidth('x')*4;		// Breite eines Tags = 4 Zeichen 	GetFontInfo(&inf);				// Höhe des aktuellen Fonts	zeilenHoehe=inf.ascent+inf.descent+inf.leading;	zeile=TOP_OFFSET+TOP_DAY_OFFSET+inf.ascent+inf.leading;	// Erste Zeile	xWindow=w->MoreMem;	XWIN->theUnion.schedule.zeilenHoehe=zeilenHoehe;	XWIN->theUnion.schedule.breite=(char)breite;	XWIN->theUnion.schedule.woTag=(char)woTag;	NumToString(datum->month,s);	NumToString(datum->year,s2);	ConcatPString(s,"\p / ");	ConcatPString(s,s2);	i=StringWidth(s);	MoveTo((iRect->right-iRect->left-i)/2,zeilenHoehe);	DrawString(s);		ShowDayNames(TOP_OFFSET+zeilenHoehe,CAL_OFFSET,breite,false);	// Tagesnamen in Zeile 10 ausgeben 	woche=datum->week;					// Nummer der ersten Woche 	MoveTo(CAL_OFFSET-breite/2,zeile);	// Wochennummer ausgeben 	sprintf((STR)s,"%2d",woche++);		// Woche 2-stellig 	DrawString((StringPtr)CtoPstr((STR)s));	for(i=1,s[0]=0 ; i<=tage ; i++)		// Jeden Tag ausgeben	{		if(marks)						// Markierungen zu vermelden?			todaysMark=(*marks)[i-1];		else			todaysMark=0;		sprintf((STR)s,"%2d",i);		// Tag 2-stellig 		x=woTag*breite+CAL_OFFSET;		// x-Koordinate dieses Tags		style=0;		if(day==i)		{			style=bold;					// Heute in Fettschrift			x--;						// Ein bißchen zentrieren		}		if(todaysMark & (WITH_ANN1+WITH_ANN2))			style|=italic;		if(todaysMark & (PERIOD_START+PERIOD_END+PERIOD_MIDDLE))			style|=underline;		TextFace(style);		CtoPstr((STR)s);		MoveTo(x,zeile);		DrawString(s);					// Tag für Tag ausgeben		TextFace(0);				if(todaysMark & VORMITTAG)		{			theRect.left=woTag*breite+CAL_OFFSET+1+TextWidth(s,1,s[0]);			theRect.right=theRect.left+BOX_HEIGHT;			theRect.top=zeile-inf.ascent+1;			theRect.bottom=theRect.top+BOX_HEIGHT;			PaintRoundRect(&theRect,2,2);		}		if(todaysMark & NACHMITTAG)		{			theRect.left=woTag*breite+CAL_OFFSET+1+TextWidth(s,1,s[0]);			theRect.right=theRect.left+BOX_HEIGHT;			theRect.bottom=zeile;			theRect.top=theRect.bottom-BOX_HEIGHT;			PaintRoundRect(&theRect,2,2);		}		if(todaysMark & TODO)		{			theRect.left=woTag*breite+CAL_OFFSET+TextWidth(s,1,s[0])+BOX_HEIGHT+2;			theRect.right=theRect.left+1;			theRect.bottom=zeile-BOX_HEIGHT+2;			theRect.top=theRect.bottom-inf.ascent+2*BOX_HEIGHT-2;			PaintRect(&theRect);		}		if(XWIN->theUnion.schedule.theSelectedDay==i)	// Tag ist selektiert?		{			theRect.left=x;			if((day!=i) || !day)						// Beim akt. Tag (Fettschrift)				theRect.left--;							// Linksrücken ausgleichen			theRect.bottom=zeile+inf.descent+inf.leading;			theRect.top=zeile-inf.ascent;			theRect.right=theRect.left+breite*MONTH_SEL_RANGE;			LMSetHiliteMode(LMGetHiliteMode() & ~(1<<hiliteBit));			InvertRect(&theRect);		}				if((++woTag==8) && (i!=tage))	// Eine Woche voll 		{			woTag=1;			zeile+=zeilenHoehe;			// Neue Zeile 			if(woche>1)					// Ab Woche 52 kann das neue Jahr beginnen 			{				datum->day=i+1;			// Daher Woche neu berechnen 				CalcDate(datum);				woche=datum->week;			}			MoveTo(CAL_OFFSET-breite/2,zeile);	// Wochennummer ausgeben 			sprintf((STR)s,"%2d",woche++);	// Woche 2-stellig 			DrawString((StringPtr)CtoPstr((STR)s));		}	}	if((XWIN->theUnion.schedule.theSelectedDay>0) && (XWIN->theUnion.schedule.theSelectedDay<=tage))		DisplayDaysLeft(w,XWIN->theUnion.schedule.theSelectedDay);	if(marks)		DisposeHandle(marks);}////	DrawWeek zeichnet einen Kalender für eine Woche im aktuellen//  Fenster. Übergeben wird eine datumRec-Struktur für den 1. der Woche//	ACHTUNG: die datumRec-Struktur kann dabei verändert werden!//void	DrawWeek(WindPtr w,datumRec *datum,Rect *iRect){	short		woTag,tage,theDay,i,x;		// Dies und das 	short		zeile,woche,zeilenHoehe,breite,anz,maxAnz,iType;	long		dateInMonths,sdate,edate;	// Für periodische	FontInfo	inf;	Str63		s,s2;	unsigned long	date;				// Heutiges Datum (da in fett darzustellen)	unsigned long	dayInQuestion;		// Für ToDo	DateTimeRec	shortDateTime;	char		day;	char		**marks,todaysMark;	// Markierungs-Bits für Termine	Rect		theRect;			// Für Terminkästchen	Style		style;	Handle		xWindow,iHandle;	ListH		lHandle;	RgnHandle	oldClip;	WindPtr		oldGMacWind;		if(w==nil)		return;		GetDItem((DialogPtr)w, schUserItem, &iType, &iHandle, &theRect);	EraseRect(&theRect);	marks=CalcMarks(datum->year,datum->month,datum->dayOfWeek);	// Termine für diesen Monat raussuchen		GetDateTime(&date);				// heutiges Datum abfragen	Secs2Date(date,&shortDateTime);	// in DateTimeRec wandeln	if((shortDateTime.year==datum->year) &&		(shortDateTime.month==datum->month))	// Liegt heute im angezeigten Monat?			day=shortDateTime.day;				// Dann heutigen Tag merken		else			day=0;								// Sonst disablen	if(gCalendarMode)				//  Montag bis Sonntag erwünscht? 	{		if(!(woTag=--datum->dayOfWeek))	// Dann Mac-Format umrechnen 			woTag=7;				// 1=Montag … 7=Sonntag 	}else		woTag=datum->dayOfWeek;		tage=ndays[datum->month-1];		// Tage in diesem Monat 	if((datum->month==2) && !(datum->year % 4))	// Schaltjahr 		tage++;		breite=CharWidth('x')*16;		// Breite eines Tags = 4 Zeichen 	GetFontInfo(&inf);				// Höhe des aktuellen Fonts	zeilenHoehe=inf.ascent+inf.descent+inf.leading;	zeile=TOP_OFFSET+inf.ascent+inf.leading;	// Erste Zeile	xWindow=w->MoreMem;	XWIN->theUnion.schedule.zeilenHoehe=zeilenHoehe;	XWIN->theUnion.schedule.breite=(char)breite;	XWIN->theUnion.schedule.woTag=(char)woTag;	NumToString(datum->month,s);	NumToString(datum->year,s2);	ConcatPString(s,"\p / ");	// Monat und Jahr	ConcatPString(s,s2);	ConcatPString(s,"\p [");				// Wochennummer hintendran	x=datum->dayOfWeek;	CalcDate(datum);	NumToString(datum->week,s2);	datum->dayOfWeek=x;	ConcatPString(s,s2);	s[++s[0]]=']';	i=StringWidth(s);	MoveTo((iRect->right-iRect->left-i)/2,zeilenHoehe);	DrawString(s);		theDay=XWIN->theUnion.schedule.day;	for( i=0 ; i<7 ; i++,theDay++ )	{		MoveTo(iRect->left,(i+1)*zeilenHoehe+zeile);	// Erstmal Tag ausgeben		if(theDay>tage)		{			theDay-=tage;			if((++datum->month)>12)						// Wird für Terminvergleiche gebraucht			{				datum->month=1;				datum->year++;			}			x=datum->day;			datum->day=1;			CalcDate(datum);			datum->day=x;			if(marks)				DisposHandle((Handle)marks);			marks=CalcMarks(datum->year,datum->month,datum->dayOfWeek);	// Termine für diesen Monat raussuchen			if((shortDateTime.year==datum->year) &&				(shortDateTime.month==datum->month))	// Liegt heute im angezeigten Monat?					day=shortDateTime.day;				// Dann heutigen Tag merken				else					day=0;								// Sonst disablen		}		if(marks)								// Markierungen zu vermelden?			todaysMark=(*marks)[theDay-1];		else			todaysMark=0;		sprintf((STR)s,"%2d",theDay);			// Tag 2-stellig 		CtoPstr((STR)s);		style=0;		if(day==theDay)			style=bold;							// Heute in Fettschrift		if(todaysMark & (WITH_ANN1+WITH_ANN2+TODO))			style|=italic;		if(todaysMark & (PERIOD_START+PERIOD_END+PERIOD_MIDDLE))			style|=underline;		TextFace(style);		DrawString(s);		oldGMacWind=gMacWind;				// Ist für NextListH nötig		gMacWind=w;					maxAnz=(iRect->right-iRect->left)/CharWidth('i')/WEEK_LENGTH;	// Max. Anzahl der Termine pro Tag		anz=0;		if(todaysMark & (PERIOD_START+PERIOD_END+PERIOD_MIDDLE))	// Jahrestag auf dem Datum?		{			dateInMonths=(datum->year*12L+datum->month)*32L+theDay;			lHandle=ORG.period;			TextFace(underline);			if(lHandle && !CheckEntry(lHandle,gMacWind))	// Erster Eintrag nicht sichtbar?				lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen			while(lHandle && (anz<maxAnz) && ((*lHandle)->type==PERIOD))			{				sdate=((*lHandle)->t.psched.syear*12L+(*lHandle)->t.psched.smonth)*32L+(*lHandle)->t.psched.sday;				edate=((*lHandle)->t.psched.eyear*12L+(*lHandle)->t.psched.emonth)*32L+(*lHandle)->t.psched.eday;				if((sdate<=dateInMonths) && (dateInMonths<=edate))				{					if(anz)								// Nicht der erste Termin?						s[0]=':';					else						s[0]=' ';					HLock((Handle)lHandle);					strncpy((char*)s+1,(*lHandle)->d,WEEK_LENGTH);	// Textanfang kopieren 					HUnlock((Handle)lHandle);					s[WEEK_LENGTH]=0;					CtoPstr((STR)s);					MoveTo(iRect->left+CharWidth('0')*5+breite*anz++,(i+1)*zeilenHoehe+zeile);					DrawString(s);				}				lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen			}		}				if(todaysMark & WITH_ANN2)	// Jahrestag auf dem Datum?		{			lHandle=ORG.ann2;			TextFace(italic);			if(lHandle && !CheckEntry(lHandle,gMacWind))	// Erster Eintrag nicht sichtbar?				lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen			while(lHandle && (anz<maxAnz) && ((*lHandle)->type==ANN2))			{				if((*lHandle)->t.ann2.month==datum->month)				{					x=((*lHandle)->t.ann2.week)*7+(*lHandle)->t.ann2.day-woTag+1;					if((*lHandle)->t.ann2.day>=woTag-1)						x-=7;					if(x==theDay)		// Der Jahrestag ist heute?					{						if(anz)								// Nicht der erste Termin?							s[0]=':';						else							s[0]=' ';						HLock((Handle)lHandle);						strncpy((char*)s+1,(*lHandle)->d,WEEK_LENGTH);	// Textanfang kopieren 						HUnlock((Handle)lHandle);						s[WEEK_LENGTH]=0;						CtoPstr((STR)s);						MoveTo(iRect->left+CharWidth('0')*5+breite*anz++,(i+1)*zeilenHoehe+zeile);						DrawString(s);					}				}				lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen			}		}				if(todaysMark & WITH_ANN1)	// Jahrestag auf dem Datum?		{			lHandle=ORG.ann1;			TextFace(italic);			if(lHandle && !CheckEntry(lHandle,gMacWind))	// Erster Eintrag nicht sichtbar?				lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen			while(lHandle && (anz<maxAnz) && ((*lHandle)->type==ANN1))			{				if(((*lHandle)->t.ann1.month==datum->month) && 					((*lHandle)->t.ann1.date==theDay))		// Der Jahrestag ist heute?					{						if(anz)								// Nicht der erste Termin?							s[0]=':';						else							s[0]=' ';						HLock((Handle)lHandle);						strncpy((char*)s+1,(*lHandle)->d,WEEK_LENGTH);	// Textanfang kopieren 						HUnlock((Handle)lHandle);						s[WEEK_LENGTH]=0;						CtoPstr((STR)s);						MoveTo(iRect->left+CharWidth('0')*5+breite*anz++,(i+1)*zeilenHoehe+zeile);						DrawString(s);					}				lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen			}		}		if((todaysMark & (VORMITTAG + NACHMITTAG)) && (anz<maxAnz))	// Termin auf dem Datum?		{			lHandle=ORG.schedule;				// Nun noch evtl. Termine ausgeben			TextFace(0);			if(lHandle && !CheckEntry(lHandle,gMacWind))	// Erster Eintrag nicht sichtbar?				lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen			while(lHandle && (anz<maxAnz) && ((*lHandle)->type==SCHEDULE))			{				if(((*lHandle)->t.schedule.year==datum->year) && 					((*lHandle)->t.schedule.month==datum->month) &&					((*lHandle)->t.schedule.day==theDay))	// Der Termin ist heute?					{						if(anz)								// Nicht der erste Termin?							s[0]=':';						else							s[0]=' ';						HLock((Handle)lHandle);						strncpy((char*)s+1,(*lHandle)->d,WEEK_LENGTH);	// Textanfang kopieren 						HUnlock((Handle)lHandle);						s[WEEK_LENGTH]=0;						CtoPstr((STR)s);						MoveTo(iRect->left+CharWidth('0')*5+breite*anz++,(i+1)*zeilenHoehe+zeile);						DrawString(s);					}				lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen			}		}		if(ORG.todo)				// Wenn es keine einzige Aufgabe gibt, können wir		{							// uns das folgende sparen…			GetTime(&shortDateTime);		// Aktuelles Datum			shortDateTime.hour=shortDateTime.minute=shortDateTime.second=0;			Date2Secs(&shortDateTime,&date);			if((shortDateTime.year==XWIN->theUnion.schedule.year) && 				(shortDateTime.month==XWIN->theUnion.schedule.month) && 				(shortDateTime.day==theDay))		// Wird heute angezeigt?			{				// Erster Schritt: Es werden alle Aufgaben angezeigt, die schon abgelaufen				// sind. Kennung: <!> als Priorität								lHandle=ORG.todo;				if(lHandle && !CheckEntry(lHandle,gMacWind))	// Erster Eintrag nicht sichtbar?					lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen				while(lHandle && (XWIN->theUnion.schedule.arrayCounter<MAX_ITEMS_IN_DAY_LIST))				{					if(((*lHandle)->t.todo.year>0) && (((char)(*lHandle)->t.todo.prio)!=(char)'√'))					{						shortDateTime.year=(*lHandle)->t.todo.year;		// Tag der Aufgabe in Sekunden wandeln						shortDateTime.month=(*lHandle)->t.todo.month;						shortDateTime.day=(*lHandle)->t.todo.day;						Date2Secs(&shortDateTime,&dayInQuestion);						if(date>dayInQuestion)						// Der Termin ist schon verstirchen?						{							if(anz)								// Nicht der erste Termin?								s[0]=':';							else								s[0]=' ';							s[1]=0;							HLock((Handle)lHandle);							s2[0]=0;							s2[++s2[0]]='<';						// Priorität anhängen							s2[++s2[0]]='!';							s2[++s2[0]]='>';							s2[++s2[0]]=' ';							PtoCstr(s2);							// Nach C-String wandeln							strncat((char*)s2,(*lHandle)->d,WEEK_LENGTH);	// Erstes Feld (=Kommentar) anhängen							strncat((char*)s+1,(char*)s2,WEEK_LENGTH);	// Textanfang kopieren 							HUnlock((Handle)lHandle);							s[WEEK_LENGTH]=0;							CtoPstr((STR)s);							MoveTo(iRect->left+CharWidth('0')*5+breite*anz++,(i+1)*zeilenHoehe+zeile);							DrawString(s);						}else							break;									// Sonst kommt keiner mehr, da sortiert					}					lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen				}				// Zweiter Schritt: Jetzt folgen alle Terminlosen Aufgaben					lHandle=ORG.todo;				if(lHandle && !CheckEntry(lHandle,gMacWind))	// Erster Eintrag nicht sichtbar?					lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen				while(lHandle && (XWIN->theUnion.schedule.arrayCounter<MAX_ITEMS_IN_DAY_LIST))				{					if((*lHandle)->t.todo.year<=0)							// Kein Datum?					{						if(anz)								// Nicht der erste Termin?							s[0]=':';						else							s[0]=' ';						s[1]=0;						HLock((Handle)lHandle);						strncat((char*)s+1,(*lHandle)->d,WEEK_LENGTH);	// Textanfang kopieren 						HUnlock((Handle)lHandle);						s[WEEK_LENGTH]=0;						CtoPstr((STR)s);						MoveTo(iRect->left+CharWidth('0')*5+breite*anz++,(i+1)*zeilenHoehe+zeile);						DrawString(s);					}else						break;									// Sonst kommt keiner mehr, da sortiert					lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen				}			}					// Letzter Schritt: Jetzt folgen alle Aufgaben, die an diesem Tag fällig sind.					if(todaysMark & TODO)								// ToDo fällig?			{				lHandle=ORG.todo;				if(lHandle && !CheckEntry(lHandle,gMacWind))	// Erster Eintrag nicht sichtbar?					lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen				while(lHandle && (XWIN->theUnion.schedule.arrayCounter<MAX_ITEMS_IN_DAY_LIST))				{					if(((*lHandle)->t.todo.year==XWIN->theUnion.schedule.year) && 						((*lHandle)->t.todo.month==XWIN->theUnion.schedule.month) && 						((*lHandle)->t.todo.day==XWIN->theUnion.schedule.day))		// Der Termin ist heute?						{							if(anz)								// Nicht der erste Termin?								s[0]=':';							else								s[0]=' ';							s[1]=0;							HLock((Handle)lHandle);								strncat((char*)s+1,(*lHandle)->d,WEEK_LENGTH);	// Textanfang kopieren 							HUnlock((Handle)lHandle);							s[WEEK_LENGTH]=0;							CtoPstr((STR)s);							MoveTo(iRect->left+CharWidth('0')*5+breite*anz++,(i+1)*zeilenHoehe+zeile);							DrawString(s);						}					lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen				}			}		}//#endif		gMacWind=oldGMacWind;	}	TextFace(0);	ShowDayNames(zeile,iRect->left+CharWidth('0')*3,zeilenHoehe,true);	if(XWIN->theUnion.schedule.theSelectedDay && 		(XWIN->theUnion.schedule.theSelectedDay<XWIN->theUnion.schedule.day+7) &&		(XWIN->theUnion.schedule.theSelectedDay>=XWIN->theUnion.schedule.day))			// Ist ein Tag selektiert?	{		GetDItem((DialogPtr)w,schUserItem,&iType,&iHandle,&theRect);	// Rechteck des Useritems		theRect.top+=TOP_OFFSET;		theRect.bottom=theRect.top+8*zeilenHoehe;		oldClip=NewRgn();		if(MemError()!=noErr)			return;		GetClip(oldClip);		ClipRect(&theRect);		theRect.top=(XWIN->theUnion.schedule.theSelectedDay-XWIN->theUnion.schedule.day+1)*zeilenHoehe+TOP_OFFSET;		theRect.bottom=theRect.top+zeilenHoehe;		LMSetHiliteMode(LMGetHiliteMode() & ~(1<<hiliteBit));		InvertRect(&theRect);							// Selektierten Tag invertieren		SetClip(oldClip);		DisposeRgn(oldClip);	}	if(XWIN->theUnion.schedule.theSelectedDay)		DisplayDaysLeft(w,XWIN->theUnion.schedule.theSelectedDay);	if(marks)		DisposeHandle(marks);}////	DrawDay zeichnet einen Kalender für einen Tag im aktuellen//  Fenster. Übergeben wird eine datumRec-Struktur für den aktuellen Tag//	ACHTUNG: die datumRec-Struktur kann dabei verändert werden!//void	DrawDay(WindPtr w,datumRec *datum,Rect *iRect){	short		woTag,tage,theDay,i,x;		// Dies und das 	short		zeile,woche,zeilenHoehe,breite,iType;	char		lengthWithoutWeek;	unsigned long	dateInSecs;	FontInfo	inf;	Str63		s,s2;	unsigned long	date;					// Heutiges Datum (da in fett darzustellen)	DateTimeRec	shortDateTime,theDate;	char		day;	Rect		theRect;					// Für Terminkästchen	Style		style;	Handle		xWindow,iHandle;	ListH		*lHandleArray;	DialogPtr	d=(DialogPtr)w;		if(!w)		return;		GetDateTime(&date);				// heutiges Datum abfragen	Secs2Date(date,&shortDateTime);	// in DateTimeRec wandeln	if((shortDateTime.year==datum->year) &&		(shortDateTime.month==datum->month))	// Liegt heute im angezeigten Monat?			day=shortDateTime.day;				// Dann heutigen Tag merken		else			day=0;								// Sonst disablen	if(gCalendarMode)				//  Montag bis Sonntag erwünscht? 	{		if(!(woTag=--datum->dayOfWeek))	// Dann Mac-Format umrechnen 			woTag=7;				// 1=Montag … 7=Sonntag 	}else		woTag=datum->dayOfWeek;		breite=CharWidth('x')*50;		// Breite eines Tags = 4 Zeichen	GetFontInfo(&inf);				// Höhe des aktuellen Fonts	zeilenHoehe=inf.ascent+inf.descent+inf.leading;	zeile=TOP_OFFSET+inf.ascent+inf.leading;	// Erste Zeile	GetDItem((DialogPtr)w, schUserItem, &iType, &iHandle, &theRect);	theRect.bottom=theRect.top+zeilenHoehe;	EraseRect(&theRect);	xWindow=w->MoreMem;	if(!XWIN->theUnion.schedule.list)			// Keine Liste für uns angemeldet		return;	XWIN->theUnion.schedule.zeilenHoehe=zeilenHoehe;	XWIN->theUnion.schedule.breite=(char)breite;	XWIN->theUnion.schedule.woTag=(char)woTag;	theDay=XWIN->theUnion.schedule.day;	theDate=*((DateTimeRec*)datum);	theDate.day=theDay;	theDate.hour=theDate.minute=0;			// Zeit = 0, da zufällige	theDate.second=0;						// Overflows das Datum weiterschalten	Date2Secs(&theDate,&dateInSecs);		GetDateString(s,dateInSecs,abbrevDate);	// Datum mit Wochentagsangabe	lengthWithoutWeek=s[0];	ConcatPString(s,"\p [");				// Wochennummer hintendran	x=datum->dayOfWeek;	CalcDate(datum);	NumToString(datum->week,s2);	datum->dayOfWeek=x;	ConcatPString(s,s2);	s[++s[0]]=']';			if(day==theDay)							// TextFace VOR StringWidth einstellen!		TextFace(bold);						// Heute in Fettschrift darstellen	else		TextFace(0);	i=StringWidth(s);						// Wie breit wird das ganze?	if(i>iRect->right-iRect->left)			// Breiter als das UserItem?	{		s[0]=lengthWithoutWeek;				// Dann ohne Woche anzeigen…		i=StringWidth(s);		if(i>iRect->right-iRect->left)		{			GetDateString(s,dateInSecs,shortDate);	// Datum so kurz wie möglich			i=StringWidth(s);		}	}	MoveTo((iRect->right-iRect->left-i)/2+iRect->left,zeilenHoehe);	DrawString(s);	TextFace(0);	//	invalid=NewRgn();//	if(MemError()!=noErr)//		return;	//	GetDItem((DialogPtr)w,schSecondUserItem,&iType,&iHandle,&iRect);//	RectRgn(invalid,&iRect);//	PaintRgn(invalid);//	LUpdate(((WindowPeek)w)->updateRgn,XWIN->theUnion.schedule.list);//	GetDItem((DialogPtr)w,schSecondUserItem,&iType,&iHandle,&iRect);//	FrameRect(&iRect);}////  Wochentag, Tag im Jahr und Kalenderwoche aus Datum berechnen//void	CalcDate(datumRec *givenDate){	unsigned long	secsGiven,secsJanuary;	DateTimeRec		temp,rekursiv;	REG int			woTag;		temp=*(DateTimeRec *)givenDate;	temp.hour=0;			// Uhrzeit im DateTimeRec = Mitternacht 	temp.minute=0;	temp.second=0;		Date2Secs(&temp,&secsGiven);		// Wochentag berechnen 	Secs2Date(secsGiven,&temp);	givenDate->dayOfWeek=temp.dayOfWeek;	temp.day=temp.month=1;		// Sekunden für 1. Januar berechnen		Date2Secs(&temp,&secsJanuary);	givenDate->dayInYear=(secsGiven-secsJanuary)/86400+1;			// Sekunden im Jahr berechnen / Sekunden pro Tag 		// Wochennummer berechnen 	Secs2Date(secsJanuary,&temp);	// Wochentag des 1. Januar 	woTag=temp.dayOfWeek==1?6:temp.dayOfWeek-2; // Montag – Sonntag = 0–6 	givenDate->week=(secsGiven-(secsJanuary-woTag*86400))/(86400*7)+1;	if(woTag>3)	{		givenDate->week--;	 	if((8-woTag)>givenDate->dayInYear)		{			// Erster Wochentag im Jahr ist Freitag-Sonntag ->			// Woche = Letzte Woche des Vorjahres. 			rekursiv=temp;		// Rekursiv für Vorjahr durchsuchen 			rekursiv.year--;			rekursiv.month=12;			rekursiv.day=31;			rekursiv.hour=rekursiv.minute=rekursiv.second=0;			CalcDate((datumRec *)&rekursiv);			givenDate->week=((datumRec *)&rekursiv)->week;	// Wochennummer gleich letzte Woche Vorjahr 		}	}		temp.year++;				// Resttage im Jahr berechnen 	Date2Secs(&temp,&secsJanuary);	(*givenDate).daysLeft=(secsJanuary-secsGiven)/86400-1;}////	Druckroutine für einen Kalender//void	PrintCalendar(datumRec *datum, Rect *iRect){	short		woTag,tage,i;		// Dies und das 	short		breite,zeile,zeilenHoehe,woche,fontHoehe;	long		size;	FontInfo	inf;	Str63		s,s2;	Rect		theRect;	Intl1Hndl	intlParam;		if(gCalendarMode)				//  Montag bis Sonntag erwünscht? 	{		if(!(woTag=--datum->dayOfWeek))	// Dann Mac-Format umrechnen 			woTag=7;				// 1=Montag … 7=Sonntag 	}else		woTag=datum->dayOfWeek;		tage=ndays[datum->month-1];		// Tage in diesem Monat 	if((datum->month==2) && !(datum->year % 4))	// Schaltjahr 		tage++;		breite=(iRect->right-iRect->left)/(7+fieldNames);	// Breite eines Tags	zeilenHoehe=(iRect->bottom-iRect->top)/8;	zeile=zeilenHoehe*2;					// Erste Zeile	PenSize(2,2);							// Für die Rahmen etwas dicker	if(gS.language>=LANG_OFFSET)			// Gibt es die aktuelle Sprache		intlParam=(Intl1Hndl)GetResource('itl1',MenuToLanguageCode(gS.language));	// Int1-Resource für eingest. Sprache	else		intlParam=(Intl1Hndl)IUGetIntl(1);				// Int1-Resource für default Sprache	if(intlParam)							// Resource vorhanden?	{		CopyPString(s,(*intlParam)->months[datum->month-1]);	// Dann Monatsnamen holen		s[++s[0]]=' ';						// Space anhängen	}else	{		NumToString(datum->month,s);		// Kein Monatsname lesbar,		ConcatPString(s,"\p / ");			// Dann "Monatsnummer /" als Notlösung nehmen	}	NumToString(datum->year,s2);			// Jahreszahl hintendran	ConcatPString(s,s2);	TextSize(100);							// Faktor Pixelhöhe/Punkthöhe ausrechnen	GetFontInfo(&inf);						// Höhe des aktuellen Fonts 	fontHoehe=inf.ascent+inf.descent+inf.leading;	i=CharWidth('D');	size=(iRect->right-iRect->left)*5/i; 	// Breite von 20 D	TextSize(size);							// Überschrift-Höhe = 3/2 Kästchen	GetFontInfo(&inf);						// Höhe des aktuellen Fonts 	size=inf.ascent+inf.leading;	i=TextWidth(s,0,s[0]);					// Breite in akt. Größe	MoveTo((iRect->right-iRect->left-i)/2,size*2);	// Zentrieren	DrawString(s);							// Monat / Jahr ausgeben		TextSize(zeilenHoehe*35/fontHoehe);		// Sonstige Texthöhe = 1/4 Kästchen	GetFontInfo(&inf);						// Höhe des aktuellen Fonts 	fontHoehe=inf.ascent+inf.leading;	CopyPString(s,"\pMo");	if(fieldNames)		ShowDayNames(zeilenHoehe*2-inf.descent-inf.leading,breite/2-TextWidth(s,0,2)/2,breite,false);	// Tagesnamen in Zeile 10 ausgeben 	else		ShowDayNames(zeilenHoehe*2-inf.descent-inf.leading,-breite/2-TextWidth(s,0,2)/2,breite,false);	// Tagesnamen in Zeile 10 ausgeben 	woche=datum->week;						// Nummer der ersten Woche 	if(fieldNames)	{		MoveTo(iRect->left,zeile+fontHoehe);	// Wochennummer ausgeben 		sprintf((STR)s,"%2d:",woche++);			// Woche 2-stellig		DrawString((StringPtr)CtoPstr((STR)s));	}	for(i=1,s[0]=0 ; i<=tage ; i++)	// Jeden Tag ausgeben	{		sprintf((STR)s,"%2d",i);			// Tag 2-stellig 		MoveTo((woTag-(1-fieldNames))*breite,zeile+fontHoehe);		DrawString((StringPtr)CtoPstr((STR)s));	// Tag für Tag ausgeben 				SetRect(&theRect,(woTag-(1-fieldNames))*breite-2,zeile-2,(woTag-(1-fieldNames)+1)*breite,zeile+zeilenHoehe);		FrameRect(&theRect);		if((++woTag==8) && (i!=tage))	// Eine Woche voll 		{			woTag=1;			zeile+=zeilenHoehe;		// Neue Zeile 			if(woche>1)			// Ab Woche 52 kann das neue Jahr beginnen 			{				datum->day=i+1;		// Daher Woche neu berechnen 				CalcDate(datum);				woche=datum->week;			}			if(fieldNames)			{				MoveTo(iRect->left,zeile+fontHoehe);	// Wochennummer ausgeben 				sprintf((STR)s,"%2d:",woche++);	// Woche 2-stellig 				DrawString((StringPtr)CtoPstr((STR)s));			}		}	}}////	Das gegebene Datum -im Scheduler-Union- wird auf einen Wochenanfang gesetzt//void	AlignWeek(Handle xWindow){	unsigned long	secs;	DateTimeRec		dateTime;	short			maxDays;	if(XWIN->floatVar!=flWeek)			// Wochenalignment ist nur bei Wochenübersicht angesagt		return;		dateTime.year=XWIN->theUnion.schedule.year;	dateTime.month=XWIN->theUnion.schedule.month;	dateTime.day=XWIN->theUnion.schedule.day;	dateTime.hour=0; dateTime.minute=0; dateTime.second=0;	Date2Secs(&dateTime,&secs);			// Wochentag berechnen 	Secs2Date(secs,&dateTime);	if((dateTime.dayOfWeek-=2)<0)		// 0=Montag - 6=Sonntag		dateTime.dayOfWeek=6;	if((XWIN->theUnion.schedule.day-=dateTime.dayOfWeek)<1)		if(XWIN->theUnion.schedule.month>1)		{			XWIN->theUnion.schedule.month--;			maxDays=ndays[XWIN->theUnion.schedule.month-1];			if((XWIN->theUnion.schedule.month==2) && !(XWIN->theUnion.schedule.year % 4))	// Schaltjahr 				maxDays++;			XWIN->theUnion.schedule.day=maxDays+XWIN->theUnion.schedule.day;		}else		if(XWIN->theUnion.schedule.year>MIN_YEAR)		{			XWIN->theUnion.schedule.month=12;			XWIN->theUnion.schedule.year--;			XWIN->theUnion.schedule.day=31+XWIN->theUnion.schedule.day;		// Dezember hat immer 31 Tage		}else			XWIN->theUnion.schedule.day=4;	// 4.1.1904 war ein Montag}////	Legt eine ListHandle für das oberste Kalenderwindow an//void	PrepareDay(WindPtr w){	Handle		xWindow,iHandle;	short		iType;	Rect		iRect;	Str255		s;	GrafPtr		oldPort;	DateTimeRec	date;	unsigned long secs;		if(w)	{		xWindow=w->MoreMem;		if(XWIN->windowType!=ANN1)						// Kein Kalender?			return;										// Dann Fehler		if(XWIN->theUnion.schedule.l)					// Schon angemeldet?			return;										// Dann ignorieren		date.year=XWIN->theUnion.schedule.year;		date.month=XWIN->theUnion.schedule.month;		date.day=XWIN->theUnion.schedule.day;		date.second=date.minute=date.hour=0;		Date2Secs(&date,&secs);		Secs2Date(secs,&date);							// Überläufe in den Tagen umrechnen		XWIN->theUnion.schedule.year=date.year;		XWIN->theUnion.schedule.month=date.month;		XWIN->theUnion.schedule.day=date.day;		if(XWIN->theUnion.schedule.theSelectedDay)			XWIN->theUnion.schedule.theSelectedDay=XWIN->theUnion.schedule.day=date.day;				XWIN->theUnion.schedule.l=(ListH**)NewHandle(MAX_ITEMS_IN_DAY_LIST*4);	// Platz für 500 Termine am Tag		if(MemError()!=noErr)		{			DoDialog(DLOGOutOfMemory,1);			Floatklick(flMonth);				// Wenn's nicht reicht, auf Monatsübersicht schalten			return;		}			XWIN->theUnion.schedule.list=NewList((DialogPtr)w,schSecondUserItem,false,true,0);	// UserItem, HSlider, VSlider		(*(XWIN->theUnion.schedule.list))->selFlags = lOnlyOne;	// Nur eine Zelle kann selektiert werden		GetDItem((DialogPtr)w,schWeek,&iType,&iHandle,&iRect);		GetIndString(s,strFloatTxt,strFlTag);		SetIText(iHandle,s);			GetPort(&oldPort);		SetPort((GrafPtr)w);		GetDItem((DialogPtr)w, schUserItem, &iType, &iHandle, &iRect);		EraseRect(&iRect);		SetPort(oldPort);		UpdateDay(w);	}else		SysBeep(BEEPTIME);}void	DisposeDay(WindPtr w){	Handle		xWindow,iHandle;	short		iType;	Rect		iRect;	Str255		s;		if(w)	{		xWindow=w->MoreMem;		if(XWIN->windowType!=ANN1)						// Kein Kalender?			return;											// Dann Fehler		DisposHandle((Handle)XWIN->theUnion.schedule.l);		DisposeObject((DialogPtr)w,schSecondUserItem);		XWIN->theUnion.schedule.l=nil;		XWIN->theUnion.schedule.list=nil;		GetDItem((DialogPtr)w,schWeek,&iType,&iHandle,&iRect);		GetIndString(s,strFloatTxt,strFlWoche);		SetIText(iHandle,s);		XWIN->theUnion.schedule.theSelectedDay=XWIN->theUnion.schedule.day;	}	else		SysBeep(BEEPTIME);}void	UpdateDay(WindPtr w){	char		**marks,todaysMark;			// Markierungs-Bits für Termine	ListH		lHandle,*lHandleArray;	ListHandle	l;	Handle		xWindow,iHandle;	short		x,iType;	Rect		iRect;	WindPtr		oldGMacWind;	long		dateInMonths,sdate,edate;	// Für periodische	unsigned long	today,dayInQuestion;	// Für ToDo	char		s[255];	datumRec	actDate;	DateTimeRec	theDate;		if(!w || !IsDialogWindow((WindowPeek)w))	{		SysBeep(BEEPTIME);		return;	}		xWindow=w->MoreMem;		if(!XWIN->theUnion.schedule.l || !XWIN->theUnion.schedule.list)		return;	//	if(XWIN->theUnion.schedule.list)//		DisposeList((DialogPtr)w,schSecondUserItem);	l=XWIN->theUnion.schedule.list; //=NewList((DialogPtr)w,schSecondUserItem,false,true,0);	// UserItem, HSlider, VSlider//	(*l)->selFlags = lOnlyOne;	// Nur eine Zelle kann selektiert werden	LDelRow(0,0,l);	LDoDraw(false,l);	XWIN->theUnion.schedule.arrayCounter=0;		HLock((Handle)XWIN->theUnion.schedule.l);	lHandleArray=*XWIN->theUnion.schedule.l;		actDate.year=XWIN->theUnion.schedule.year;	actDate.month=XWIN->theUnion.schedule.month;//	actDate.day=XWIN->theUnion.schedule.day;	actDate.day=1;	CalcDate(&actDate);			// Wochentag vom Monatsersten berechnen		marks=CalcMarks(XWIN->theUnion.schedule.year,XWIN->theUnion.schedule.month,actDate.dayOfWeek);	// Termine für diesen Monat raussuchen	if(gCalendarMode)							//  Montag bis Sonntag erwünscht? 	{		if(!(XWIN->theUnion.schedule.woTag=--actDate.dayOfWeek))	// Dann Mac-Format umrechnen 			XWIN->theUnion.schedule.woTag=7;						// 1=Montag … 7=Sonntag 	}else		XWIN->theUnion.schedule.woTag=actDate.dayOfWeek;		if(marks)								// Markierungen zu vermelden?		todaysMark=(*marks)[XWIN->theUnion.schedule.day-1];	else		todaysMark=0;	oldGMacWind=gMacWind;					// Ist für NextListH nötig	gMacWind=w;			if(todaysMark & (PERIOD_START+PERIOD_END+PERIOD_MIDDLE))	// Jahrestag auf dem Datum?	{		dateInMonths=(XWIN->theUnion.schedule.year*12L+XWIN->theUnion.schedule.month)*32L+XWIN->theUnion.schedule.day;		lHandle=ORG.period;		if(lHandle && !CheckEntry(lHandle,gMacWind))	// Erster Eintrag nicht sichtbar?			lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen		while(lHandle && ((*lHandle)->type==PERIOD) && (XWIN->theUnion.schedule.arrayCounter<MAX_ITEMS_IN_DAY_LIST))		{			sdate=((*lHandle)->t.psched.syear*12L+(*lHandle)->t.psched.smonth)*32L+(*lHandle)->t.psched.sday;			edate=((*lHandle)->t.psched.eyear*12L+(*lHandle)->t.psched.emonth)*32L+(*lHandle)->t.psched.eday;			if((sdate<=dateInMonths) && (dateInMonths<=edate))			{				HLock((Handle)lHandle);				lHandleArray[XWIN->theUnion.schedule.arrayCounter++]=lHandle;				AddListMgr((*lHandle)->d,l);	// an die Liste anhängen				HUnlock((Handle)lHandle);			}			lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen		}	}		if(todaysMark & WITH_ANN2)	// Jahrestag auf dem Datum?	{		lHandle=ORG.ann2;		if(lHandle && !CheckEntry(lHandle,gMacWind))	// Erster Eintrag nicht sichtbar?			lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen		while(lHandle && ((*lHandle)->type==ANN2) && (XWIN->theUnion.schedule.arrayCounter<MAX_ITEMS_IN_DAY_LIST))		{			if((*lHandle)->t.ann2.month==XWIN->theUnion.schedule.month)			{				x=((*lHandle)->t.ann2.week)*7+(*lHandle)->t.ann2.day-XWIN->theUnion.schedule.woTag+1;				if((*lHandle)->t.ann2.day>=XWIN->theUnion.schedule.woTag-1)					x-=7;				if(x==XWIN->theUnion.schedule.day)		// Der Jahrestag ist heute?				{					HLock((Handle)lHandle);					lHandleArray[XWIN->theUnion.schedule.arrayCounter++]=lHandle;					AddListMgr((*lHandle)->d,l);	// an die Liste anhängen					HUnlock((Handle)lHandle);				}			}			lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen		}	}		if(todaysMark & WITH_ANN1)	// Jahrestag auf dem Datum?	{		lHandle=ORG.ann1;		if(lHandle && !CheckEntry(lHandle,gMacWind))	// Erster Eintrag nicht sichtbar?			lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen		while(lHandle && ((*lHandle)->type==ANN1) && (XWIN->theUnion.schedule.arrayCounter<MAX_ITEMS_IN_DAY_LIST))		{			if(((*lHandle)->t.ann1.month==XWIN->theUnion.schedule.month) && 				((*lHandle)->t.ann1.date==XWIN->theUnion.schedule.day))		// Der Jahrestag ist heute?				{					HLock((Handle)lHandle);					lHandleArray[XWIN->theUnion.schedule.arrayCounter++]=lHandle;					AddListMgr((*lHandle)->d,l);	// an die Liste anhängen					HUnlock((Handle)lHandle);				}			lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen		}	}	if((todaysMark & (VORMITTAG + NACHMITTAG)))	// Termin auf dem Datum?	{		lHandle=ORG.schedule;				// Nun noch evtl. Termine ausgeben		if(lHandle && !CheckEntry(lHandle,gMacWind))	// Erster Eintrag nicht sichtbar?			lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen		while(lHandle && ((*lHandle)->type==SCHEDULE) && (XWIN->theUnion.schedule.arrayCounter<MAX_ITEMS_IN_DAY_LIST))		{			if(((*lHandle)->t.schedule.year==XWIN->theUnion.schedule.year) && 				((*lHandle)->t.schedule.month==XWIN->theUnion.schedule.month) &&				((*lHandle)->t.schedule.day==XWIN->theUnion.schedule.day))	// Der Termin ist heute?				{					HLock((Handle)lHandle);					lHandleArray[XWIN->theUnion.schedule.arrayCounter++]=lHandle;					s[0]=0;									// String löschen					if((*lHandle)->t.schedule.shour>=0)		// Gibt es eine Startzeit?					{						theDate.day=theDate.month=theDate.year=0;	// Für AddTimeToList zu löschen, da						theDate.second=0;					// Overflows das Datum weiterschalten						AddTimeToString(s,(*lHandle)->t.schedule.shour,(*lHandle)->t.schedule.sminute,&theDate);												if((*lHandle)->t.schedule.ehour>=0)	// Gibt es eine Endzeit?						{							strcat(s,"-");					// Trenner zur Endzeit							AddTimeToString(s,(*lHandle)->t.schedule.ehour,(*lHandle)->t.schedule.eminute,&theDate);						}							strcat(s," ");					// Als Trenner zum Text					}					strcat(s,(*lHandle)->d);				// Noch den Text anhängen					AddListMgr(s,l);						// an die Liste anhängen					HUnlock((Handle)lHandle);				}			lHandle=NextListH(lHandle,getTheNextOne);		// Dann überspringen		}	}	if(ORG.todo)				// Wenn es keine einzige Aufgabe gibt, können wir	{							// uns das folgende sparen…		GetTime(&theDate);		// Aktuelles Datum		theDate.hour=theDate.minute=theDate.second=0;		Date2Secs(&theDate,&today);		if((theDate.year==XWIN->theUnion.schedule.year) && 			(theDate.month==XWIN->theUnion.schedule.month) && 			(theDate.day==XWIN->theUnion.schedule.day))		// Wird heute angezeigt?		{			// Erster Schritt: Es werden alle Aufgaben angezeigt, die schon abgelaufen			// sind. Kennung: <!> als Priorität						lHandle=ORG.todo;			if(lHandle && !CheckEntry(lHandle,gMacWind))	// Erster Eintrag nicht sichtbar?				lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen			while(lHandle && (XWIN->theUnion.schedule.arrayCounter<MAX_ITEMS_IN_DAY_LIST))			{				if(((*lHandle)->t.todo.year>0) && (((char)(*lHandle)->t.todo.prio)!=(char)'√'))				{					theDate.year=(*lHandle)->t.todo.year;		// Tag der Aufgabe in Sekunden wandeln					theDate.month=(*lHandle)->t.todo.month;					theDate.day=(*lHandle)->t.todo.day;					Date2Secs(&theDate,&dayInQuestion);					if(today>dayInQuestion)						// Der Termin ist schon verstirchen?					{						HLock((Handle)lHandle);						lHandleArray[XWIN->theUnion.schedule.arrayCounter++]=lHandle;						GetIndString((USTR)s,strToDoTxt,strToDoDailyTxt);	// Aufgabe:						s[++s[0]]='<';						// Priorität anhängen						s[++s[0]]='!';						s[++s[0]]='>';						s[++s[0]]=' ';						PtoCstr((USTR)s);							// Nach C-String wandeln						strncat(s,(*lHandle)->d,strchr((*lHandle)->d,RETURN)-(*lHandle)->d);	// Erstes Feld (=Kommentar) anhängen						AddListMgr(s,l);					// an die Liste anhängen						HUnlock((Handle)lHandle);					}else						break;									// Sonst kommt keiner mehr, da sortiert				}				lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen			}			// Zweiter Schritt: Jetzt folgen alle Terminlosen Aufgaben			lHandle=ORG.todo;			if(lHandle && !CheckEntry(lHandle,gMacWind))	// Erster Eintrag nicht sichtbar?				lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen			while(lHandle && (XWIN->theUnion.schedule.arrayCounter<MAX_ITEMS_IN_DAY_LIST))			{				if((*lHandle)->t.todo.year<=0)							// Kein Datum?				{						HLock((Handle)lHandle);						lHandleArray[XWIN->theUnion.schedule.arrayCounter++]=lHandle;						GetIndString((USTR)s,strToDoTxt,strToDoDailyTxt);	// Aufgabe:						s[++s[0]]='(';						// Priorität anhängen						s[++s[0]]=(*lHandle)->t.todo.prio;						s[++s[0]]=')';						s[++s[0]]=' ';						PtoCstr((USTR)s);							// Nach C-String wandeln						strncat(s,(*lHandle)->d,strchr((*lHandle)->d,RETURN)-(*lHandle)->d);	// Erstes Feld (=Kommentar) anhängen						AddListMgr(s,l);					// an die Liste anhängen						HUnlock((Handle)lHandle);				}else					break;									// Sonst kommt keiner mehr, da sortiert				lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen			}		}			// Letzter Schritt: Jetzt folgen alle Aufgaben, die an diesem Tag fällig sind.			if(todaysMark & TODO)								// ToDo fällig?		{			lHandle=ORG.todo;			if(lHandle && !CheckEntry(lHandle,gMacWind))	// Erster Eintrag nicht sichtbar?				lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen			while(lHandle && (XWIN->theUnion.schedule.arrayCounter<MAX_ITEMS_IN_DAY_LIST))			{				if(((*lHandle)->t.todo.year==XWIN->theUnion.schedule.year) && 					((*lHandle)->t.todo.month==XWIN->theUnion.schedule.month) && 					((*lHandle)->t.todo.day==XWIN->theUnion.schedule.day))		// Der Termin ist heute?					{						HLock((Handle)lHandle);						lHandleArray[XWIN->theUnion.schedule.arrayCounter++]=lHandle;						GetIndString((USTR)s,strToDoTxt,strToDoDailyTxt);	// Aufgabe:						s[++s[0]]='[';						// Priorität anhängen						s[++s[0]]=(*lHandle)->t.todo.prio;						s[++s[0]]=']';						s[++s[0]]=' ';						PtoCstr((USTR)s);							// Nach C-String wandeln						strncat(s,(*lHandle)->d,strchr((*lHandle)->d,RETURN)-(*lHandle)->d);	// Erstes Feld (=Kommentar) anhängen						AddListMgr(s,l);					// an die Liste anhängen						HUnlock((Handle)lHandle);					}				lHandle=NextListH(lHandle,getTheNextOne);	// Dann überspringen			}		}	}	gMacWind=oldGMacWind;	HUnlock((Handle)XWIN->theUnion.schedule.l);	if(marks)		DisposeHandle(marks);	LDoDraw(true,l);	GetDItem((DialogPtr)w,schSecondUserItem,&iType,&iHandle,&iRect);//	InsetRect(&iRect,-1,-1);	iRect.right-=SBarWidth;	InvalRect(&iRect);}