/*** *	Standard List Definition Procedure for simple text * *  Ernie Beernink  March 1985 * *	This is the standard List defProc.  Its primary task is to draw *	the contents of a list manager cell, either selected or deselected. *	It is passed a pointer to the cell's data, the length of the cell's *	data, and a rectangle in which to draw the cell.  When it is called, *	the clip region is set to that rect.  The cell data does NOT include a *	length byte. ***/#include <Script.h>#include <GestaltEqu.h>#define LineOffset		16/*** *	GetGestaltResult() ermittelt den RŸckgabewert der Gestalt Funktion. Falls ein *	Fehler auftritt, so wird 0 zurŸckgegeben. Somit ist diese Funktion nur dann *	brauchbar, wenn kein Fehler auftreten kann (Gegenbeispiel: AUX-Version erfragen) ***/long	GetGestaltResult(OSType gestaltSelector){long	gestaltResult;		if (Gestalt(gestaltSelector,&gestaltResult) == noErr)		return(gestaltResult);	else		return(0);}pascal void		main(short LMessage,Boolean LSelect,Rect *LRect,Cell LCell,short LDataOffset,						 short LDataLen,ListHandle LHandle){ListPtr		p = *LHandle;char		c,kategorie[31],summe[11];short		i,j;	switch(LMessage) {	case lInitMsg:	{ FontInfo	f;					GetFontInfo(&f);					p->indent.v = f.ascent;					p->indent.h = 4;					}					break;	case lDrawMsg:	{ Point	pnt = topLeft(*LRect);					AddPt(p->indent,&pnt);					MoveTo(pnt.h,pnt.v);	// Pen auf die Indent-Position setzen					PenNormal();			// und den Stift zurŸcksetzen					c = HGetState(p->cells);					HLock(p->cells);					EraseRect(LRect);		// Rechteck lšschen					if (LDataLen > 0) {		// Daten Ÿberhaupt vorhanden?						short	len		= LDataLen;						short	width	= LRect->right - LRect->left - p->indent.h - 1											- LineOffset-TextWidth("9999999.99",0,10);						for( i=0 ; (*p->cells)[i+LDataOffset]!='\t' ; i++)							kategorie[i]=(*p->cells)[i+LDataOffset];												for( j=0 ; i+j<len ; j++)							summe[j]=(*p->cells)[i+j+LDataOffset];						if (TextWidth(kategorie,0,i) <= width) {							DrawText(kategorie,0,i);						} else {							short	face = p->port->txFace;							Str255	s;							Boolean	trunc = false;							TextFace(face | condense);							if (i & 1) i++;	// LŠnge sollte gerade sein							BlockMove(kategorie,s,i);							if (GetGestaltResult(gestaltSystemVersion) >= 0x0700) {								TruncText(width,(char*)s,&len,smTruncEnd);							} else {								while((TextWidth(s,0,i) > width)&&(len > 0)) {									if (!trunc) {										width -= CharWidth('É');										trunc = true;									}									len--;								}							}							if (i) {								DrawText(s,0,i);								if (trunc)									DrawChar('É');							}							TextFace(face);						}						width=TextWidth(summe,0,j);						MoveTo(LRect->right-width,pnt.v);	// Pen auf die Indent-Position setzen						DrawText(summe,0,j);					}					HSetState(p->cells,c);					}	case lHiliteMsg:	break;	case lCloseMsg:		break;	}}