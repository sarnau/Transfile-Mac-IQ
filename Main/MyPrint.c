////	MyPrint - Ausdruckroutinen//#include "GlobalDefines.h"#include "xRsrcDefines.h"#include "GlobalStruct.h"#include "Geos.h"#include "Memo.h"#include "List.h"#include "Float.h"#include "String.h"#include "Utilities.h"#include "DialogLib.h"#include "AktDocStruct.h"#include "Print.h"#include "MyPrint.h"#include "Install.h"#include "Scheduler.h"					// Da ist ne Datumswandelroutine drin#include "Calendar.h"					// Da ist die Kalenderdruckroutine drinListH		**listStarts;				// Datensatzanfänge je Seiteshort		columnWidth;				// Wird am Anfang aus columnsPerPage berechnetshort		columnsPerPage=2;			// Zahl der SpaltenBoolean		fieldNames=true;			// true: Feldnamen werden mitgedrucktBoolean		printHeader=true;			// true: Seitenheader wird gedruckt#define		YELLOW	0					// Keine Buttons (Testversion für Yellow)/*** *	Erweiterung der Drucken-Dialoge ***/void		PrintDialog(short type,register DialogPtr d,register short item){		Handle	xWindow;			// Um den Windowtyp zu bestimmen		Str255	s;					// Temporärer String für "Wochennummern drucken"static	short	first;	switch(type) {	case JobInit:	first = item;					fieldNames = ADOC.fieldNames;					printHeader = ADOC.printHeader;					columnsPerPage = ADOC.columnsPerPage;					if((columnsPerPage<=0) || (columnsPerPage>MAX_COLUMNS_PER_PAGE))						columnsPerPage=1;					SetButton(d,item,fieldNames);					SetButton(d,item+1,printHeader);					SetInteger(d,item+2,columnsPerPage);					xWindow=gTopWindow->MoreMem;					if(!xWindow)						// Beim Drucken einer Datei vom Desktop						return;					if(XWIN->windowType==ANN1)		// Calendar drucken?					{						GetIndString(s,strPrintText,3);	// Dann "Wochennummern" einsetzen						SetCTitle(GetCH(d,item),s);//						HiliteControl(GetCH(d,item+2),255);	// Und Spalten disabeln					}					break;	case JobAktion:	switch(item - first) {					case 0:	fieldNames = !fieldNames;							SetButton(d,item,fieldNames);							break;					case 1:	printHeader = !printHeader;							SetButton(d,item,printHeader);							break;					case 2:	columnsPerPage = GetInteger(d,first+2);							break;					}					break;	case JobExit:	columnsPerPage = GetInteger(d,first+2);					if ((columnsPerPage != ADOC.columnsPerPage)||						(printHeader != ADOC.printHeader)||						(fieldNames != ADOC.fieldNames)) {						ADOC.columnsPerPage = columnsPerPage;						ADOC.printHeader = printHeader;						ADOC.fieldNames = fieldNames;						AppDocumentDirty(gDoc,true);	// Document ist jetzt dirty					}					if((fieldNames!=gS.fieldNames) ||						(printHeader!=gS.printHeader) ||						(columnsPerPage!=gS.columnsPerPage))						{							gSaveSettings = true;			// Einstellungen dirty							gS.fieldNames=fieldNames;		// Defaults zurückschreiben							gS.printHeader=printHeader;							gS.columnsPerPage=columnsPerPage;						}					break;	}}////	Eigentliches Ausdrucken//void	DoPrint(TPPrPort p, THPrint print){	Str255			s,s2;	static unsigned long	dateTime;	// Wird über jede Seite gesetzt	Handle			xWindow;			// Hierher kommt der akt. IQFileType	FontInfo		inf;				// Info des aktuellen Fonts	static short	pages;				// Gesamtzahl der Seiten	short			y,zeilenHoehe,font,columnCount,columnNo,temp;	ListH			handle;				// akt. Datensatz	datasetH		actset;				// Feldnamen und akt. Satztext	Rect			clRect;				// Clipping-Rectangle für Mehrspaltendruck	IQFileType		theWindowType;	short			debugCount=0;		if((columnsPerPage<=0) || (columnsPerPage>MAX_COLUMNS_PER_PAGE))		columnsPerPage=1;		GetFNum(ADOC.font,&font);			// Fontname aus AktDocStruct	TextFont(font);						// Font setzen	TextSize(ADOC.fontSize);			// Größe setzen	GetFontInfo(&inf);					// Höhe des aktuellen Fonts	zeilenHoehe=inf.ascent+inf.descent+inf.leading;		// ermitteln, ob Datensätze auf dieser Seite sind	xWindow=gTopWindow->MoreMem;	if(xWindow)		theWindowType=XWIN->windowType;	else		theWindowType=ANN1;				// Kein Fenster? Dann immer Kalender drucken	if((gPrintPage==-1) && (theWindowType==ANN1))	// Prä-erste Seite	{		GetDateTime(&dateTime);			// aktuelle Uhrzeit		return;				// Kalender braucht sie nicht	}	if(gPrintPage==-1)		// Prä-erste Seite	{		listStarts=(ListH**)NewHandle(MAX_PAGES*sizeof(ListH));		if(MemError()!=noErr)		{			SysBeep(BEEPTIME);			DoDialog(DLOGOutOfMemory,1);			gPrintPage=0;			return;		}		pages=PutDataOnPages(p,XWIN->windowType,print);	// Dann Anfangs-Array berechnen		GetDateTime(&dateTime);			// aktuelle Uhrzeit		return;	}	columnNo=(gPrintPage-1)*columnsPerPage+1;	// # der ersten Spalte dieser Seite	actset=(dataset**)NewHandle(sizeof(dataset));		if(((XWIN->windowType==ANN1) && (gPrintPage>12)) ||	// Kalender max 12 Seiten		((XWIN->windowType!=ANN1) && ((columnNo>pages) || 		(MemError()!=noErr) || (columnNo>=MAX_PAGES))))		// gewünschte Seite liegt hinter der letzten?	{		gPrintPage=0;					// Dann sind wir fertig		if(actset)			DisposHandle((Handle)actset);		DisposHandle((Handle)listStarts);		return;	}	clRect=(*print)->prInfo.rPage;		// Clip-Rect = ganze Seite	ClipRect(&clRect);	// Header ausgeben	if(printHeader)	{		GetIndString(s,strPrintText,strPage);// Seitennummer kommt nach rechts		NumToString((long)gPrintPage,s2);		ConcatPString(s,s2);				// Seitennummer dazu		y=StringWidth(s);		y=(*print)->prInfo.rPage.right-y-CharWidth('—');		MoveTo(y,inf.ascent);				// Ganz nach rechts - Textbreite		DrawString(s);			MoveTo(0,inf.ascent);		PrintHeader(dateTime,longDate,s);	// Erstmal sehen, ob's im Langformat paßt		if(StringWidth(s)>y)				// Sonst Datum im Kurzformat			PrintHeader(dateTime,shortDate,s);		DrawString(s);	}	// Footer ausgeben	#if YELLOW		CopyPString(s,"\pTestversion mit 2 Spalten, Header und Feldnamen. In der Endversion schalbar!");		MoveTo(0,(*print)->prInfo.rPage.bottom-inf.descent);		DrawString(s);	#endif		if(theWindowType==ANN1)		// Kalender drucken?	{Handle xWindow; datumRec actDate;			if(!gTopWindow)	return;		xWindow=gTopWindow->MoreMem;		actDate.year=XWIN->theUnion.schedule.year+(XWIN->theUnion.schedule.month-2+gPrintPage)/12;		actDate.month=((XWIN->theUnion.schedule.month-2+gPrintPage)%12)+1;		// -2: 1 für Modulo (Monate 0-11), 1 für gPrintPage (Seite 1 = Monat +0)		actDate.day=1;		CalcDate(&actDate);		PrintCalendar(&actDate,&clRect);		if(gPrintPage==12)		{			gPrintPage=0;			DisposHandle((Handle)listStarts);		}					return;	}		// Daten für diese Seite rausschmeißen	handle=(*listStarts)[columnNo-1];	HLock((Handle)actset);	FillOut(XWIN->windowType,actset);	clRect=(*print)->prInfo.rPage;	for( columnCount=0 ; (columnCount<columnsPerPage) && (columnNo<=pages) ; columnCount++,columnNo++ )	{		if(printHeader)			y=2;							// Titelzeile und Leerzeile freilassen		else			y=0;		clRect.left=columnCount*columnWidth;		clRect.right=(columnCount+1)*columnWidth-CharWidth('—');		ClipRect(&clRect);		while(handle && handle!=(*listStarts)[columnNo])	// Bis zum ersten Datensatz der nächsten Seite		{			HLock((Handle)handle);			CopyListToDataset(actset,handle);			temp=columnCount*columnWidth;			if(!fieldNames)				temp-=ADOC.columnOffset;			DisplayEntry(temp,y*zeilenHoehe,actset,zeilenHoehe,handle,displayPrint);			temp=EntryLength(handle,(*handle)->type)+1;	// Eintragslänge			HUnlock((Handle)handle);			y+=temp;			if(!gMacWind)					// gMacWind nicht gesetzt?			{				gMacWind=gTopWindow;		// Dann temporär auf gTopWindow				handle=NextListH(handle,getTheNextOne);		// Wird nämlich für CheckEntry benötigt				gMacWind=nil;			}else				handle=NextListH(handle,getTheNextOne);		// Nächsten Listeneintrag holen		}	}	if((columnNo>pages) || (columnNo>=MAX_PAGES))	// War das die letzte Seite?	{		gPrintPage=0;		DisposHandle((Handle)listStarts);	}	HUnlock((Handle)actset);	DisposHandle((Handle)actset);	if((columnNo>pages) || (MemError()!=noErr) || (columnNo>=MAX_PAGES))  // gewünschte Seite liegt hinter der letzten?	{		gPrintPage=0;					// Dann sind wir fertig		DisposHandle((Handle)listStarts);	}}void	PrintHeader(unsigned long dateTime, DateForm temp, Str255 s){	Str255		s2,s3;		GetWTitle((WindowPtr)gTopWindow,s);	// Windowtitel	GetIndString(s3,strPrintText,strSpace);	ConcatPString(s,s3);				// Spaces anhängen	GetDateString(s2,dateTime,temp);	// Datum in String wandeln	ConcatPString(s,s2);				// und anhängen	s[++s[0]]=' ';						// Space dazwischen	GetTimeString(s2,dateTime);			// Zeit ohne Sekunden	ConcatPString(s,s2);				// und anhängen}////	Datensätze auf Seiten verteilen -vor dem Drucken einmal-//short	PutDataOnPages(TPPrPort p,IQFileType type, THPrint print){	short			zeilenHoehe,zeilenZahl,merkZeilenZahl,column;	short			fieldWidth,i,columnCount;	FontInfo		inf;	ListH			handle;		GetFontInfo(&inf);					// Höhe des aktuellen Fonts	zeilenHoehe=inf.ascent+inf.descent+inf.leading;	zeilenZahl=((*print)->prInfo.rPage.bottom-(*print)->prInfo.rPage.top)/zeilenHoehe;	if(printHeader)		zeilenZahl-=2;					// Für den Header gehen 2 Zeilen ab	#if YELLOW		zeilenZahl-=2;					// 2 Zeilen für Footer	#endif	merkZeilenZahl=zeilenZahl;	columnWidth=((*print)->prInfo.rPage.right-(*print)->prInfo.rPage.left)/columnsPerPage;	column=0;							// Ab erster Seite geht's los	(*listStarts)[0]=0;					// Default: Alle Seiten leer	handle=GetListH(GetOrgH(gDoc),type);// erste Listhandle des fraglichen Typs	if(!handle) return(0);				// 0 Seiten	if(!CheckEntry(handle,gTopWindow))	// Erster Eintrag ausgeblendet?	{									// Dann nächsten holen		if(!gMacWind)					// gMacWind nicht gesetzt?		{			gMacWind=gTopWindow;		// Dann temporär auf gTopWindow			handle=NextListH(handle,getTheNextOne);		// Wird nämlich für CheckEntry benötigt			gMacWind=nil;		}else			handle=NextListH(handle,getTheNextOne);		// Nächsten Listeneintrag holen	}	if(!handle) return(0);				// 0 Seiten	do{									// Alle Seiten durchforsten		for( columnCount=1 ; (columnCount<=columnsPerPage) && handle ; columnCount++)		{			(*listStarts)[column++]=handle;	// Handle des ersten Datensatzes merken			{				do{								// Sätze probieren, bis Seite voll					i=EntryLength(handle,type)+1;					if(zeilenZahl>i || (i>=merkZeilenZahl) && (zeilenZahl==merkZeilenZahl))	// aktueller Datensatz paßt noch drauf					{							// oder sowieso nicht auf eine Seite, dann auf leere Seite setzen						zeilenZahl-=i;						if(!gMacWind)		// gMacWind nicht gesetzt?						{							gMacWind=gTopWindow;	// Dann temporär auf gTopWindow							handle=NextListH(handle,getTheNextOne);		// Wird nämlich für CheckEntry benötigt							gMacWind=nil;						}else							handle=NextListH(handle,getTheNextOne);		// Nächsten Listeneintrag holen					}				}while((zeilenZahl>i) && handle);				zeilenZahl=merkZeilenZahl;			}		}	}while(handle && (column<MAX_PAGES));	if(column==MAX_PAGES)		DoDialog(DLOGPrintError,1);	return(column);						// Gesamtseitenzahl zurückgeben}