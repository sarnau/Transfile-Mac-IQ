//// Editor.c//#include "Editor.h"#include "GlobalDefines.h"#include "DialogLib.h"#include "Document.h"#include "Memo.h"#include "Geos.h"#include "GlobalLib.h"#include "String.h"#include "AktDocStruct.h"#include "Options.h"#include "List.h"#include "DoEvent.h"				// Nur für gTheEvent (Debugging only)#include <TextEdit.h>#include <Packages.h>#include <Gestalt.h>#include "Calendar.h"				// für MIN- und MAX_YEAR#include "STDio.h"#include "Scheduler.h"#include "MySound.h"#include "IQComm.h"#include "CheckList.h"#include "GeosMore.h"char ndays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };// Prototypenpascal Boolean MyWordBreaker(char *textPtr, short offset);pascal void MyScrollProc(ControlHandle c,short thePart);// Konstanten#define	Home		200				// Für DoScrollBar (entspr. Tasten)#define End			201datasetH			gActset;ListH				workHandle;			// Handle auf momentanen Datensatz (Kopie)Rect				dialogDest,userRect,dialogView;TEHandle			teHandle;			// Globale TextEdit-Handleshort				fieldLength[MAX_NAMES],zeilenHoehe,userItemZeilen,Slider;short				editEntry,maxEditEntry,editOffset;	// Nummer des momentan editierten Feldes			short				totalLength;		// Gesamtlänge-aktuellem FeldFontInfo			inf;				// Für Zeilenhöhenberechnung; Info Editor-Fontschar				*editT;				// Gerade editierter TextBoolean				changeEntry,shift;	// Das TE-Feld muß neu gesetzt werden: editEntry geändertBoolean				tabHasBeenPressed=false; // Nach Tab wird der Cursor ans Feldende gesetztBoolean				DontRedraw=false;	// Debug onlyBoolean				itsDirty;			// Dirty-Flag für aktuellen DatensatzPoint				thePoint;			// Letzter MausklickDialogPtr			d;RgnHandle			myUpdateRgn;		// Beim Scrollen benötigtEditRetType	Editor(ListH handle, IQFileType dataType, DateTimeRec *defaultDate){	GrafPtr			oldPort;	short			iType,item,oldSize,oldOffset,fieldWidth,i,dummy;	short			nLines,nLines2,oldEditEntry,saveSize,saveFont;	short			oldEditField;	Rect			iRect;	Handle			iHandle;	ListH			tempHandle,succHandle,prevHandle;	EditRetType		result={0,0,0,0};	TEHandle		oldHandle;	CharsHandle		teText;	CheckErrorCode	notValid;		// Eintrag nach OK nicht gültig	Str255			s;	DialogPtr		invalDialog;	Boolean			setCaret=true;	// Nach changeEntry noch den Caret neu setzen		result.recalcNecessary=false;	// Keine Sliderberechnung	result.redrawNecessary=false;	if(FreeMem()<MIN_EDITOR_MEM)	{		DoDialog(DLOGOutOfMemory,1);		return(result);	}	// Shift produziert die Terminart-Auswahl{KeyMap		theKeys;					// 8 Byte Tastaturmatrix	GetKeys(theKeys);					// aktuelle Tastaturmatrik holen	if((dataType==SCHEDULE) && (CheckKey(0x38)) && (!handle))	// Shift gedrückt und keine alten Daten übergeben?		dataType=ChooseSchedulerType();	// Dann besondere Termintypen abfragen	else		if(handle)			dataType=(*handle)->type;	// Sonst übergebenen Typ nutzen}	if(dataType==UNKNOWNFILE)			// Cancel oder Fehler bei ChooseSchedulerType		return(result);	editT=NewPtr(TE_LENGTH);			// Buffer für TextEdit organisieren	if(MemError()!=noErr)		return(result);	gActset=(dataset**)NewHandle(sizeof(dataset));	if(!gActset)	{		DisposePtr(editT);		return(result);	}	myUpdateRgn=NewRgn();	if(MemError()!=noErr)	{		DisposePtr(editT);		DisposHandle((Handle)gActset);		return(result);	}		d = GetCenteredDialog(DLOGEditor,nil);	if (d) {								// Dialog vorhanden?	//		MenuHandle	mh = GetMHandle(mBearbeiten);	//		EnableItem(mh,0);				// Edit-Menu enabeln	//		EnableItem(mh,4);				// Edit-Menu enabeln						GetPort(&oldPort);			SetPort((GrafPtr)d);			// GrafPort auf Dialogbox			saveSize=((GrafPtr)d)->txSize;			saveFont=((GrafPtr)d)->txFont;			oldSize=ADOC.fontSize;			ADOC.fontSize=ADOC.fontSize>MAX_EDITOR_FONT_SIZE?MAX_EDITOR_FONT_SIZE:ADOC.fontSize;			oldOffset=ADOC.columnOffset;						TextFont(EDITOR_FONT);			TextSize(MAX_EDITOR_FONT_SIZE); // TextSize(ADOC.fontSize);			CalcSecondColumn(oldPort);			editOffset=ADOC.columnOffset;			ADOC.columnOffset=oldOffset;						GetFontInfo(&inf);					// Höhe des aktuellen Fonts			zeilenHoehe=inf.ascent+inf.descent+inf.leading; // ist global						ADOC.fontSize=oldSize;			TextSize(saveSize);			TextFont(saveFont);			// Entsprechendes fürs Telefon-Popup-Menü			GetDItem(d,editPopup,&iType,&iHandle,&iRect);			if(((dataType<TEL1DATA) || (dataType>TEL3DATA)) &&				((dataType<USERFILE1) || (dataType>USERFILE3)))				HideDItem(d,editPopupTxt);			else			// Wenn es das Teil gibt, müssen die Listennamen eingetragen werden			{	Str255		s;				ListH		telListHandle;				MenuHandle	mh = GetMenu(mTelefonart);				IQFileType	firstOfThree;	// Werden Userfiles oder Telefondaten bearbeitet?								if(mh==nil)					// Menü konnte nicht gelesen werden				{					for(i=1 ; i<3 ; i++)						SysBeep(20);				}else				{					for( i=1 ; i<=3 ; i++)	// Drei Dateien gibt es jeweils					{						if(dataType>=USERFILE1)						{							firstOfThree=USER1FREE;							telListHandle=ORG.userfree;		// Dateinamen für User-Files						}else								// stehen am Anfang der Freifelder						{							firstOfThree=TEL1FILE;							telListHandle=ORG.telfile;						}														while(telListHandle && (*telListHandle)->type!=firstOfThree-1+i)							telListHandle=(*telListHandle)->next;						if(telListHandle)						{							HLock((Handle)telListHandle);			// Dateinamen holen…							strncpy((char*)s,(*telListHandle)->d,10);	// Max. 10 Zeichen lang							s[10]=0;						// Userfiles hat nämlich die Freifelder dahinter							HUnlock((Handle)telListHandle);							CtoPstr((STR)s);							SetItem(mh,i,s);				// Und ins Popup-Menü schreiben						}					}					ShowDItem(d,editPopupTxt);					NewPopup(d,editPopup,mTelefonart,editPopupTxt,1);				}			}					do{			// äußere Schleife: Einen kompl. Datensatz editieren			result.leftArrow=result.rightArrow=0;	// Schleifenendebedingung			notValid=CHKNoErr;			itsDirty=false;			FillOut(dataType,gActset);			if((dataType>=TEL1DATA) && (dataType<=TEL3DATA))	// Bei Telefon gibt's Freifelder				GetFreeFields(gActset,ORG.telfree,dataType,TEL1FREE,TEL1DATA,3);			if((dataType>=USERFILE1) && (dataType<=USERFILE3))	// Bei Userfiles auch				GetFreeFields(gActset,ORG.userfree,dataType,USER1FREE,USERFILE1,0); // Ab Feld 0, nicht 3					(*gActset)->visible=-1;				// Keine Felder ausgeblendet			for( maxEditEntry=0 ; (maxEditEntry<MAX_NAMES) && 				((*gActset)->text[maxEditEntry][0]!=END_OF_LIST) ; maxEditEntry++ ) ;			maxEditEntry--;			// Letzter Eintrag gildet nich!			// Alarm bei Bedarf disabeln (nur beim Scheduler und Daily Alarm möglich)			GetDItem(d,editAlarmOn,&iType,&iHandle,&iRect);			if((dataType!=SCHEDULE) && (dataType!=DALARM))				HiliteControl((ControlHandle)iHandle,255);			else				HiliteControl((ControlHandle)iHandle,0);			if(dataType==EXPENSE)				// Alarm in "Beleg" ändern			{				ShowDItem(d,editBeleg);				HideDItem(d,editAlarmOn);			}			// Dasselbe für Mark*ieren			GetDItem(d,editMarked,&iType,&iHandle,&iRect);			if((dataType>=ANN1) && (dataType<=DALARM))				HiliteControl((ControlHandle)iHandle,255);			else				HiliteControl((ControlHandle)iHandle,0);			// Last not least 4/8-zeilig			GetDItem(d,editFour,&iType,&iHandle,&iRect);			if((dataType==DALARM) || (dataType==BUSINESS) || (dataType==USERFILE1)				|| (dataType==EXPENSE) || (dataType==DOLIST))				HiliteControl((ControlHandle)iHandle,255);			else				HiliteControl((ControlHandle)iHandle,0);						if(!handle)						// Keine Handle = Neuer Datensatz			{				GetDItem(d,editLeft,&iType,&iHandle,&iRect);	// Nächster und voriger				HiliteControl((ControlHandle)iHandle,255);						// disabeln				GetDItem(d,editRight,&iType,&iHandle,&iRect);				HiliteControl((ControlHandle)iHandle,255);				workHandle=(ListH)NewHandle(sizeof(List));	// Neuen Datensatz anlegen				if(MemError()!=noErr)				{					DoDialog(DLOGOutOfMemory,1);					DisposHandle((Handle)gActset);					DisposeRgn(myUpdateRgn);					DisposePtr(editT);					DisposeObjects(d);					DisposDialog(d);					return(result);				}				for( i=0 ; i<sizeof(List) ; (*(Handle)workHandle)[i++]=0) ;				(*workHandle)->type=dataType;		// Art des Datensatzes				if((dataType<=DALARM) || (dataType==EXPENSE) ||				(dataType==DOLIST) || (dataType==TODO))	// Termin irgendeiner Art?				{					memset(&((*workHandle)->t),-1,sizeof(IQTime));	// Datum erstmal ungültig					if(defaultDate)					// Gibt es ein default-Datum?					{						if(defaultDate->year>0)		// Default Tag						{							switch(dataType)							{							case SCHEDULE:								(*workHandle)->t.schedule.year=defaultDate->year;								(*workHandle)->t.schedule.month=defaultDate->month;								(*workHandle)->t.schedule.day=defaultDate->day;								break;															case ANN1:								(*workHandle)->t.ann1.month=defaultDate->month;								(*workHandle)->t.ann1.date=defaultDate->day;								break;															case PERIOD:								(*workHandle)->t.psched.syear=defaultDate->year;								(*workHandle)->t.psched.smonth=defaultDate->month;								(*workHandle)->t.psched.sday=defaultDate->day;								break;							case DOLIST: case TODO:								(*workHandle)->t.todo.year=defaultDate->year;								(*workHandle)->t.todo.month=defaultDate->month;								(*workHandle)->t.todo.day=defaultDate->day;								break;							}						}					}				}			}else			{				workHandle=handle;				if(HandToHand((Handle*)&workHandle))				// Sonst alten kopieren					workHandle=nil;						// Bei Fehler = nil					tempHandle=NextListH(handle,getTheNextOne);		// Nächsten Listeneintrag holen				GetDItem(d,editRight,&iType,&iHandle,&iRect);				if(!tempHandle)							// Kein Folgeeintrag?					HiliteControl((ControlHandle)iHandle,255);				else					HiliteControl((ControlHandle)iHandle,0);				tempHandle=NextListH(handle,getThePreviousOne);		// Vorigen Listeneintrag holen				GetDItem(d,editLeft,&iType,&iHandle,&iRect);				if(!tempHandle)					// Kein voriger Eintrag?					HiliteControl((ControlHandle)iHandle,255);				else					HiliteControl((ControlHandle)iHandle,0);			}			GetDItem(d,editScroll,&iType,&iHandle,&iRect);	// Handle auf Scrollbar			SetCtlMin((ControlHandle)iHandle,0);			Slider=0;			if(workHandle)								// Nur wenn genug Ram da ist			{				AddReturnsIfNecessary(workHandle);				HLock((Handle)gActset);				if(dataType==SCHEDULE)					// Bei gesetzter Alarmzeit					if((*workHandle)->t.schedule.ahour>=0)	// Alarm einschalten						(*workHandle)->b.alarm=1;				if((dataType>=TEL1DATA) && (dataType<=TEL3DATA))					SetPopupValue(d,editPopup,dataType-TEL1DATA+1);				else if((dataType>=USERFILE1) && (dataType<=USERFILE3))					SetPopupValue(d,editPopup,dataType-USERFILE1+1);				GetDItem(d,editUser,&iType,&iHandle,&userRect);	// Rechteck des Useritems				InsetRect(&userRect,2,2);				userItemZeilen=(userRect.bottom-userRect.top)/zeilenHoehe; // global					oldEditEntry=editEntry=0;		// Ersten Eintrag editieren				changeEntry=false;				CopyListToDataset(gActset,workHandle);				saveSize=((GrafPtr)d)->txSize;				saveFont=((GrafPtr)d)->txFont;				TextSize(MAX_EDITOR_FONT_SIZE); // TextSize(ADOC.fontSize>MAX_EDITOR_FONT_SIZE?MAX_EDITOR_FONT_SIZE:ADOC.fontSize);				TextFont(EDITOR_FONT);				SetDialogRect(editEntry,editT,d);	// Setzt dialogRect für Eintrag 0				teHandle=TENew(&dialogDest,&dialogView);				(*teHandle)->txFont=EDITOR_FONT;				(*teHandle)->txSize=MAX_EDITOR_FONT_SIZE; //ADOC.fontSize>MAX_EDITOR_FONT_SIZE?MAX_EDITOR_FONT_SIZE:ADOC.fontSize;				TextFont(saveFont);				TextSize(saveSize);				TEActivate(teHandle);				CalcFieldLength((*gActset)->data,FieldWidthCalc(workHandle),d);	// SetCtlMax				SetDialogRect(editEntry,editT,d);	// Wenn das Ding schon zu lang ist,				(*teHandle)->viewRect=dialogView;	// evtl. schon mal nach unten scrollen				(*teHandle)->destRect=dialogDest;//				TESetWordBreak((WordBreakUPP)MyWordBreaker,teHandle);				(*teHandle)->wordBreak = (void*)MyWordBreaker;				TESetText(editT,(long)strlen(editT),teHandle);				TESetSelect(32767,32767,teHandle);				ScrollAfterChangeEntry(d);				nLines2=(*teHandle)->nLines;	// Um Zeilenzahländerungen zu erkennen				if(!nLines2)									// Kein Zeichen?					nLines2=1;									// Trotzdem eine Zeile lang				teText=TEGetText(teHandle);				if((*teText)[(*teHandle)->teLength-1]=='\r')	// Return am Ende?					nLines2++;				// Dann eine Zeile länge								oldHandle=((DialogPeek)d)->textH;				oldEditField=((DialogPeek)d)->editField;				((DialogPeek)d)->textH=teHandle;				((DialogPeek)d)->editField=editUser-1;								{									// Direkt einen Redraw machen					EventRecord		dummyEvent;					short			button;										dummyEvent.message=(long)d;					dummyEvent.what=updateEvt;					EditFilter(d,&dummyEvent,&button);					ValidRect(&userRect);				}				do{					// Check-Boxes richtig setzen					GetDItem(d,editFour,&iType,&iHandle,&iRect);					SetCtlValue((ControlHandle)iHandle,(*workHandle)->b.displaymode);					GetDItem(d,editMarked,&iType,&iHandle,&iRect);					SetCtlValue((ControlHandle)iHandle,(*workHandle)->b.marked);					if(dataType==EXPENSE)						GetDItem(d,editBeleg,&iType,&iHandle,&iRect);					else						GetDItem(d,editAlarmOn,&iType,&iHandle,&iRect);					SetCtlValue((ControlHandle)iHandle,(*workHandle)->b.alarm);					GetDItem(d,editUser,&iType,&iHandle,&iRect);						nLines=nLines2;		// Zeilenzahl des akt. Feldes					saveSize=((GrafPtr)d)->txSize;					saveFont=((GrafPtr)d)->txFont;//					TextSize(MAX_EDITOR_FONT_SIZE); // TextSize(ADOC.fontSize>MAX_EDITOR_FONT_SIZE?MAX_EDITOR_FONT_SIZE:ADOC.fontSize);//					TextFont(EDITOR_FONT);					TextFont(0);					ModalDialog((ModalFilterProcPtr)EditFilter,&item);//					TextFont(saveFont);//					TextSize(saveSize);										// Scrollen, wenn vorher/hinterher mindestens 1 Zeile und Zeilenzhl geändert					nLines2=(*teHandle)->nLines;					// Akt. Zeilenzahl von TE					if(!nLines2)									// Kein Zeichen?						nLines2=1;									// Trotzdem eine Zeile lang					teText=TEGetText(teHandle);					if((*teText)[(*teHandle)->teLength-1]=='\r')	// Return am Ende?						nLines2++;				// Dann eine Zeile länge					if(nLines2!=nLines)				// Zeilenzahl geändert?					{RgnHandle	tempRgn,dialogRgn,oldRgn;							iRect=userRect;						iRect.top=dialogDest.bottom;						if(FreeMem()>200)	// Sollte für die Miniatur-Regions reichen						{							tempRgn=NewRgn();							dialogRgn=NewRgn();							oldRgn=NewRgn();							if(tempRgn && dialogRgn && oldRgn)							{								RectRgn(dialogRgn,&dialogView);		// Dialog-Bereich muß nicht redrawt werden!								RectRgn(oldRgn,&userRect);								DiffRgn(oldRgn,dialogRgn,tempRgn);	// Scrollen nur im UserRect - Dialogbox								GetClip(oldRgn);								SetClip(tempRgn);								ScrollRect(&iRect,0,zeilenHoehe*(nLines2-nLines),tempRgn);								if(DontRedraw)									InvertRgn(tempRgn);								SetClip(oldRgn);								DiffRgn(tempRgn,dialogRgn,tempRgn);	// Dialogbox nicht redrawn								if(DontRedraw)									FrameRgn(tempRgn);								else									InvalRgn(tempRgn);								DisposeRgn(tempRgn);								DisposeRgn(dialogRgn);								DisposeRgn(oldRgn);							}							else								SysBeep(20);						}						else							InvalRect(&userRect);	// Sonst brutal-Redraw							WriteDataToList(oldEditEntry,TEGetText(teHandle));						CopyListToDataset(gActset,workHandle);						if(!((*gActset)->data))		// Schedulereintrag Gülle?							TESetText((*gActset)->data,0,teHandle);	// Dann löschen						CalcFieldLength((*gActset)->data,FieldWidthCalc(workHandle),d);						SetDialogRect(editEntry,editT,d);						(*teHandle)->viewRect=dialogView;						(*teHandle)->destRect=dialogDest;						ScrollAfterChangeEntry(d);					}					switch(item){					case editMarked:						(*workHandle)->b.marked^=1;						InvalRect(&userRect);						itsDirty=true;						break;					case editFour:						(*workHandle)->b.displaymode^=1;						InvalRect(&userRect);						changeEntry=true;				// Alle Zeilenlängen haben sich geändert						setCaret=false;						itsDirty=true;						break;					case editAlarmOn:						(*workHandle)->b.alarm^=1;						// Wenn der Alarm ausgeschaltet wurde, wird die Alarmzeit gelöscht						if(!(*workHandle)->b.alarm)						{							(*workHandle)->t.schedule.ahour=(*workHandle)->t.schedule.aminute=-1;							InvalRect(&userRect);						}						itsDirty=true;						break;					case editBeleg:						(*workHandle)->b.alarm^=1;						itsDirty=true;						break;					case editPopup:						if(dataType<USERFILE1)	// Telefondaten werden bearbeitet						{							dataType=GetPopupValue(d,editPopup)+TEL1DATA-1;							(*workHandle)->type=dataType;							GetFreeFields(gActset,ORG.telfree,dataType,TEL1FREE,TEL1DATA,3);						}else						{							dataType=GetPopupValue(d,editPopup)+USERFILE1-1;							(*workHandle)->type=dataType;							GetFreeFields(gActset,ORG.userfree,dataType,USER1FREE,USERFILE1,0);						}						InvalRect(&userRect);	// Neue Freifelder, daher Redraw forcieren						itsDirty=true;			// Und dirty ist der Datensatz nun sowieso						break;					}					if(changeEntry)				// Edit-Feld wurde gewechselt					{short i;						TEDeactivate(teHandle);	// Cursor/Selection ausblenden												// Aktuellen Text in workHandle eintragen						WriteDataToList(oldEditEntry,TEGetText(teHandle));						i=FieldWidthCalc(workHandle);						CopyListToDataset(gActset,workHandle);												if(oldEditEntry<CountSpecialLines((*workHandle)->type))							InvalRect(&dialogView);												oldEditEntry=editEntry;						CalcFieldLength((*gActset)->data,FieldWidthCalc(workHandle),d);						SetDialogRect(editEntry,editT,d);	// Setzt dialogRect für Eintrag 0						// Wenn das aktuelle Feld nicht sichtbar ist, dann						// mal mit Sliden versuchen…						totalLength=strlen((*workHandle)->d)-strlen(editT);	// Gesamtlänge						TESetText(editT,(long)strlen(editT),teHandle);						(*teHandle)->viewRect=dialogView;						(*teHandle)->destRect=dialogDest;						TECalText(teHandle);						nLines2=(*teHandle)->nLines;	// Sonst würde gescrollt						if(!nLines2)									// Kein Zeichen?							nLines2=1;									// Trotzdem eine Zeile lang						changeEntry=false;						TEActivate(teHandle);						if(setCaret)							if(tabHasBeenPressed)							{								TESetSelect(32767,32767,teHandle);	// Cursor ans Zeilenende								tabHasBeenPressed=false;							}							else								TEClick(thePoint,false,teHandle);						setCaret=true;						ScrollAfterChangeEntry(d);					}				}while((item!=editOK) && (item!=editCancel) &&					(item!=editLeft) && (item!=editRight));					// Aktuellen Text in workHandle eintragen				WriteDataToList(editEntry,TEGetText(teHandle));					((DialogPeek)d)->textH=oldHandle;				((DialogPeek)d)->editField=oldEditField;//				result.redrawNecessary=false;				if(item!=editCancel)	// Cancel bricht ab, OK, < und > übernehmen				{Size size;					HLock((Handle)workHandle);					ShortenEntry((*workHandle)->d);		// Returns am Ende wegcutten					HUnlock((Handle)workHandle);					if((*workHandle)->d[strlen((*workHandle)->d)-1]==RETURN)						(*workHandle)->d[strlen((*workHandle)->d)-1]=0;					i=notValAdapt;					notValid=CheckData(workHandle,ORG.type);	// Fehlt noch was wichtiges?										if(notValid!=CHKNoErr)					{						GetIndString(s,strEditorError,notValid<50?notValid:notValid-50+5);						ParamText(s,nil,nil,nil);						invalDialog = GetCenteredDialog(DLOGnotValid,nil);						if (invalDialog) {					// Dialog vorhanden?							pfeil();							// Abtesten, ob der ungültige Eintrag durch Kürzen gültig wird:							handle=workHandle;							if(HandToHand((Handle*)&handle))			// Kopie anlegen								handle=nil;					// Bei Fehler = nil								HUnlock((Handle)handle);							notValid=CorrectEntry(handle,ORG.type,notValid);	// Korrekturversuch							if((notValid==CHKNil) || (notValid==CHKKill))		// Kein Speicher oder nicht korrigierbar?								HiliteButton(invalDialog,notValAdapt,255);							// handle enthält jetzt den korrigierten Datensatz;							// workHandle den originalen														ModalDialog((ModalFilterProcPtr)OwnDialogFilter,&i);							DisposDialog(invalDialog);														// Auswertung des Buttons							switch(i)							{							case notValErase:				// Änderungen verwerfen								notValid=CHKNoErr;			// Dann = Cancel								DisposHandle((Handle)workHandle);	// Beim Canceln auch freigeben								if(handle)					// Gab es eine Kopie der workHandle?									DisposHandle((Handle)handle);	// Dann wegwerfen.								handle=workHandle=nil;		// Jetzt sind alle ungültig								break;							case notValAdapt:				// Automatisch anpassen								notValid=CHKNoErr;			// Dann = Cancel								DisposHandle((Handle)workHandle);	// workHandle wird durch angepaßte ersetzt								workHandle=handle;								handle=nil;								itsDirty=true;								break;							case notValCorrect:								DisposHandle((Handle)handle);								handle=nil;							}						}					}					if(handle)					{						// Folge-Handles merken —fürs Links- und Rechtsblättern—						succHandle=NextListH(handle,getTheNextOne);						prevHandle=NextListH(handle,getThePreviousOne);					}												if((i==notValAdapt) && itsDirty)	// Anpassen?					{						result.redrawNecessary=true;	// Dann ist immer ein Redraw erforderlich						result.recalcNecessary=true;						if(handle)			// Alter Datensatz wurde editiert						{							// Alten Eintrag aus Liste entfernen							DisposeFromList(GetListHA(GetOrgH(gDoc),(*handle)->type),handle);						}						{IQFileType	theType;							theType=(*workHandle)->type;	// Typ des neuen Datensatztes															if(theType==MEMO)				// Memo wird angehängt,								AppendToList(GetOrgH(gDoc),theType,workHandle);							else							// Alle anderen einsortiert								SortToList(GetOrgH(gDoc),theType,workHandle);							handle=workHandle;				// Für Arrows wichtig						}						AppDocumentDirty(gDoc,true);	// Document ist jetzt dirty					}				}else					DisposHandle((Handle)workHandle);	// Beim Canceln auch freigeben				if(item==editLeft)				// Voriger Datensatz ist fällig				{//					handle=NextListH(handle,getThePreviousOne);		// Vorigen Listeneintrag holen					if(prevHandle)					{						handle=prevHandle;						dataType=(*handle)->type;						result.leftArrow=1;					}else					{						OwnBeep(shit);						result.leftArrow=0;					}				}				if(item==editRight)				// Der nächste bitte…				{//					handle=NextListH(handle,getTheNextOne);		// Nächsten Listeneintrag holen					if(succHandle)					{						handle=succHandle;						dataType=(*handle)->type;						result.rightArrow=1;					}else					{						OwnBeep(shit);						result.rightArrow=0;					}				}				TEDeactivate(teHandle);				TEDispose(teHandle);			}		}while(result.leftArrow || result.rightArrow || notValid);		result.leftArrow=result.rightArrow=0;		SetPort(oldPort);		DisposeObjects(d);		DisposDialog(d);		pfeil();			// War nicht zurückgesetzt, wenn Ende über Tastatur	}	DisposHandle((Handle)gActset);	DisposeRgn(myUpdateRgn);	DisposePtr(editT);	return(result);}////	eigener Dialogfilter//pascal Boolean	EditFilter(DialogPtr d,EventRecord *event, short *item){	TEHandle		t = ((DialogPeek)d)->textH;		// Handle auf aktuelles TextEdit-Feld	short			key,iType,saveFont,saveSize,saveOffset;	Rect			iRect;	Handle			iHandle;	ControlHandle	ctlHandle;	RgnHandle		tempRgn,dialogRgn,oldRgn;	Str255			s;	unsigned long	date;		t=teHandle;		while (0==0) {		TEIdle(teHandle);		if ((event->what == updateEvt) && (d == (DialogPtr)event->message))		{			tempRgn=NewRgn();					// Region für alte Clip-Region			if(tempRgn)			{				dialogRgn=NewRgn();				if(dialogRgn)				{					oldRgn=NewRgn();					if(oldRgn)					{						GetDItem(d,editUser,&iType,&iHandle,&iRect);						ValidRect(&iRect);						FrameRect(&iRect);									EraseRect(&userRect);				// Erstmal löschen						GetClip(oldRgn);						RectRgn(tempRgn,&userRect);			// Clip-Region = UserItem…						RectRgn(dialogRgn,&dialogView);						DiffRgn(tempRgn,dialogRgn,tempRgn);	// … - Dialog-Feld						SetClip(tempRgn);						HLock((Handle)workHandle);						CopyListToDataset(gActset,workHandle);												saveSize=((GrafPtr)d)->txSize;						saveFont=((GrafPtr)d)->txFont;						saveOffset=ADOC.columnOffset;						TextSize(MAX_EDITOR_FONT_SIZE); // TextSize(ADOC.fontSize>MAX_EDITOR_FONT_SIZE?MAX_EDITOR_FONT_SIZE:ADOC.fontSize);						TextFont(EDITOR_FONT);						ADOC.columnOffset=editOffset;						DisplayEntry(userRect.left,userRect.top-Slider,gActset,zeilenHoehe,workHandle,displayEditor);						HUnlock((Handle)workHandle);						SetClip(dialogRgn);						EraseRect(&dialogView);						TEUpdate(&dialogView,teHandle);//						TextFont(saveFont);//						TextSize(saveSize);						TextFont(0); TextSize(12);						ADOC.columnOffset=saveOffset;						SetClip(oldRgn);					// Alte Clip-Region restaurieren						DisposeRgn(oldRgn);					}				DisposeRgn(dialogRgn);				}			DisposeRgn(tempRgn);			}			break;		}		thePoint=event->where;		GlobalToLocal(&thePoint);		shift=(event->modifiers & shiftKey)!=0;				// Klicks ins TextEdit-Window werden weitergereicht:		if ((event->what == mouseDown) && PtInRect(thePoint,&dialogView)			&& (((DialogPeek)d)->editField==editUser-1))		{			TEClick(thePoint,shift,teHandle);			return(true);		}				// Sonstige Klicks ins UserItem ändern das TE-Window:		if((event->what == mouseDown) && PtInRect(thePoint,&userRect))		{short i,j,k;//			((DialogPeek)d)->textH=teHandle;	// Wir sind wieder aktives TextEdit-Feld//			((DialogPeek)d)->editField=editUser-1;			k=thePoint.v-userRect.top;	// y-Koordinate des Klicks			// Umrechnen in Eintragsnummer:			for( editEntry=j=0, i=(k+Slider)/zeilenHoehe ; 				(editEntry<maxEditEntry) && ((j+=fieldLength[editEntry])<=i) ;				 editEntry++ ) ;			changeEntry=true;			return(true);		}		if(event->what == mouseDown)	// Klick in den Slider?		{			GetDItem(d,editScroll,&iType,(Handle*)&ctlHandle,&iRect);	// Handle auf Slider holen			iType=FindControl(thePoint,(WindowPtr)d,(ControlHandle*)&iHandle);			if(iHandle!=(Handle)ctlHandle)				break;					// Nicht unser Control (oder gar keins)			if(iType==inThumb)			{				TrackControl(ctlHandle,thePoint,nil);				DoScrollBar(d,iType);	// Hier nötig; wird sonst in MyScrollProc aufgerufen			}			else				TrackControl(ctlHandle,thePoint,MyScrollProc);		}		if ((event->what != keyDown)&&(event->what != autoKey)) break;//		if ((*t)->teLength<gTEMaxLen) break;	// Text evtl. zu lang?		key = event->message & charCodeMask;		if(!gAppTrue && (event->modifiers & controlKey)) // Control ruft Debugger auf		{			switch(key)			{Str255	s;				case '\33':						// Control-Esc = Debugger					Debugger();					break;				case 3:							// Control-C = Control-Test					GetDItem(d,editScroll,&iType,&iHandle,&iRect);					SetCtlMax((ControlHandle)iHandle,100);					HiliteControl((ControlHandle)iHandle,0);					break;				case 'r'-'a'+1:					// Control-R = Redraw					GetDItem(d,editScroll,&iType,&iHandle,&iRect);					iType=GetCtlValue((ControlHandle)iHandle);					iRect=userRect;					iRect.top=userRect.bottom-15;					EraseRect(&iRect);					MoveTo(userRect.left,userRect.bottom-inf.descent);					NumToString((long)userRect.left,s);					DrawString(s);					MoveTo(userRect.left+20,userRect.bottom-inf.descent);					NumToString((long)(dialogDest.left),s);					DrawString(s);					MoveTo(userRect.left+40,userRect.bottom-inf.descent);					iType=GetCtlMax((ControlHandle)iHandle);					NumToString((long)editOffset,s);					DrawString(s);					break;				case 'x'-'a'+1:					// Control-X = Toggle DontRedraw					DontRedraw=1-DontRedraw;					SysBeep(BEEPTIME);					if(!DontRedraw)						InvalRect(&dialogView);					break;				case 'u'-'a'+1:						// Page Up					DoScrollBar(d,inPageUp);					break;				case 'd'-'a'+1:						// Page Down					DoScrollBar(d,inPageDown);					break;								}			return(true);		}		if((event->modifiers & cmdKey)!=0)	// Bei Command X,C,V abtesten		{			switch(key)			{			case 'x':						// x = Cut				TECut(teHandle);				itsDirty=true;				break;			case 'c':						// c = Copy				TECopy(teHandle);				break;			case 'v':						// v = Paste				if(TestInsertLength((short)TEGetScrapLen()))	// Paßt das noch?				{					TEPaste(teHandle);					itsDirty=true;				}				else					Alert(ALRTTextTooLong,nil);				break;			case 28:						// Cursor links				TESetSelect(0,0,teHandle);				break;			case 29:						// Cursor Rechts				TESetSelect(32767,32767,teHandle);				break;			case 30:				DoScrollBar(d,inUpButton);				break;			case 31:				DoScrollBar(d,inDownButton);				break;			case 'd':						// d = Date Stamp				GetDateTime(&date);			// heutiges Datum abfragen				GetDateString(s,date,shortDate);	// Datum kopieren				PtoCstr(s);				if(TestInsertLength(strlen((STR)s)))	// Paßt das noch?				{					TEInsert(s,(long)strlen((char*)s),teHandle);					itsDirty=true;				}				else					Alert(ALRTTextTooLong,nil);				break;			case 't':						// d = Date Stamp				GetDateTime(&date);			// heutiges Datum abfragen				GetTimeString(s,date);		// Zeit kopieren				PtoCstr(s);				if(TestInsertLength(strlen((STR)s)))	// Paßt das noch?				{					TEInsert(s,(long)strlen((char*)s),teHandle);					itsDirty=true;				}				else					Alert(ALRTTextTooLong,nil);				break;			default:				return(OwnDialogFilter(d,event,item));	// allgemeinen Dialoghandler aufrufen			}			return(true);					// Auswertung abgeschlossen		}		switch(key)		{		case '\t':						// Tab?//			editX=(*teHandle)->selStart;	// Neue X-Koordinate = Anfang der alten			changeEntry=true;				// Neues TE-Feld			tabHasBeenPressed=true;			// Damit der Cursor ans Zeilenende gesetzt wird			if(shift)						// Shift-Tab?				if(editEntry)					editEntry--;			// Dann vorigen Eintrag editieren				else					editEntry=maxEditEntry;			else				if(editEntry<maxEditEntry)					editEntry++;				else					editEntry=0;			break;		case '\3':							// Enter gedrückt?			SelectControl(GetCH(d,editOK));			*item=editOK;			break;		case '\33':							// Esc gedrückt?			SelectControl(GetCH(d,editCancel));			*item=editCancel;			break;		case 11:							// Page Up			DoScrollBar(d,inPageUp);			break;		case 12:							// Page Down			DoScrollBar(d,inPageDown);			break;		case 1:								// Home			DoScrollBar(d,Home);			break;		case 4:								// End			DoScrollBar(d,End);			break;		case 28: case 29: case 30: case 31:			TEKey((char)key,t);			ScrollAfterCursorKey(d);			break;		case 127:							// Forward Delete			if((*t)->selStart==(*t)->selEnd)	// Keine Selektion-Range?				TEKey((char)29,t);			// Dann Cursor Right…			TEKey((char)8,t);				// …und Backspace			itsDirty=true;			break;		case 8:								// Backspace wird nicht in der			TEKey((char)8,t);				// Längenberechnung berücksichtigt			itsDirty=true;			break;		case '\r':			{short maxLen=(*gActset)->maxLen[editEntry];	// Längenbeschränkung für dieses Feld							if(!maxLen || (maxLen>ALLOW_RETURN) || (maxLen<-ALLOW_RETURN))	// Keine Beschränkung oder >30 Zeichen?				{								// Dann Return zulässig, sonst nicht!					if(TestInsertLength(1))			// Paßt das noch?					{						TEKey((char)key,t);			// Sonst kriegt TE die Taste						itsDirty=true;					}					else						Alert(ALRTTextTooLong,nil);				}			}			break;		default:			if(TestInsertLength(1))			// Paßt das noch?			{				ScrollAfterChangeEntry(d);				TEKey((char)key,t);			// Sonst kriegt TE die Taste				itsDirty=true;			}			else				Alert(ALRTTextTooLong,nil);		}		return(true);						// Tastencode ignorieren	}	return(OwnDialogFilter(d,event,item));	// allgemeinen Dialoghandler aufrufen}pascal void MyScrollProc(ControlHandle c,short thePart){	TEHandle		t = ((DialogPeek)d)->textH;		// Handle auf aktuelles TextEdit-Feld	short			saveFont,saveSize,saveOffset;	RgnHandle		oldRgn,thirdRgn;	DoScrollBar(d,thePart);	oldRgn=NewRgn();	if(oldRgn)	{		thirdRgn=NewRgn();		if(thirdRgn)		{			RectRgn(oldRgn,&userRect);//			InvertRgn(((WindowPeek)d)->updateRgn);			SectRgn(myUpdateRgn,oldRgn,thirdRgn);			GetClip(oldRgn);			SetClip(thirdRgn);			EraseRect(&userRect);				// Erstmal löschen			HLock((Handle)workHandle);				CopyListToDataset(gActset,workHandle);						saveSize=((GrafPtr)d)->txSize;			saveFont=((GrafPtr)d)->txFont;			saveOffset=ADOC.columnOffset;			TextSize(MAX_EDITOR_FONT_SIZE); // TextSize(ADOC.fontSize>MAX_EDITOR_FONT_SIZE?MAX_EDITOR_FONT_SIZE:ADOC.fontSize);			TextFont(EDITOR_FONT);			ADOC.columnOffset=editOffset;			DisplayEntry(userRect.left,userRect.top-Slider,gActset,zeilenHoehe,workHandle,displayEditor);			TextFont(saveFont);			TextSize(saveSize);			ADOC.columnOffset=saveOffset;			HUnlock((Handle)workHandle);			SetClip(oldRgn);					// Alte Clip-Region restaurieren			DisposeRgn(thirdRgn);		}		DisposeRgn(oldRgn);	}}////	Klick ins Scroll-Bar auswerten [auch Tastaturäquivalente]//void	DoScrollBar(DialogPtr d,short iType){	ControlHandle	ctlHandle;	Rect			iRect;	short			i,j;	GetDItem(d,editScroll,&j,(Handle*)&ctlHandle,&iRect);	// Handle auf Slider holen	switch(iType)				// Wohin wurde denn geklickt?	{	case inUpButton:		i=GetCtlValue(ctlHandle)-1;		if(i>=GetCtlMin(ctlHandle))			SetCtlValue(ctlHandle,i);		break;	case inDownButton:		i=GetCtlValue(ctlHandle)+1;		if(i<=GetCtlMax(ctlHandle))			SetCtlValue(ctlHandle,i);		break;	case inPageUp:		i=GetCtlValue(ctlHandle)-userItemZeilen;		if(i>=GetCtlMin(ctlHandle))			SetCtlValue(ctlHandle,i);		else			SetCtlValue(ctlHandle,GetCtlMin(ctlHandle));		break;	case inPageDown:		i=GetCtlValue(ctlHandle)+userItemZeilen;		if(i<=GetCtlMax(ctlHandle))			SetCtlValue(ctlHandle,i);		else			SetCtlValue(ctlHandle,GetCtlMax(ctlHandle));		break;	case Home:		SetCtlValue(ctlHandle,0);						// Home: Ganz nach oben		break;	case End:		SetCtlValue(ctlHandle,GetCtlMax(ctlHandle));	// End: Ganz nach unten		break;	}	ScrollRect(&userRect,0,Slider-GetCtlValue(ctlHandle)*zeilenHoehe,myUpdateRgn);	if(DontRedraw)		FrameRgn(myUpdateRgn);	else			InvalRgn(myUpdateRgn);	Slider=GetCtlValue(ctlHandle)*zeilenHoehe;	SetDialogRect(editEntry,editT,d);	// Setzt dialogRect für Eintrag 0	(*teHandle)->viewRect=dialogView;	(*teHandle)->destRect=dialogDest;}pascal Boolean MyWordBreaker(char *textPtr, short offset){	return(textPtr[offset]=='\r');}////	Berechnet die TextEdit-Ausmaße für das Feld #entry//void	SetDialogRect(int entry, char *editText, DialogPtr dialog){	short			lineCount,i,j,max,saveSize,saveFont,newTextEdit;	datasetP		list;	Rect			tempRect;		// Linker Rand wurde schon am Anfang berechnet	dialogDest.left=editOffset+userRect.left-1;		// Rechter Rand = n mal Breite eines "x"	saveSize=((GrafPtr)d)->txSize;	saveFont=((GrafPtr)d)->txFont;	TextSize(MAX_EDITOR_FONT_SIZE); // TextSize(ADOC.fontSize>MAX_EDITOR_FONT_SIZE?MAX_EDITOR_FONT_SIZE:ADOC.fontSize);	TextFont(EDITOR_FONT);	if(GetGestaltResult(gestaltTextEditVersion)>gestaltTE4)		newTextEdit=1;	else		newTextEdit=0;	dialogDest.right=dialogDest.left+CharWidth('—')*(FieldWidthCalc(workHandle)+newTextEdit);	TextFont(saveFont);	TextSize(saveSize);		// Jetzt wird abgezählt, welcher Eintrag editiert werden muß, und	// an welchen Koordinaten er steht	for( i=lineCount=0 ; (i<MAX_NAMES) && (i<entry) ; lineCount+=fieldLength[i++] ) ;	dialogDest.top=userRect.top+zeilenHoehe*lineCount-Slider+inf.descent+1;	// Das Edit-Fenster ist mindestens eine Zeile hoch	dialogDest.bottom=dialogDest.top+zeilenHoehe*(fieldLength[entry]==0?1:fieldLength[entry]);	dialogView=dialogDest;	InsetRect(&dialogView,-2,-2);	// Das View-Fenster ist um je 2 Pixel größer	SectRect(&dialogView,&userRect,&dialogView);	// "Clipping" mit dem UserItem	// Jetzt noch den Text des aktuellen Feldes in gActset unterbringen	// (gActset ist gelocked)//	HLock((Handle)workHandle);	list=(*gActset);//	list=(*workHandle);	max=strlen(list->data);	for( i=j=0 ; (i<max) && (j<entry) ; i++ )	// i auf erstes Zeichen des gesuchten Teilstrings		if(list->data[i]==RETURN)			j++;	for ( j=0 ; (i<max) && ((list->data[i])!=RETURN) ; i++,j++ )		if(list->data[i]!=CRLF)				// Cr des Sharp…			editText[j]=list->data[i];		else			editText[j]='\r';				// …in Mac-Cr wandeln	editText[j]=0;							// String noch terminieren//	HUnlock((Handle)workHandle);}////	Scrollt automatisch, wenn das Feld gewechselt wurde//void	ScrollAfterChangeEntry(DialogPtr d){	ControlHandle	ctlHandle;	Rect 			dummy;	short			i,j,k;	GetDItem(d,editScroll,&i,(Handle*)&ctlHandle,&dummy);	// Handle auf Slider holen	for( i=j=0 ; i<editEntry ; j+=fieldLength[i]?fieldLength[i++]:1) ;	// Längen der vorigen Felder addieren	for( k=0 ; (k<(*teHandle)->nLines) && ((*teHandle)->selEnd>((*teHandle)->lineStarts)[k]) ; k++) ;	j+=k;	i=GetCtlValue(ctlHandle);				// Weggescrollte Zeilen	j-=i;	if((j<userItemZeilen) && (j>0))			// Cursor ist innerhalb des Windows?		return;								// Dann ist nichts zu scrollen	if(j>0) //dialogDest.bottom>userRect.bottom)	// Wurde unten etwas weggeclipped?	{		for( i=j=0 ; i<=editEntry ; j+=fieldLength[i]?fieldLength[i++]:1) ;	// Längen der vorigen Felder addieren		j-=userItemZeilen;		i=GetCtlMax(ctlHandle);		SetCtlValue(ctlHandle,i<j?i:j);		// Feld nach unten sliden (Maximalwert beachten)		DoScrollBar(d,0);					// Scrollen, Slider updaten	}else	{//		if(dialogDest.top<userRect.top)		// Wurde oben etwas weggeclipped?		{			for( i=j=0 ; i<=editEntry ; j+=fieldLength[i]?fieldLength[i++]:1) ;	// Längen der vorigen Felder addieren			j-=userItemZeilen;			i=GetCtlMin(ctlHandle);			SetCtlValue(ctlHandle,i<j?i:j);	// Feld nach oben sliden (Minimalwert beachten)			DoScrollBar(d,0);				// Scrollen, Slider updaten		}	}}void	ScrollAfterCursorKey(DialogPtr d){	ControlHandle	ctlHandle;	Rect 			dummy;	short			i,j,k;	GetDItem(d,editScroll,&i,(Handle*)&ctlHandle,&dummy);	// Handle auf Slider holen	for( i=j=0 ; i<editEntry ; j+=fieldLength[i]?fieldLength[i++]:1) ;	// Längen der vorigen Felder addieren	for( k=0 ; (k<(*teHandle)->nLines) && ((*teHandle)->selEnd>((*teHandle)->lineStarts)[k]) ; k++) ;	j+=k;	i=GetCtlValue(ctlHandle);				// Weggescrollte Zeilen	j-=i;		if(j>=userItemZeilen)	// Cursor ist unten raus	{		i++;		k=GetCtlMax(ctlHandle);		SetCtlValue(ctlHandle,i<k?i:k);	// Feld nach oben sliden (Minimalwert beachten)		DoScrollBar(d,0);				// Scrollen, Slider updaten	}else		if(j<=0)							// Cursor ist oben raus		{			i--;			k=GetCtlMax(ctlHandle);			SetCtlValue(ctlHandle,i<k?i:k);	// Feld nach unten sliden (Maximalwert beachten)			DoScrollBar(d,0);				// Scrollen, Slider updaten		}}////	Berechnet die Länge aller Felder von workHandle und legt sie in//	fieldLength[] ab//void	CalcFieldLength(char *d, short w,DialogPtr dialog){	short			i,k,zeilen,field,alltogether;	ControlHandle	ctlHandle;	Rect			dummy;	i=k=zeilen=field=alltogether=0;	while(d[i])								// Bis 0-Byte = Stringende zählen	{		if((d[i]!=CRLF) && (d[i]!=RETURN) && (k<w))	// Bei Return oder w Zeichen oder Feldende			k++;		else		{			zeilen++;						// Feld nicht ausgeblendet wurde			if(d[i]==RETURN)				// Feldende?			{				fieldLength[field++]=zeilen;				if(zeilen)				{					alltogether+=zeilen;	// Gesamtzeilenzahl					zeilen=0;				}				else					alltogether++;			// Leereinträge kosten auch 1 Zeile				if((*gActset)->text[field][0]==END_OF_LIST)	// Letztes Feld erreicht?					break;					// Dann abbrechen			}			if((k==w) && (d[i]!=RETURN))	// Zeile voll?				i--;						// dann i++ ausgleichen;			k=0;							// fängt ne neue Zeile an		}		i++;	}	if(((*gActset)->text[field][0]!=END_OF_LIST) && (d[i-1]!=RETURN))	// Noch was übrig? (letzter String nicht RETURN-terminiert)	{		fieldLength[field++]=++zeilen;		alltogether+=zeilen;				// Gesamtzeilenzahl	}	// Für Leereinträge am Ende gibt's nicht immer genug Returns…	while(((*gActset)->text[field++][0]!=END_OF_LIST) && (field<MAX_NAMES)) 		alltogether++;	// Nun noch den Maximalwert für den Slider berechnen	alltogether-=userItemZeilen;			// - Größe des UserItems in Zeilen	GetDItem(dialog,editScroll,&i,(Handle*)&ctlHandle,&dummy);	// Handle auf Slider holen	if(alltogether>0)	{		SetCtlMax(ctlHandle,alltogether);		HiliteControl((ControlHandle)ctlHandle,0);	}else	{		SetCtlMax(ctlHandle,0);		HiliteControl((ControlHandle)ctlHandle,255);	}}////	Auswahl der Terminart beim Editorstart durch den User, wenn SHIFT gedrückt.//IQFileType	ChooseSchedulerType(void){	DialogPtr	dPtr;	short		item,item2,i;	OrganizerH	o;	o = GetOrgH(gDoc);					// Handle auf den Organizer ermitteln	if (o)		i = (*o)->type;					// Typ vom aktuellen Dokument	else		return(schSelSchedule);			// Kein Dokument vorhanden!?	dPtr = GetCenteredDialog(DLOGSchedSelect,nil);	if(dPtr)	{		item=schSelAnn1;					// Default-Button		if(!(i & IQGetOrgMask(PERIOD)))		// Wenn kein 8000er, dann keine Periods.			HiliteControl(GetCH(dPtr,schSelPeriod),255);		if(!(i & IQGetOrgMask(DALARM)))		// …und keine Daily Alarms			HiliteControl(GetCH(dPtr,schSelDalarm),255);		do		{			item2=item;			for( i=schSelSchedule ; i<=schSelDalarm ; i++ )	// Radio-Buttons setzen				SetCtlValue(GetCH(dPtr,i),i==item);							ModalDialog((ModalFilterProcPtr)OwnDialogFilter,&item);		}while((item!=schSelOK) && (item!=schSelCancel));				DisposDialog(dPtr);				if(item==schSelCancel)			return(UNKNOWNFILE);		else			return(item2-schSelSchedule+SCHEDULE);	}else		return(UNKNOWNFILE);}////	Wenn der übergebene oder angelegte Datensatz nicht genügend Returns enthält, werden//	sie hier angehängt//void	AddReturnsIfNecessary(ListH lHandle){	short		i,j,oldReturnNumber;	ListP		lPointer;	char		hstate;		hstate = HGetState((Handle)lHandle);			// Aus Geschwindigkeitsgründen dereferenzieren	if (!(hstate & 0x80))		HLock((Handle)lHandle);	lPointer=*lHandle;		for( i=oldReturnNumber=0 ; lPointer->d[i] ; )	// strlen Ersatz, bei dem die RETURNs		if(lPointer->d[i++]==RETURN)				// gezählt werden,			oldReturnNumber++;				// Wieviele Returns sollten es sein?	for( j=oldReturnNumber ; (j<MAX_LENGTH) && ((*gActset)->text[j][0]!=END_OF_LIST) ; j++) ;	HUnlock((Handle)lHandle);							// Handle nötigenfalls vergrößern	SetHandleSize((Handle)lHandle,GetHandleSize((Handle)lHandle)+j-oldReturnNumber);	if(MemError()!=noErr)	{		OwnBeep(shit);		return;	}		for( ; j>oldReturnNumber ; j--)				// Nötigenfalls nun die Returns daran…		(*lHandle)->d[i++]=RETURN;	(*lHandle)->d[i]=0;							// Nullterminieren…	HSetState((Handle)lHandle,hstate);			// Handle wieder auf alten Status zurück}////	Testet, ob die angegebene Zeichenzahl noch angehängt werden darf, oder ob der//	Text dann zu lang wird//Boolean	TestInsertLength(short number){	short		i;	Boolean		checkTotalLength=true;		number-=(*teHandle)->selEnd-(*teHandle)->selStart;	// Größe der Selection abziehen		i=(*gActset)->maxLen[editEntry];			// Gibt's eine Beschränkung für dieses Feld?	if(i<0)										// Negativ indiziert, daß dieses Feld	{											// Nicht in der Gesamtlänge zu berücksichtigen		checkTotalLength=false;					// ist.		i=-i;	}		if(i && (number+(*teHandle)->teLength>i))	// Und wird diese hierbei überschritten?		return(false);							// Dann unzulässig	if(checkTotalLength)		if(totalLength+number+(*teHandle)->teLength>(*gActset)->setLength)	// Größer als Gesamtlänge?			return(false);	return(true);}////	Zurückschreiben des Editor-Textes in die Liste an eine best. Position//void	WriteDataToList(short entry, CharsHandle textFromTE){	short			i,j,k,max;	ListP			list;	char			*temp,*tempCopy;	Size			size;	char			*editText;	char			standard=-1,oldState;	HLock((Handle)textFromTE);	editText=(char*)*textFromTE;	temp=NewPtr(TE_LENGTH);		if(MemError()!=noErr)					// Ohne Speicher müssen wirs	{										// leider ignorieren		SysBeep(20);		return;	}		BlockMoveData(editText,temp,(*teHandle)->teLength);	temp[(*teHandle)->teLength]=0;	// Für Suchfunktionen 0-terminieren	oldState=HLockH((Handle)workHandle);	list=(*workHandle);						// Schon mal dereferenzieren	max=strlen(list->d);		switch(list->type)	{	case SCHEDULE:		switch(entry)		{		case 0:								// Datum			DateToList(editText,(*teHandle)->teLength,&list->t.schedule.year,				&list->t.schedule.month,&list->t.schedule.day,false);			break;		case 1:								// Von/Bis-Zeit//			oldTE=editText[(*teHandle)->teLength];			tempCopy=strchr(temp,'-');	// Nach Zeittrennern suchen			i=0;			if(tempCopy)				i=tempCopy-temp;			else			{				tempCopy=strchr(temp,'~');				if(tempCopy)					i=tempCopy-temp;				else				{					tempCopy=strchr(temp,'/');					if(tempCopy)						i=tempCopy-temp;					else					{						tempCopy=strchr(temp,'\\');						if(tempCopy)							i=tempCopy-temp;					}				}			}			TimeToList(temp,i?i:(*teHandle)->teLength,&(list->t.schedule.shour),&(list->t.schedule.sminute));			if(i)				TimeToList(temp+i+1,(*teHandle)->teLength-i-1,&(list->t.schedule.ehour),&(list->t.schedule.eminute));			else				list->t.schedule.ehour=list->t.schedule.eminute=-1;//			[(*teHandle)->teLength]=oldTE;			break;		case 2:								// Alarmzeit			if(TimeToList(temp,(*teHandle)->teLength,&(list->t.schedule.ahour),&(list->t.schedule.aminute)))			{				list->b.alarm=0;		// Keine Alarmzeit: Alarm ausschalten			}else				list->b.alarm=1;		// Sonst entsprechend einschalten			break;		default:			standard=3;			break;		}		break;	case ANN1:		switch(entry)		{		case 0:								// Datum			Ann1ToList(temp,(*teHandle)->teLength,&list->t.ann1.month,&list->t.ann1.date);			break;		default:			standard=1;			break;		}		break;	case ANN2:		switch(entry)		{		case 0:								// Ann2-Datum			Ann2ToList(temp,(*teHandle)->teLength,&list->t.ann2.month,&list->t.ann2.week,				&list->t.ann2.day);			break;		default:			standard=1;			break;		}		break;	case PERIOD:		switch(entry)		{		case 0:								// Datum			DateToList(temp,(*teHandle)->teLength,&list->t.psched.syear,				&list->t.psched.smonth,&list->t.psched.sday,false);			break;		case 1:								// Datum			DateToList(temp,(*teHandle)->teLength,&list->t.psched.eyear,				&list->t.psched.emonth,&list->t.psched.eday,false);			break;		default:			standard=2;			break;		}		break;	case DALARM:		TimeToList(temp,(*teHandle)->teLength,&list->t.dalarm.hour,&list->t.dalarm.minute);		break;	case EXPENSE:		switch(entry)		{		case 0:								// Datum			DateToList(editText,(*teHandle)->teLength,&list->t.expense.year,				&list->t.expense.month,&list->t.expense.day,false);			break;		default:			standard=1;			break;		}		break;	case DOLIST: case TODO:		switch(entry)		{Str255 s;		case 0:								// Datum			DateToList(editText,(*teHandle)->teLength,&list->t.todo.year,				&list->t.todo.month,&list->t.todo.day,false);			break;		case 1:								// Priorität			s[0]=(*teHandle)->teLength;			s[1]=editText[0];			s[2]=editText[1];			UppercaseText((char*)s+1,s[0],smSystemScript);	// Priorität nur groß und ohne diakritische Zeichen			switch(s[0])					// Wie lang ist die Priorität?			{			case 0:				list->t.todo.prio=' ';		// Kein Zeichen eingegeben				break;			case 1:				list->t.todo.prio=s[1];		// Ein Zeichen				break;			case 2:				list->t.todo.prio=(s[1]<<8)+s[2];	// Zwei Zeichen				break;			default:						// Alles andere ist Güll				SysBeep(BEEPTIME);			}			break;		default:			standard=2;			break;		}		break;	default:		standard=0;	}											// switch(type) ende	if(standard>=0)								// Standardprozedur	{		for( i=j=0 ; (i<max) && (j<entry-standard) ; i++ ) // Erstmal den Text vor dem			if(list->d[i]==RETURN)				// geänderten Feld				j++;			strcpy(temp,list->d);			k=(*teHandle)->teLength;		// Dann den geänderten Teil drüberkopieren		for ( j=0 ; j<k ; i++,j++ )			if(editText[j]!='\r')				// Mac-Cr…				temp[i]=editText[j];			else				temp[i]=CRLF;					// …in Sharp-Cr wandeln			// Zuletzt den nicht geänderten Teil dranhängen		for( j=k=0 ; (j<max) && (k<entry-standard+1) ; j++ )			if(list->d[j]==RETURN)				k++;			temp[i++]=RETURN;						// Das Feld terminieren		while(list->d[j]!=0)			temp[i++]=list->d[j++];		temp[i]=0;								// String noch terminieren		HUnlock((Handle)workHandle);				size=GetHandleSize((Handle)workHandle)-max+i;	// Handle auf neue Größe anpassen		SetHandleSize((Handle)workHandle,size);		if(MemError()!=noErr)					// Nicht genügend Speicher?		{			for( i=0 ; i<3 ; i++)				SysBeep(20);					// Dann 3mal fiepen			DoDialog(DLOGOutOfMemory,1);		}		else		{			HLock((Handle)workHandle);			strcpy((*workHandle)->d,temp);		// Sonst String reinkopieren			HUnlock((Handle)workHandle);		}	}else		HUnlock((Handle)workHandle);					// Durch switch nicht unbedingt gegeben	DisposePtr(temp);	HSetState((Handle)textFromTE,oldState);}////	Wandelt eine ASCII-Zeit in hour/minute//Boolean	TimeToList(char *ptr,short laenge,char *hour,char *minute){	Boolean		guelle=false;	short		number,i;	char		*temp,*temp1;		if(laenge<1)							// Gar nix eingegeben?		return(true);						// Dann Eingabe ungültig, aber kein Beep	*minute=0;	if((ptr[0]<'0') || (ptr[0]>'9'))		// Erste Stelle keine Ziffer?		guelle=true;	if((ptr[1]<'0') || (ptr[1]>'9') || (laenge<2))	// Zweite Stelle keine Ziffer?	{		number=ptr[0]-'0';					// Dann nur 1 Ziffer		i=1;	}else	{		number=ptr[0]-'0';		number=number*10+ptr[1]-'0';		// Sonst 2 Ziffern		i=2;	}		if(number<24)		*hour=number;						// Stunden komplett eingelesen	else		guelle=true;		if((laenge>i+1) && !guelle)				// Noch mehr Ziffern?	{		if((ptr[i]>='0') && (ptr[i]<='9'))	// Trenner = Ziffer?			guelle=true;			// Nun noch die Minuten		if((ptr[++i]>='0') && (ptr[i]<='9'))	// Erste Stelle keine Ziffer?		{			if((ptr[i+1]<'0') || (ptr[i+1]>'9') || (laenge<=i+1))	// Zweite Stelle keine Ziffer?			{				number=ptr[i]-'0';				// Dann nur 1 Ziffer			}else			{				number=ptr[i]-'0';				number=number*10+ptr[i+1]-'0';		// Sonst 2 Ziffern			}			if(number<60)				*minute=number;			else				guelle=true;		}	}	if(((temp=strstr(ptr,"pm")) || (temp1=strstr(ptr,"PM"))) && (*hour<12))	{		if(!temp)			temp=temp1;		number=temp-ptr;				// Steht das "pm" hinter dem Stringende?		if(number<=laenge)				// Dann ignorieren			*hour+=12;					// Sonst 12 Stunden draufaddieren	}		if(guelle)	{		SysBeep(20);					// Beim Fehler beepen		*hour=*minute=-1;			// …und Wert auf "leer" setzten	}	return(guelle);}////	Wandelt ein ASCII-Datum in ANN1//Boolean	Ann1ToList(char *ptr,short laenge,char *month,char *day){	Boolean		guelle=false;	short		number,i;		if(laenge<3)							// Gar nix eingegeben?		return(true);						// Dann Eingabe ungültig, aber kein Beep	*day=0;	if((ptr[0]<'0') || (ptr[0]>'9'))		// Erste Stelle keine Ziffer?		guelle=true;	if((ptr[1]<'0') || (ptr[1]>'9') || (laenge<2))	// Zweite Stelle keine Ziffer?	{		number=ptr[0]-'0';					// Dann nur 1 Ziffer		i=1;	}else	{		number=ptr[0]-'0';		number=number*10+ptr[1]-'0';		// Sonst 2 Ziffern		i=2;	}		if(number<32)		*day=number;						// Tag komplett eingelesen	else		guelle=true;		if((laenge>i+1) && !guelle)				// Noch mehr Ziffern?	{		if((ptr[i]>='0') && (ptr[i]<='9'))	// Trenner = Ziffer?			guelle=true;			// Nun noch den Monat		if((ptr[++i]>='0') && (ptr[i]<='9'))	// Erste Stelle keine Ziffer?		{			if((ptr[i+1]<'0') || (ptr[i+1]>'9') || (laenge<=i+1))	// Zweite Stelle keine Ziffer?			{				number=ptr[i]-'0';				// Dann nur 1 Ziffer			}else			{				number=ptr[i]-'0';				number=number*10+ptr[i+1]-'0';		// Sonst 2 Ziffern			}			if(number<13)				*month=number;			else				guelle=true;		}	}else		guelle=true;	if(ndays[*month-1]<*day)			// Der Monat hat gar nicht so viele Tage		guelle=true;		if(guelle)	{		SysBeep(20);					// Beim Fehler beepen		*day=*month=-1;					// …und Wert auf "leer" setzten	}	return(guelle);}////	Wandelt ein ASCII-Datum in ANN2//Boolean	Ann2ToList(char *ptr,short laenge,char *month,char *week,char *day){	Boolean		guelle=false;	short		number,i;		if(laenge<5)							// Gar nix eingegeben?		return(true);						// Dann Eingabe ungültig, aber kein Beep	*month=0;	if((ptr[0]<'0') || (ptr[0]>'9'))		// Erste Stelle keine Ziffer?		guelle=true;	if((ptr[1]<'0') || (ptr[1]>'9') || (laenge<2))	// Zweite Stelle keine Ziffer?	{		number=ptr[0]-'0';					// Dann nur 1 Ziffer		i=1;	}else	{		number=ptr[0]-'0';		number=number*10+ptr[1]-'0';		// Sonst 2 Ziffern		i=2;	}		if(number<13)		*month=number;						// Tag komplett eingelesen	else		guelle=true;		if((laenge>i+1) && !guelle)				// Noch mehr Ziffern?	{		if((ptr[i]>='0') && (ptr[i]<='9'))	// Trenner = Ziffer?			guelle=true;			// Nun noch die Woche		if((ptr[++i]>='0') && (ptr[i]<='9'))	// Erste Stelle keine Ziffer?		{			number=ptr[i++]-'0';		// Dann nur 1 Ziffer			if(number<6)				*week=number;			else				guelle=true;			// Zuletzt den Wochentag			if((laenge>i+1) && !guelle)				// Noch mehr Ziffern?			{				if((ptr[i]>='0') && (ptr[i]<='9'))	// Trenner = Ziffer?					guelle=true;							if((ptr[++i]>='0') && (ptr[i]<='9'))	// Erste Stelle keine Ziffer?				{					number=ptr[i]-'0';		// Nur 1 Ziffer					if(number<7)						*day=number;					else						guelle=true;				}else					guelle=true;			}else				guelle=true;		}else			guelle=true;	}else		guelle=true;	if(guelle)	{		SysBeep(20);					// Beim Fehler beepen		*day=*week=*month=-1;			// …und Wert auf "leer" setzten	}	return(guelle);}//// Desgleichen fürs Datum// ignoreDay=TRUE: Bei 2 eingegebenen Zahlen wird daraus Monat/Jahr, sonst Tag/Monat//Boolean DateToList(char *ptr,short length,short *year,char *month,char *day,Boolean ignoreDay){	short			result,dateTemp[3],dummy;	char			daysInMonth,defaultPos,old;	Boolean			guelle=false;	unsigned long	date;	DateTimeRec		shortDateTime;	Intl0Hndl		intl;	DateOrders		theOrder;	static char	dateConv[3][6][3]={{{1,0,2},{0,1,2},{2,1,0},{2,0,1},{0,2,1},{1,2,0}},								{{0,1,2},{0,1,2},{0,2,1},{0,1,2},{0,2,1},{0,2,1}},								{{1,0,2},{0,1,2},{1,0,2},{1,0,2},{0,1,2},{0,1,2}}};	if((ptr==nil) || (!length))		return(true);						// Kein Text = Fehler			old=ptr[length];	ptr[length]=0;	result=sscanf((Ptr)ptr,"%d%c%d%c%d",&dateTemp[0],&dummy,&dateTemp[1],&dummy,&dateTemp[2]);	ptr[length]=old;		if(result<3)							// Nicht alle Elemente ausgewertet	{		SysBeep(20);		return(true);	}		if(result<5)							// Nur 2 Werte angegeben	{		if(ignoreDay)		{			dateTemp[2]=dateTemp[1];			dateTemp[1]=dateTemp[0];			dateTemp[0]=1;			defaultPos=1;		}else		{			GetDateTime(&date);				// Auf heutiges Datum setzen			Secs2Date(date,&shortDateTime);	// Jahr und Monat berechnen			dateTemp[2]=shortDateTime.year;			defaultPos=2;		}	}else		defaultPos=0;						// Alle 3 Werte angegeben		intl=(Intl0Hndl)MyGetIntl(shortDate);	if(intl)	{		theOrder=(*intl)->dateOrder;		HPurge((Handle)intl);				*year=dateTemp[dateConv[defaultPos][theOrder][2]];		*month=dateTemp[dateConv[defaultPos][theOrder][1]];		*day=dateTemp[dateConv[defaultPos][theOrder][0]];	}else	{		*year=dateTemp[2];					// Intl-Resource nicht lesbar, dann default		*month=dateTemp[1];		*day=dateTemp[0];	}		if(*year<39)		*year+=2000;	if(*year<100)		*year+=1900;			if((*year<MIN_YEAR) || (*year>MAX_YEAR))	// Jahr im falschen Bereich?		guelle=true;	if((*month<1) || (*month>12))				// Monat gültig?		guelle=true;	daysInMonth=ndays[*month-1];				// Wieviele Tage hat der akt. Monat?	if((*month==2) && (!(*year%4)))		daysInMonth++;							// Februar und Schaltjahr gibt einen Bonustag	if((*day<1) || (*day>daysInMonth))			// Tag im falschen Bereich?		guelle=true;		if(guelle)	{		SysBeep(20);					// Beim Fehler beepen		*day=*month=*year=-1;			// …und Wert auf "leer" setzten	}		return(guelle);}