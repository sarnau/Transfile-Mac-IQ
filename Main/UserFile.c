/*** *	UserFile.c ***/#include "GlobalDefines.h"#include "Windows.h"#include "xRsrcDefines.h"#include "Geos.h"#include "Memo.h"#include "Calendar.h"#include "Userfile.h"#include "List.h"/*** *	Window öffnen ***/OSErr	OpenUserfileWindows(void)		// Window für UserFiles öffnen{	Handle		xWindow;	REG WindPtr	w1;	w1 = MyOpenWind(FULLER | (1L<<noOrigin),WindUserFile,strUserFile,USERFILE1);	// Window mit Slidern	if(!w1) 		return(memFullErr);				// Fehler beim Öffnen 	xWindow=w1->MoreMem;	XWIN->floatVar=TEL_DEFAULT;			// Default = Alle 3 Kategorien	MultiOpen(w1,USERFILE1);	WFUNC(w1,menuupdate,calendarupdate);// Darstellung disabeln	return(noErr);						// alles ok!}////	Erstellt Default-Freifelder für Anwenderdateien.//void	CreateUserFileDefaults(OrganizerH o){	REG short 	fieldCount,j=1,length;	short		i;	ListH		lHandle;	char		str[255];	REG char	*dPointer;		if( !gDoc || ORG.userfree )							// Gibt es kein Dokument oder gibt es schon User-Free-Fields?		return;	for( i=USER1FREE ; i<=USER3FREE ; i++)				// 3 Bereiche gibt es	{		lHandle=(ListH)NewHandle(sizeof(List)+1+TITLE_LENGTH+(FREE_STR_LENGTH+1)*NUMBER_OF_FREE_FIELDS);	// Neue ListHandle		if(!lHandle)		{			for( j=1 ; j<=3 ; j++)						// Kein Speicher mehr frei…				SysBeep(BEEPTIME);			return;		}		HLock((Handle)lHandle);		dPointer=(char*)((*lHandle)+1)-2;				// Anfang des d-Teils (+1 = +1*sizeof(List))		length=TITLE_LENGTH;							// Erster Eintrag = Titel (nur 10 Zeichen lang)		fieldCount=0;		while(fieldCount<=NUMBER_OF_FREE_FIELDS)		{			GetIndString((unsigned char*)&str,strUserFreeDefaults,j++);	// Nächsten String einlesen			if((str[0]==3) && (str[1]=='*')) break;		// *** ist Endekennung						while(str[0]<length) str[++str[0]]=' ';		// Wenn zu kurz, dann mit Spaces auffüllen					BlockMoveData(str+1,dPointer,length);			// Text (ohne Längenbyte) kopieren			dPointer+=length;							// Dorthin kommt der nächste Eintrag			(*dPointer)=RETURN;							// Feldtrenner hintendran			dPointer++;			length=FREE_STR_LENGTH;						// Alle Folgeeinträge sind Freifelder		}		(*dPointer)=0;									// String nullterminieren		(*lHandle)->type=i;								// Richtigen Typ zuweisen		HUnlock((Handle)lHandle);		(*lHandle)->next=(*lHandle)->prev=nil;		AppendToList(o,i,lHandle);						// Einsortieren	}}