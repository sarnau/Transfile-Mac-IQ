/*** *	Importieren ***/#include "rsrcDefines.h"#include "Geos.h"#include "Print.h"#include "Windows.h"#include "GeosMore.h"#include "List.h"#include "DialogLib.h"#include "Memo.h"#include "AktDocStruct.h"#include "Utilities.h"#include "GlobalLib.h"#include "GlobalStruct.h"#include "File.h"#include "DoEvent.h"#include "IQComm.h"#include "CheckList.h"#include <String.h>#include <stdio.h>#define	dImport			153#define	dImportUnknown	154short	ImportFormat(Ptr p,long len);void	DoImport(void);enum {						// die verschiedenen Import-Formate	ImFmBasic = 1,	ImFmSYLK,	ImFmKomma,	ImFmSerienbrief,	ImFmTab					// Tab MUSS das hinterste Format sein, da es z.B. Texte							// ohne Tabs auch umfaßt!!!};Handle		ImH;			// Handle auf die zu importierenden Datenlong		ImOffset;		// aktueller Leseoffset auf die Datenlong		ImSize;			// Größe der ImportdatendatasetH	ImData;			// Handle auf die Import-Daten-StrukturUWORD		ImMaxLen;		// maximale Satzlänge// folgende Felder werde von den Setup-Funktionen ausgefülltshort		ImFeldAnz;		// Feldanzahl in der Import-Dateishort		ImSatzAnz;		// Anzahl der Datensätzetypedef struct ImportStruct {	void	(*setup)(void);		// Setup-Funktion	void	(*getfeld)(short satz,short feld,USTR s);	// ein Feld aus einem best. Datensatz holen	Boolean	(*check)(Ptr p,long size);	// Testen, ob das Format stimmt} ImportStruct;void	ImBasicSetup(void);void	ImSYLKSetup(void);void	ImTabSetup(void);void	ImKommaSetup(void);void	ImSerienSetup(void);void	ImBasicGetfeld(short satz,short feld,USTR s);void	ImSYLKGetfeld(short satz,short feld,USTR s);void	ImTabGetfeld(short satz,short feld,USTR s);void	ImKommaGetfeld(short satz,short feld,USTR s);void	ImSerienGetfeld(short satz,short feld,USTR s);Boolean	ImBasicCheck(Ptr buf,long len);Boolean	ImSYLKCheck(Ptr buf,long len);Boolean	ImTabCheck(Ptr buf,long len);Boolean	ImKommaCheck(Ptr buf,long len);Boolean	ImSerienCheck(Ptr buf,long len);struct ImportStruct ImS[] =	{		{ ImBasicSetup,ImBasicGetfeld,ImBasicCheck },	// Basic		{ ImSYLKSetup,ImSYLKGetfeld,ImSYLKCheck },		// SYLK		{ ImKommaSetup,ImKommaGetfeld,ImKommaCheck },	// Text mit Komma		{ ImSerienSetup,ImSerienGetfeld,ImSerienCheck },// Serienbrief		{ ImTabSetup,ImTabGetfeld,ImTabCheck },			// Text mit Tab		{ 0,0,0 }										// letzter Eintrag	};/*** *	einige kleine Funktionen für den “Dateizugriff” ***/UCHAR	ImGetAktByte(VOID);UCHAR	ImGetByte(VOID);VOID	ImSkipBytes(REG UCHAR c,Boolean anf);LONG	ImGetZahl(VOID);/*** *	aktuelles Byte aus der Datei holen ***/UCHAR	ImGetAktByte(VOID){REG LONG	l = ImSize;REG UCHAR	c;	if (ImOffset > l) ImOffset = l;		// hinter dem Dateiende? => dann auf das Ende setzen	if (ImOffset == l) return(0);		// Dateiende!	c = *((*ImH)+ImOffset);				// aktuelles Zeichen holen	if (c == '\n')						// Linefeed?		c = ImGetByte();				// einfach ignorieren!	return(c);}/*** *	Byte aus der Datei holen ***/UCHAR	ImGetByte(VOID){REG LONG	l = ImSize;REG UCHAR	c;	if (ImOffset > l) ImOffset = l;		// hinter dem Dateiende? => dann auf das Ende setzen	if (ImOffset == l) return(0);		// Dateiende!	c = *((*ImH)+ImOffset++);			// nächstes Zeichen holen	if (c == '\n')						// Linefeed?		c = ImGetByte();				// einfach ignorieren!	return(c);}/*** *	bis zum nächsten “char” alles überlesen ***/VOID	ImSkipBytes(REG UCHAR c,Boolean anf){REG UCHAR	d;REG Boolean	first = true;	do {		d = ImGetByte();		if (first) {					// erstes Zeichen?			if ((d == '\"')&&(anf))		// ein Anführungszeichen? (und dieses auch beachten?)				ImSkipBytes('\"',false);// Anführungszeichen überspringen			first = false;				// erstes Zeichen erledigt		}	} while((d != 0)&&(d != c));}/*** *	Zahl ab der aktuellen Position holen ***/LONG	ImGetZahl(VOID){UCHAR		c;REG LONG	zahl = 0;	c = ImGetByte();	while((c >= '0')&&(c <= '9')) {		// nur Ziffern sind erlaubt!		zahl = zahl * 10 + (c - '0');		c = ImGetByte();	}	if (c != 0) ImOffset--;				// Ptr auf das Zeichen HINTER die Zahl zurück	return(zahl);}/*** *	Setup-Funktionen für alle Formate ***/void	ImListSetup(char trenner);void	ImListSetup(char trenner){long	count = 0;long	saveoffset = ImOffset;char	c;	do {		ImSkipBytes('\r',false);// Zeilen zählen…		count++;	} while(ImGetByte() != 0);	// bis zum Dateiende	ImOffset = saveoffset;	ImSatzAnz = count;			// = Anzahl der Datensätze	count = 1;	do {		c = ImGetByte();		if (c == '\"') {		// Feldanfang?			ImSkipBytes('\"',false);	// dann das Feld überspringen			c = ImGetByte();	// und das Folgezeichen holen		}		if (c == trenner) count++; // Feldtrenner zählen	} while((c != '\r')&&(c != 0));	ImFeldAnz = count;}void	ImBasicSetup(void){	ImListSetup(',');}void	ImSYLKSetup(void){	ImSkipBytes('\r',false);	// erste ID-Zeile überlesen	ImSkipBytes('Y',false);		// “B;Y” überspringen	ImSatzAnz = ImGetZahl();	// Anzahl der Datensätze	ImSkipBytes('X',false);		// “;X” überspringen	ImFeldAnz = ImGetZahl();	// Anzahl der Felder}void	ImTabSetup(void){long	count = 0;long	saveoffset = ImOffset;char	c;	do {		ImSkipBytes('\r',false);// Zeilen zählen…		count++;	} while(ImGetByte() != 0);	// bis zum Dateiende	ImOffset = saveoffset;	ImSatzAnz = count;			// = Anzahl der Datensätze	count = 0;	do {		c = ImGetByte();		if (c == '\t')			// Feldanfang?			count++;	} while((c != '\r')&&(c != 0));	ImFeldAnz = count + 1;}void	ImKommaSetup(void){	ImListSetup(',');}void	ImSerienSetup(void){	ImSkipBytes('\r',false);	// erste Zeile = Feldnameninfo => überlesen	ImListSetup(';');}/*** *	Getfeld-Funktionen für alle Formate ***/void	ImListGetfeld(short satz,short feld,USTR s,char trenner);void	ImListGetfeld(short satz,short feld,REG USTR s,REG char trenner){REG long	i;REG char	c;REG Boolean	anf;	for(i=1;i != satz; i++)		ImSkipBytes('\r',false);	// bis zum nächsten Datensatz skippen	for(i=1;i != feld; i++)		ImSkipBytes(trenner,true);	// bis zum Tab überspringen	anf = false;	i = 0;	do {		c = ImGetByte();			// weitere Zeichen holen		if (!c) return;				// Textende		if ((c == '\"')&&(i == 0))			anf = true;				// erstes Zeichen = Anführungszeichen		else {			if ((anf)&&(c == '\"')) break; // abschließende Anführungszeichen			*s++ = c;				// nein, Zeichen merken		}		i++;		if (i > ImMaxLen) break;	// Datensatz maximal!		if (c == '\r') break;		// Zeilenende		if (anf) continue;			// Anführungszeichen sind offen		if (c != trenner) continue;	// Sonst auch den Trenner beachten!		--s;						// Trenner wieder entfernen		break;	} while(1==1);	*s = 0;}void	ImBasicGetfeld(short satz,short feld,USTR s){	ImListGetfeld(satz,feld,s,',');}void	ImSYLKGetfeld(short satz,short feld,USTR s){long	i;char	c,d;	*s = 0;							// Datzensatzfeld löschen	ImSkipBytes('\r',false);		// Headerzeilen überspringen	do {		ImSkipBytes('\r',false);	// bis zum nächsten Datensatz skippen		ImSkipBytes('Y',false);		i = ImGetZahl();		if (ImGetAktByte() == 0) return;	// Dateiende	} while(i != satz);				// bis zum entsprechenden Datensatz skippen	do {		ImSkipBytes(';',false);		if (ImGetAktByte() == 'Y') return;		ImSkipBytes('X',false);		i = ImGetZahl();			// Feldindex holen		if (i == feld) break;		// Feld gefunden!		ImSkipBytes('\r',false);		if (ImGetAktByte() == 0) return;	// Dateiende	} while(i != feld);				// Feld gefunden?	ImSkipBytes('K',false);			// Feldinhalt suchen	i = 0;	c = ImGetByte();	if (!c) return;					// Dateiende!!!	if (c != '\"') {				// in Anführungszeichen eingefaßt?		*s++ = c; i++;				// nein, Zeichen merken		c = '\r';					// Abschlußzeichen = Return	}	do {		d = ImGetByte();		if (!d) return;				// Dateiende!!!		*s++ = d;		if (++i > ImMaxLen) break;	// maximale Länge erreicht!	} while(d != c);	*--s = 0;}void	ImTabGetfeld(short satz,short feld,USTR s){long	i;char	c;	for(i=1;i != satz; i++)		ImSkipBytes('\r',false);	// bis zum nächsten Datensatz skippen	for(i=1;i != feld; i++)		ImSkipBytes('\t',true);		// bis zum Tab überspringen	i = 0;	do {		c = ImGetByte();			// weitere Zeichen holen		if (!c) return;				// Textende		*s++ = (c == '\013')?'\t':	// Ctrl-K in Tab wandeln				(c == '\035')?'\t':	// Ctrl-] in Tab wandeln				c;					// nein, Zeichen merken		if (++i > ImMaxLen) break;	// maximale Länge erreicht	} while((c != '\t')&&(c != '\r'));	*--s = 0;}void	ImKommaGetfeld(short satz,short feld,USTR s){	ImListGetfeld(satz,feld,s,',');}void	ImSerienGetfeld(short satz,short feld,USTR s){	ImSkipBytes('\r',false);		// Headerzeilen überspringen	ImListGetfeld(satz,feld,s,';');}/*** *	Abtesten, ob ein best. Format vorliegt ***/Boolean	ImCheckList(Ptr p,long len,char trenner);Boolean	ImCheckList(Ptr p,long len,char trenner){REG short	cnt,anz;REG long	i = 0;REG Boolean	ignore;REG char	c;short		cnti;	if (len < 10) return(false);		// Datei zu kurz	cnti = -1;							// Feldanzahl nocht nicht ermittelt	for(anz=0;anz<10;anz++) {			// 10 gültige Datensätze suchen		cnt = 0;						// Zähler für Feldanzahl		if (i == len) break;		ignore = false;					// Anfügungszeichen geschlossen		while(((c = p[i++]) != '\r')&&(i < len)) {	// Zeilenende suchen			if (c == '\"')				ignore = !ignore;		// Anführungszeichen-Flag toggeln			else				if (!ignore) {					// außerhalb von Anführungszeichen?					if (c == trenner) cnt++; // Feldtrenner zählen					else {						if (c >= '@')		// Buchstabe?							return(false);	// ist außerhalb nicht erlaubt!					}				}		}		if (i >= len) break;			// Textende erreicht		if (ignore) return(false);		// Anführungszeichen noch offen?		if (cnti < 0)					// Feldanzahl noch unbekannt?			cnti = cnt;					// dann jetzt setzen		else {			if (cnti != cnt) return(false);	// Feldanzahl ungleich?		}		if (p[i] == '\n') i++;			// Linefeed ggf. auch überspringen	}									// wenn 10 Sätze gefunden => dann ok!	if (cnti < 0) return(false);		// Datensatz war zu lang!	return(true);						// paßt!}Boolean	ImBasicCheck(Ptr p,long len){	return(ImCheckList(p,len,','));}Boolean	ImSYLKCheck(Ptr p,long len){	if (len < 64) return(false);				// Datei zu kurz!	if (((*(long*)p) & 0xFFFFFF00)== 'ID;\0') return(true);	// “SYLK”	return(false);}Boolean	ImTabCheck(Ptr p,long len){short	cnt,anz,cnti;long	i = 0;long	j;	if (len < 10) return(false);	// Datei zu kurz	cnti = -1;	anz = 0;						// Anzahl der Datensätze	do {		cnt = 0;						// Zähler für Anführungszeichen		if (i == len) break;		j = i;							// Offset auf den Zeilenanfang merken		while((p[i] != '\r')&&(i < len)) {	// Zeilenende suchen			if (p[i] == '\t') cnt++;	// Tabs zählen			i++;		}		if (i == j) return(false);		// Leerzeilen sind nicht erlaubt		if (i >= len) break;			// Textende erreicht		if (cnti < 0)			cnti = cnt;					// Tab-Zähler initialisieren		else {			if (cnti != cnt) return(false);	// Kommaanzahl stimmte nicht!		}		i++;							// Return am Zeilenende überspringen		if (p[i] == '\n') i++;			// Linefeed ggf. auch überspringen	} while(anz++ < 1000);				// wenn 1000 Sätze gefunden => dann ok!	if (cnti < 0) return(false);		// Datensatz war zu lang!	if (!BTstQ(vqkey(),3))				// Option nicht gedrückt?		if (cnti == 0) return(false);	// kein Tab gefunden => kein Tab-Format	return(true);						// paßt!}Boolean	ImKommaCheck(Ptr p,long len){	return(ImBasicCheck(p,len));}Boolean	ImSerienCheck(Ptr p,long len){long	i = 0;	if (len < 30) return(false);		// Datei zu kurz	while((p[i] != '\r')&&(i < len))	// Headerzeile überlesen		i++;	i++;								// Return auch überspringen	if (p[i] == '\n') i++;				// Linefeed ggf. auch überspringen	if (i >= len) return(false);		// Headerzeile viel zu lang!	return(ImCheckList(&p[i],len-i,';'));	// der Rest liegt fast im Basic-Format vor}/*** *	ermitteln, welches Import-Format vorliegt ***/short	ImportFormat(Ptr p,long len){LONG	i;Boolean	flag = false;	for(i=0;i<len;i++) {				// nur Zeichen <= 32 vorhanden?		if (p[i] > ' ') flag = true;	// dann ist es ein illegales Format!		if (p[i] == 0) {			return(false);	// Nullbyte => Fehler		}	}	if (flag == false) return(false);	for(i=0;i<999;i++) {				// garantiert alle Formate durchgehen		if (!*ImS[i].check)	break;		// Listenende?		if ((*ImS[i].check)(p,len)) return(i+1);	// Format erkannt?	}	return(0);}/*** *	Filterfunktion für den Fileselektor ***/#define	MyBufSize	8192	// maximale Länge von EINEM DatensatzPtr		MyFilterBuf;pascal Boolean	myFilter(ParmBlkPtr p);pascal Boolean	myFilter(ParmBlkPtr p){OSErr			err;short			fileRefNum;long			count;Ptr				buf = MyFilterBuf;Boolean			flag = true;					// “nicht darstellen” = DefaultStr255			fileName;short			vRefNum;	if (p) {									// “Nichts” nicht darstellen…		vRefNum = p->volumeParam.ioVRefNum;		CopyPString(fileName,p->fileParam.ioNamePtr);		err = HOpen(vRefNum,LMGetCurDirStore(),fileName,fsRdPerm,&fileRefNum);		if (!err) {			err = GetEOF(fileRefNum,&count);			// Länge der Datei ermitteln			if (count > MyBufSize) count = MyBufSize;	// maximal den Buffer füllen			buf[count] = '\r';							// Return an den Buffer anhängen			buf[count+1] = 0;							// und noch ein Nullbyte			if (!err)				err = SetFPos(fileRefNum,fsFromStart,0L);	// Ptr auf den Dateianfang			if (!err)				err = FSRead(fileRefNum,&count,buf);	// und den Buffer füllen			FSClose(fileRefNum);			if (!err)				flag = !ImportFormat(buf,count);		// Format bekannt?		}	}	return(flag);}/*** *	Wird angesprungen, wenn Import im Menü angewählt wurde ***/ListHandle	MyListHandleS,MyListHandleD;short		MyAktTopCell;pascal Boolean	MyClick(void);pascal Boolean	MyClick(void){short	i = (*MyListHandleD)->visible.top;	if (MyAktTopCell != i)	// erste sichtbare Zelle		LScroll(0,i - MyAktTopCell,MyListHandleS);	MyAktTopCell = i;	return(true);}void	DoImport(void){StandardFileReply	reply;				// Reply-Record vom Fileselectorshort				button;				// angeklickter ButtonDialogPtr			d;					// Ptr auf die DialogboxOSErr				err;				// aktueller FehlercodeHandle				h;					// Handle auf die Import-Datenlong				ImportLen;			// Länge der Import-Dateilong				l;					// Anzahl der gelesenen Bytes der Import-Dateishort				ImportFRefNum;		// FileRefNum für den ImportOSType				saveType;			// geretteter DateitypBoolean				ret;				// true: User will importieren (File-Selector)short				format;				// das eingelesene Import-FormatStr63				num1,num2;			// temp. Nummern als Pascal-StringsListHandle			ls,ld;				// ListHandles im Dialogshort				AktSatz = 1;		// aktuell angezeigter Datensatz (anfangen mit Satz 1)long				tempSatz;			// temp.Variable für SatznummerWindPtr				w;					// Windowhandle vom obersten FensterHandle				xWindow;short				AktSelCell;			// aktuelle selektierte Zelle (-1 = keine)char				SwapArray[64];		// Zuordnungstabelle: Import -> internchar				SwapArray2[64];		// Zuordnungstabelle: Import -> internWORD				feldanz;			// Anzahl der zu importierenden Felder	if (!gDoc) return;					// kein Dokument offen 	w = gTopWindow;						// oberstes Window 	if (!w) return;						// keins offen…	xWindow = w->MoreMem;	ImData = (datasetH)NewHandle(sizeof(dataset));	CheckOSError(MemError());	if (!ImData) return;	if (XWIN->windowType == SCHEDULE) return;	if (XWIN->windowType == ANN1) return;	FillOut(XWIN->windowType,ImData);	// Feldnamen eintragen	saveType = gG.FileTypes[0]; gG.FileTypes[0] = 'TEXT';	// Textdatei-Filetype	gGetFileFilter = 0L;//	gGetFileFilter = myFilter;	MyFilterBuf = NewPtr(MyBufSize);	if (!CheckOSError(MemError())) return;	// Speicher reichte nicht!	ret = DisplayGetFile(&reply);		// Daten importieren? Nein!	gGetFileFilter = nil;	DisposPtr(MyFilterBuf);				// Buffer sofort wieder freigeben	gG.FileTypes[0] = saveType;	if (!ret) return;					// Daten importieren? Nein! => raus	err = FOpenDF(&reply.sfFile,fsRdPerm,&ImportFRefNum);	if (!CheckOSError(err)) return;				// ein Fehler?	err = GetEOF(ImportFRefNum,&ImportLen);	if (!err) {		h = NewHandle(ImportLen);		// Speicher allozieren für die Datei		err = MemError();		if (!err) {			HLock((Handle)h);			l = ImportLen;			err = FSRead(ImportFRefNum,&l,*h);	// gesamte Datei einlesen			if ((l != ImportLen)&&(err == noErr))				err = ioErr;			HUnlock((Handle)h);		}	}	FSClose(ImportFRefNum);				// Import-Datei schließen	if (!CheckOSError(err)) {			// ein Fehler?		if (h) DisposHandle((Handle)h);			// Speicher wieder freigeben		return;							// und raus	}	ImH = h;							// globale Handle auf die zu importierenden Daten	ImOffset = 0;						// vom Datenanfang an lesen	ImSize = ImportLen;					// Größe der Importdatei	format = ImportFormat(*ImH,ImportLen);	// Import-Format ermitteln	if (!format) {		DoDialog(dImportUnknown,1);		// Format unbekannt!		DisposHandle((Handle)h);		return;	}	ImSatzAnz = 0;						// erstmal 0 Datensätze	ImFeldAnz = 0;						// und 0 Felder pro Datensatz	ImOffset = 0;	(*ImS[format-1].setup)();			// Setup aufrufen	if ((ImFeldAnz == 0)||(ImSatzAnz == 0)) {		DoDialog(dImportUnknown,1);		// Format unbekannt!		DisposHandle((Handle)h);		return;	}	NumToString(ImSatzAnz,num2);		// Anzahl der Datensätze in einen Pascal-String	d = GetCenteredDialog(dImport,nil);	if(!d) {		DisposHandle((Handle)h);		return;							// kein Dialog	}	ls = NewList(d,5,false,false,128);	(*ls)->selFlags = lNoExtend|lUseSense|lExtendDrag;	// Flags für Mehrfachselektierung	MyListHandleS = ls;	{	short i; Str255 s; short j;		ImMaxLen = 100;		for(i=1;i<=ImFeldAnz;i++) {			ImOffset = 0L;			(*ImS[format-1].getfeld)(AktSatz,i,s);			j = AddListMgr((STR)s,ls);	// an die Liste anhängen			{ Cell c; c.h = 0; c.v = j;			LSetSelect(true,c,ls);		// Zelle selecten			}		}	}	LDoDraw(true,ls);	ld=NewList(d,6,false,true,0);		// Destination-Liste	(*ld)->selFlags = lOnlyOne;			// Flags für Einzelselektierung	MyListHandleD = ld;	{	short i,j; Cell c; unsigned char *s;		for(i=0;i<MAX_NAMES-1;i++) {			s = (*ImData)->text[i];			if (s[0] == END_OF_LIST) break;	// Ende der Liste//			if (BTstQ((*ImData)->visible,i)) {	// Zelle dargestellt?				AddListMgr(PtoCstr(s),ld);	// dann auch gleich in die Import-Liste//			}			SwapArray[i] = i;		}		for(;i<ImFeldAnz;i++) {			AddListMgr("",ld);		// entsprechend Leerzeilen anhängen			SwapArray[i] = -1;		}	}	(*ld)->lClickLoop = NewListClickLoopProc(MyClick);	LDoDraw(true,ld);	tempSatz = AktSatz + 1;	// String garanitiert setzen!	while (d) {		MyAktTopCell = (*ld)->visible.top;	// erste sichtbare Zelle		if (tempSatz != AktSatz) {			NumToString(AktSatz,num1); // Anzahl der Datensätze in einen Pascal-String			ParamText(reply.sfFile.name,AKTDOC.f.fss.name,num1,num2);			RedrawItem(d,12);			// Item mit der Datensatznummer neu zeichnen			tempSatz = AktSatz;		}		HiliteButton(d,10,(AktSatz == 1)?kCntlInactive:kCntlActive);		HiliteButton(d,11,(AktSatz == ImSatzAnz)?kCntlInactive:kCntlActive);		HiliteButton(d,1,(FindSelCell(ls) < 0)?kCntlInactive:kCntlActive);		OutlineDialogItem(d,1);					// Default-Button zeichnen		AktSelCell = FindSelCell(ld);		ModalDialog((ModalFilterProcPtr)OwnDialogFilter,&button);		if ((button==1)||(button==3)) break;	// Ok, Abbruch		switch(button) {		case 6:		if (AktSelCell < 0) break;	// es war vorher eh keine Zelle selektiert					button = FindSelCell(ld);	// neue Zelle					if (button < 0) break;		// kein Button					if (AktSelCell == button) break; // gleiche Zelle angeklickt					if ((gTheEvent.modifiers & optionKey) != optionKey) break;	// Option nicht gedrückt?					{					Str255	s1,s2; Cell c;		// temp. Variablen					short	i;					i = SwapArray[AktSelCell];	// Reihenfolge tauschen					SwapArray[AktSelCell] = SwapArray[button];					SwapArray[button] = i;					LDoDraw(false,ld);					c.v = button; c.h = 0;					i = 255;					// maximal 255 Bytes holen					LGetCell(&s1[1],&i,c,ld);	// Text aus der Zelle holen					s1[0] = i;					// echte Länge setzen					c.v = AktSelCell; c.h = 0;					i = 255;					// maximal 255 Bytes holen					LGetCell(&s2[1],&i,c,ld);	// Text aus der Zelle holen					s2[0] = i;					// echte Länge setzen					LSetCell(&s1[1],s1[0],c,ld);// Text in die Zelle setzen					c.v = button; c.h = 0;					LSetCell(&s2[1],s2[0],c,ld);// Text in die Zelle setzen					LDoDraw(true,ld);					{ GrafPtr savePort;					GetPort(&savePort);					SetPort((*ld)->port);					InvalRect(&(*ld)->rView);	// Liste updaten					SetPort(savePort);					}					}					break;		case 10:	if (AktSatz<=1) break;					AktSatz--;					break;		case 11:	if (AktSatz>=ImSatzAnz) break;					AktSatz++;					break;		}		if (tempSatz != AktSatz) {			// Liste updaten?			short i; Str255 s;			Cell	c;			for(i=1;i<=ImFeldAnz;i++) {				ImOffset = 0L;				(*ImS[format-1].getfeld)(AktSatz,i,s);				c.h = 0;				c.v = i - 1;				LSetCell(s,strlen((STR)s),c,ls);	// Item ändern			}		}		MyClick();						// 1. Liste ggf. scrollen	}	{ short i,j; Cell c;		for(i=0;i<63;i++) {				// deselected-Zellen rausstreichen			c.h = 0; c.v = i;			if (!LGetSelect(false,&c,ls))				SwapArray[i] = -1;		// nicht übertragen		}		for(i=0;i<63;i++) {			SwapArray2[i] = -1;			for (j=0;j<63;j++) {				if (i == SwapArray[j])					SwapArray2[i] = j;			}		}		for(i=63;i>=0;i--)				// maximalen Feldindex ermitteln			if (SwapArray2[i]>=0) break;		feldanz = i;	}	DisposeObjects(d);	DisposeDialog(d);					// Dialogbox schließen	if (button == 1) {					// Importieren		LONG		i;		WORD		j;		UCHAR		str[2010];		WORD		typ = XWIN->windowType;		DialogPtr	d;		Boolean		abort = false;		d = GetCenteredDialog(168,nil);		if (d) {			SetUserItem(d,2,mWindowDraw);			mWmax = ImSatzAnz; mWakt = 0;			DrawDialog(d);		}		biene();		DeselectAllEntries(typ);		// alle Datensätze deselektieren		ImMaxLen = 2000;		for(i=0;i<ImSatzAnz;i++) {		// für alle Datensätze			ListH	l = (ListH)NewHandleClear(sizeof(List));			LONG	len,offset;			if (!l) break;			HLock((Handle)l);			(*l)->type = typ;			// Typ			(*l)->b.selected = true;	// Datensatz selektieren			for(j=0;j<feldanz;j++) {	// für alle Felder				str[0] = 0;				// String leeren				if (SwapArray2[j]>=0) {	// Feld einlesen?					ImOffset = 0L;					(*ImS[format-1].getfeld)(i+1,SwapArray2[j]+1,str);	// Feldinhalt holen				}				strcat((STR)str,"\r");				len = strlen((STR)str);	// Feldlänge				HUnlock((Handle)l);				offset = GetHandleSize((Handle)l);				SetHandleSize((Handle)l,offset + len);	// Struktur um die Feldlänge vergrößern				if (MemError())	break;				HLock((Handle)l);				strcat((STR)&(*l)->d,(STR)str);	// Feld anhängen			}			if (MemError()) {				DisposHandle((Handle)l);				break;			}			HUnlock((Handle)l);			{ REG WORD code; REG WORD org = (*GetOrgH(gDoc))->type;				FixListEntry(l);				if (code = CheckData(l,org)) {		// Fehler?					code = CorrectEntry(l,org,code);				}				if (code != CHKKill) {				// Datensatz verwerfen? => nicht eintragen					if (typ == MEMO)						AppendToList(GetOrgH(gDoc),typ,l);	// an die Liste anhängen					else						SortToList(GetOrgH(gDoc),typ,l);	// in Tel-Liste einsortieren				}			}			if (UserAbort()) {				abort = true;				break;								// Abbruch mit Command-.?			}			if (d) mWindowUpdate(mWakt + 1);		}		if (d) {			mWindowUpdate(mWmax);			DisposDialog(d);		}		if (abort)			DoDialog(169,-1);			// Meldung machen…		DoMultiRedraw(typ,redrawAndRecalc,nil);		AppDocumentDirty(gDoc,true);	// Dokument ist “dirty”		pfeil();	}	DisposHandle((Handle)h);					// Import-Daten verwerfen}