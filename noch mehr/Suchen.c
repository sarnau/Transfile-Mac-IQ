#include "AktDocStruct.h"#include "GlobalLib.h"#include "GeosMore.h"#include "Sharp.h"#include "Geos.h"#include "Float.h"#include "Memo.h"#include "Suchen.h"#include "IQSharpSenden.h"#include "List.h"#include "DialogLib.h"#include "xRsrcDefines.h"#include <String.h>#include "CheckList.h"Boolean	IgnoreBig = false;		// Groß- Kleinschreibung ignorierenCHAR	SuchBegriff[512];CHAR	ErsetzBegriff[512];/*** *	Sonstiges Menü auswerten ***/VOID	SonstigesMenu(UWORD entry){	switch(entry) {	case mmSuchen:	Suchen(dSuchen);					break;	case mmErsetzen:Suchen(dErsetzen);					break;	case mmDubletten:					Dubletten();					break;	case mmStatistik:Statistik();					break;	}}/*** *	Daten suchen ***/VOID	Suchen(short id){OSErr			err;DialogPtr		d;						// Ptr auf diverse Dialogeshort			button;					// Exit-ButtonListHandle		l;						// für die Auswahllistenchar			index[MaxIQFileType];	// Übersetzungstabelle: ListIndex => IQIndexWindPtr			w;IQFileType		PrefType = -1;			// bevorzugte Typenstatic short	SuchSprache = false;short			SuchGruppe = 1;			// alle Gruppen durchsuchen	if (!gDoc) return;						// kein Dokument offen	w = gTopWindow;	if (!w) return;							// kein Window offen	if (w)		PrefType = (*(xWindStruct**)w->MoreMem)->windowType;	d = GetCenteredDialog(id,nil);	if (!d) return;							// Dialog nicht zu öffnen	if (gAppTrue) {		HideDItem(d,11);		HiliteButton(d,11,kCntlInactive);	// disablen	} else {		ShowDItem(d,11);		HiliteButton(d,11,kCntlActive);		// enablen	}	SetDialogText(d,4,(USTR)SuchBegriff);	SelIText(d,4,0,32767);					// String komplett selektieren	if (id == dErsetzen) {					// Ersetzen-Dialog?		SetDialogText(d,14,(USTR)ErsetzBegriff);	}	l=NewList(d,6,false,true,0);	(*l)->selFlags = lNoExtend|lUseSense|lExtendDrag;	// Flags für Mehrfachselektierung	{	short i,j; Str255 s; Cell c; LONG num;		for(i=0;i<MaxIQFileType-1;i++) index[i] = 0;		for(i=0;i<MaxIQFileType-1;i++) {			GetIndString(s,sSharpNames+1,i+1);			if (s[0]==0) break;					// Ende der Liste			j = s[0]; s[0] = 2;			StringToNum(s,&num);				// Zahl am Stringanfang ermitteln			if (!IQIsAvailable(GetOrgH(gDoc),num)) continue;			if (num == OUTLINE) {				// wie werden Outlines durchsucht?							} else {				s[0] = j;				j = AddListMgr(PtoCstr(s)+2,l);	// an die Liste anhängen				index[num-1] = j;				// Index merken				c.h = 0; c.v = j;				if ((PrefType == num)||					(((num == TEL2DATA)||(num == TEL3DATA))&&(PrefType == TEL1DATA))||					(((num == SCHEDULE)||(num == ANN1)||(num == ANN2)||(num == PERIOD))&&((PrefType == ANN1)||(PrefType == SCHEDULE)))||					((num == BUSINESS)&&(PrefType == BUSINESS)))					LSetSelect(true,c,l);		// Zelle selecten				else					LSetSelect(false,c,l);		// Zelle deselecten			}		}	}	LAutoScroll(l);	LDoDraw(true,l);	NewPopup(d,7,157,13,SuchGruppe);			// zu suchende Gruppe	gTEMaxLen = 120;	while (d) {		SetButton(d,5,IgnoreBig==true);		SetButton(d,11,SuchSprache==true);		// keine direkte Eingabe der Suchsprache		if (SuchSprache) {			HiliteButton(d,5,kCntlInactive);	// Disablen//			HiliteButton(d,7,kCntlInactive);		} else {			HiliteButton(d,5,kCntlActive);		// Enablen//			HiliteButton(d,7,kCntlActive);		}		{ Str255	temp;			GetIText((Handle)GetCH(d,4),temp);			if ((FindSelCell(l)<0)||!temp[0]) {		// Im Bereich was selektiert				HiliteButton(d,1,kCntlInactive);	// Suchen/Ersetzen disablen			} else {				HiliteButton(d,1,kCntlActive);		// Suchen/Ersetzen enablen			}		}		OutlineDialogItem(d,1);					// Default-Button zeichnen		ModalDialog((ModalFilterProcPtr)OwnTELenFilter,&button);		if ((button==1)||(button==3)) break;		switch(button) {		case 5:	IgnoreBig ^= 1;			// Groß- Kleinschreibung ignorieren				break;		case 11:SuchSprache ^= 1;		// Suchsprache setzen				break;		}	}	SuchGruppe = GetPopupValue(d,7);	if (button == 1) {					// “Suchen” angeklickt		short	i; Cell c; Boolean flag = false;		GetDialogText(d,4,(USTR)SuchBegriff);		if (id == dErsetzen) {				// Ersetzen-Dialog?			GetDialogText(d,14,(USTR)ErsetzBegriff);		}		for(i=0;i<MaxIQFileType-1;i++) {			c.h = 0; c.v = index[i];	// ausgewählte Zellen merken			index[i] = LGetSelect(false,&c,l);			if (index[i])				flag = true;		}		if (!flag) button = 3;			// nix selektiert => raus	}	DisposeObjects(d);	DisposeDialog(d);	if (button == 1) {					// “Suchen” angeklickt		short	i;		char	s[1024];		if (SuchSprache) {				// Suchsprache direkt eingegeben?			vStrcpy(s,SuchBegriff);		// Ja!		} else {			vStrcpy(s,"c01=1");			GetPopupCond(SuchGruppe,s);			if (*SuchBegriff) {			// Suchbegriff vorhanden?				strcat(s,"as");			// AND STRING				if (IgnoreBig)					strcat(s,"+");		// Groß/Kleinschreibung ignorieren				strcat(s,"|");				strcat(s,SuchBegriff);	// Suchbegriff übertragen				strcat(s,"|");				if (id == dErsetzen) {	// Ersetzen-Dialog?					strcat(s,">");					strcat(s,ErsetzBegriff);	// Suchbegriff übertragen					strcat(s,"<");				}			}		}		biene();		{		ULONG	redrawTypeMask = 0;		for(i=0;i<MaxIQFileType-1;i++) {			if (index[i]) {				SearchOList(GetOrgH(gDoc),i+1,s,i+1);				if (id == dErsetzen)	// Ersetzen-Dialog?					SortList(GetOrgH(gDoc),i+1);				redrawTypeMask |= 1L<<i;			}		}		DoBitFieldRedraw(redrawTypeMask);		}		pfeil();		if (!SuchSprache)			SetFloatDisp(flFound);		else			SetFloatDisp(flAll);		if (id == dErsetzen)			// Ersetzen-Dialog?			CheckDoc(gDoc);				// Daten abtesten	}}/*** *	Dubletten rausfiltern ***/short	EqualListStr(ListH entry,ListH h);short	EqualListStr(ListH entry,ListH h){STR		s1 = (STR)&(*entry)->d;STR		s2 = (STR)&(*h)->d;WORD	len1 = Strlen(s1);WORD	len2 = Strlen(s2);	// CRs am Stringende nicht mit in den Vergleich einbeziehen	while((*(s1 + len1 - 1) == '\r')&&(len1>0)) len1--;	while((*(s2 + len2 - 1) == '\r')&&(len2>0)) len2--;	if (len1 != len2) return(1);			// ungleiche Länge => ungleiche Strings	while(len1--) {		if (*s1++ != *s2++) return(1);	}	return(0);}VOID	Dubletten(VOID){short		i;REG ListH	*l;REG ListH	la,lb;Boolean		clr;short		count = 0;Str63		s;Boolean		flag = vqkey() & 1;				// Option gedrückt?ULONG		redrawTypeMask = 0;	biene();	for(i=1;i<MaxIQFileType;i++) {		l = GetListHA(GetOrgH(gDoc),i);		// Basisadresse der Liste		if (!l) continue;					// keine Datensätze vorhanden =>		clr = false;		lb = *l;		while (lb) {						// äußere Schleife			la = (*lb)->next;//			if ((*la)->type == MEMO) {			// Memos sind nicht sortiert				while (la) {					// innere Schleife					if ((!CompareListEntry(la,lb,i,EqualListStr))&&(la != lb)) {			// passenden Typ gefunden?						if (((*la)->type == (*lb)->type)||flag) {							DisposeFromList(l,la);	// dann das Element freigeben							clr = true;							count++;			// Anzahl der gelöschten Datensätze							la = (*lb)->next;	// und weitersuchen						} else {							la = (*la)->next;	// einfach nur zum Folgeelement						}					} else {						la = (*la)->next;		// einfach nur zum Folgeelement					}				}#if 0											// Klappt nicht bei Terminen, etc.			} else {				if (la) {					if ((!CompareListEntry(la,lb,i,EqualListStr))&&(la != lb)) {	// passenden Typ gefunden?						if (((*la)->type == (*lb)->type)||flag) {							DisposeFromList(l,la);	// dann das Element freigeben							clr = true;							count++;				// Anzahl der gelöschten Datensätze						}					}				}			}#endif			lb = (*lb)->next;				// zum Folgeelement		}		if (clr)							// es wurde war gelöscht…			redrawTypeMask |= 1L<<(i-1);	}	DoBitFieldRedraw(redrawTypeMask);	pfeil();	if (!count) {							// Datensätze gelöscht?		DoDialog(164,0);					// nix gelöscht	} else if (count == 1) {		AppDocumentDirty(gDoc,true);		// Dokument ist “dirty”		DoDialog(165,0);					// Erfolgsmeldung verkünden	} else {		NumToString(count,s);		ParamText(s,nil,nil,nil);		AppDocumentDirty(gDoc,true);		// Dokument ist “dirty”		DoDialog(163,0);					// Erfolgsmeldung verkünden	}}/*** *	Anzahl der Objekte in einer Liste ***/VOID	SetStatistikText(DialogPtr d,WORD object,WORD count,Boolean visible);VOID	SetStatistikText(DialogPtr d,WORD object,WORD count,Boolean visible){Str63	s;	if (visible) {		NumToString(count,s);	} else {		s[0] = 1; s[1] = '-';	}	SetIText((Handle)GetCH(d,object),s);}VOID	SetStatistikEntry(DialogPtr d,WORD item,Boolean visible,OrganizerH o,...);VOID	SetStatistikEntry(DialogPtr d,WORD item,Boolean visible,OrganizerH o,...){REG IQFileType	i;va_list			arg;	CLCount = 0;	va_start(arg,o);	while (i = va_arg(arg,WORD))		SearchOList(o,i,"c00=1");	va_end(arg);	SetStatistikText(d,item+1,CLCount,true);	CLCount = 0;	va_start(arg,o);	while (i = va_arg(arg,WORD))		SearchOList(o,i,"c00=v");	va_end(arg);	SetStatistikText(d,item+2,CLCount,visible);}/*** *	Statistik zum aktuellen Dokument anzeigen ***/VOID	Statistik(VOID){DialogPtr	d;short		button;OrganizerH	o;Handle		xWindow;WindPtr		w;REG WORD	typ;	if (!gDoc) return;				// kein Dokument offen 	w = gTopWindow;					// oberstes Window 	typ = UNKNOWNFILE; 	if (w) {						// keins offen…		xWindow = w->MoreMem;		typ = XWIN->windowType;		// Typ vom obersten Window	}	d = GetCenteredDialog(dStatistik,nil);	o = GetOrgH(gDoc);	biene();	SetStatistikEntry(d,10,(typ == SCHEDULE)||(typ == ANN1),o,SCHEDULE,ANN1,ANN2,PERIOD,DALARM,0);	SetStatistikEntry(d,13,typ == MEMO,o,MEMO,0);	SetStatistikEntry(d,16,typ == TEL1DATA,o,TEL1DATA,TEL2DATA,TEL3DATA,0);	SetStatistikEntry(d,19,typ == BUSINESS,o,BUSINESS,0);	SetStatistikEntry(d,22,typ == OUTLINE,o,OUTLINE,0);	SetStatistikEntry(d,25,typ == DOLIST,o,DOLIST,0);	SetStatistikEntry(d,28,typ == EXPENSE,o,EXPENSE,0);	SetStatistikEntry(d,31,typ == USERFILE1,o,USERFILE1,USERFILE2,USERFILE3,0);	SetStatistikEntry(d,34,typ == TODO,o,TODO,0);	SetStatistikEntry(d,37,typ == USERDIC,o,USERDIC,0);	pfeil();	OutlineDialogItem(d,1);				// Default-Button zeichnen	ShowWindow(d);	ModalDialog((ModalFilterProcPtr)OwnDialogFilter,&button);	DisposDialog(d);}