/*** *	Beta-Test-Dialog ausgeben ***/void	BetaDialog(void);#if !BETA#include "GlobalDefines.h"#include "DialogLib.h"#include "GlobalLib.h"#include "Utilities.h"#include "MySound.h"#include <FixMath.h>/*** *	einige Funktionen fŸr TrueType-Fonts ***/typedef enum boxTextOptions {	constrainH = 1,	constrainV = 2} boxTextOptions;#define kBoxOptions 		(constrainH | constrainV)void	GetTextBounds(char*,Point numer,Point denom,Rect*);void	GetTextRect(char*,Rect*);void	BoxText(char*, Rect*,boxTextOptions);void	GetTextBounds(char* text,Point numer,Point denom,REG Rect* bounds){FontInfo	info;REG Fixed	hScale = FixDiv(numer.h,denom.h);REG Fixed	vScale = FixDiv(numer.v,denom.v);	GetFontInfo(&info);	SetRect(bounds,0,FixMul(-info.ascent,vScale),FixMul(StringWidth((USTR)text),hScale),FixMul(info.descent+info.leading,vScale));	OffsetRect(bounds,qd.thePort->pnLoc.h,qd.thePort->pnLoc.v);}void	GetTextRect(char* text,Rect* bounds){Point		identity;	SetPt(&identity,1,1);	GetTextBounds(text,identity,identity,bounds);}void	BoxText(REG char* myPString,Rect *dst,boxTextOptions options){Point		numer,denom;REG short 	txSize;Rect		src;	if (!options || options & ~(constrainH|constrainV)) {		DrawString((USTR)myPString);		return;	}	txSize = qd.thePort->txSize;	TextSize(100);					// pick a big size so our source metrics are precise	MoveTo(0,0);	GetTextRect(myPString,&src);	switch (options) {		case constrainH:			numer.h = numer.v = dst->right - dst->left;			denom.h = denom.v = src.right - src.left;			break;		case constrainV:			numer.h = numer.v = dst->bottom - dst->top;			denom.h = denom.v = src.bottom - src.top;			break;		case (constrainH | constrainV):			SetPt(&numer,dst->right - dst->left, dst->bottom - dst->top);			SetPt(&denom,src.right - src.left, src.bottom - src.top);			break;	}	if (denom.h && denom.v) {		short baseline = FixMul(-src.top,FixDiv(numer.v,denom.v));		MoveTo(dst->left,dst->top + baseline);		StdText(*myPString,myPString+1,numer,denom);	}	TextSize(txSize);}/*** *	Offscreen-Bitmap erzeugen/freigeben ***/GrafPtr		InitOffscreen(Rect *r);void		KillOffscreen(GrafPtr n);void		DrawStringAntialiased(Str255 s,Rect *r);GrafPtr		InitOffscreen(REG Rect *r){GrafPtr		savePort;REG GrafPtr	n;REG long	l;	GetPort(&savePort);	OffsetRect(r,-r->left,-r->top);			// links oben nach (0,0) verschieben	n = (GrafPtr)NewPtr(sizeof(GrafPort));	if (n == NULL) return(NULL);			// Speicher reichte nicht!	OpenPort(n);	n->portRect = *r;	n->portBits.bounds = *r;	l = ((r->right + 31) / 32) * 4;	n->portBits.rowBytes = l;	n->portBits.baseAddr = NewPtr(l * r->bottom);	if (n->portBits.baseAddr == NULL) {		SetPort(savePort);		ClosePort(n);		DisposPtr((Ptr)n);		return(NULL);						// Speicher fŸr Bitmap reichte nicht!	}	(*n->visRgn)->rgnSize = 10;	(*n->visRgn)->rgnBBox = *r;	EraseRect(&n->portRect);	SetPort(savePort);	return(n);}void		KillOffscreen(REG GrafPtr n){	DisposPtr(n->portBits.baseAddr);	ClosePort(n);	DisposPtr((Ptr)n);}void		DrawStringAntialiased(REG Str255 s,REG Rect *r){Rect		rctOff,rct;REG GrafPtr	op;GrafPtr		oldPort;REG short	oldTSize,ix,iy,mode;FontInfo	fi;#define ShrinkFaktor	4		// 4x4 Pixel = 16 Graustufen!	GetPort(&oldPort);	GetFontInfo(&fi);	ix = oldPort->pnLoc.h;	iy = oldPort->pnLoc.v;	oldTSize = qd.thePort->txSize;	TextSize(oldTSize * ShrinkFaktor);	GetFontInfo(&fi);	SetRect(&rctOff,0,0,StringWidth(s),fi.ascent + fi.descent);	if (!(op = InitOffscreen(&rctOff))) {	// Offscreen-Bitmap allozieren		SetPort(oldPort);					// reichte der Platz nicht?		TextSize(oldTSize);		GetFontInfo(&fi);		Move(0,fi.ascent);		DrawString(s);						// String normal ausgeben		return;	}	SetPort(op);	TextFont(oldPort->txFont);	TextFace(oldPort->txFace);	TextSize(oldTSize * ShrinkFaktor);	MoveTo(0,fi.ascent);//	DrawString(s);							// String in die Offscreen-Bitmap ausgeben	BoxText((char*)s,&rctOff,kBoxOptions);	SetPort(oldPort);	TextSize(oldTSize);	GetFontInfo(&fi);//	SetRect(&rct,0,0,StringWidth(s),fi.ascent + fi.descent);//	OffsetRect(&rct,ix,iy);	rct = *r;	mode = ditherCopy;	if (oldPort->txMode <= notSrcBic)		mode += oldPort->txMode;	CopyBits(&op->portBits,&oldPort->portBits,&rctOff,&rct,mode,NULL);	KillOffscreen(op);}/*** *	Beta-Test Dialog anzeigen ***/void	BetaDialog(void){REG DialogPtr		d;REG StringHandle	s;ULONG				date;DateTimeRec			dateTime;	s = GetString(-16096);				// Usernamen ermitteln	if (s) {		HLockH((Handle)s);		ParamText(*s,NULL,NULL,NULL);	// String in den Dialog eintragen	} else		ParamText(NULL,NULL,NULL,NULL);	d = GetCenteredDialog(9999,NULL);	if (d) {							// Dialog vorhanden?		WORD t; Handle h; Rect r; WORD fid;		WORD		font,size;		FontInfo	f;		GrafPtr		savePort;		GetDItem(d,4,&t,&h,&r);		GetFNum("\pSymbol",&fid);		if (!fid) fid = applFont;		// Symbol-Font vorhanden?		GetPort(&savePort);		SetPort((GrafPtr)d);		font = d->txFont; TextFont(fid);		size = d->txSize; TextSize(100);		{	GDHandle	g;			Boolean		flag = false;			Str255		version;			Handle		hndl;			hndl=GetResource('vers',1);	// Versions-Stage aus vers-Resource			if(hndl)				switch((*(VersRec**)hndl)->numericVersion.stage) {				case developStage:					version[1]='d';					break;				case alphaStage:					version[1]='a';					break;				default:					version[1]='b';				}			else				version[1]='b';			version[0]=1;				// LŠnge (Pascal String)			if(gQDVersion) {					// Color Quickdraw vorhanden? 				g = GetMainDevice();			// aktuellen Screen holen				if ((*(*g)->gdPMap)->pixelSize >= 4) { // nur 16 Farben sehen gut aus!					MoveTo(r.left,r.top + r.bottom - (r.top + r.bottom)/2);					DrawStringAntialiased(version,&r);					flag = true;		 		}			}			if (!flag)				BoxText((char*)version,&r,kBoxOptions);		}		TextFont(font); TextSize(size);		SetPort(savePort);		BeginUpdate(d);		UpdtDialog(d,d->visRgn);		EndUpdate(d);		HiliteButton(d,1,kCntlInactive);		OutlineDialogItem(d,1);		OwnBeep(about);		HiliteButton(d,1,kCntlActive);		OutlineDialogItem(d,1);		ModalDialog((ModalFilterProcPtr)OwnDialogFilter,&t);		DisposDialog(d);#if !GERD		GetDateTime(&date);					// Auf heutiges Datum setzen		Secs2Date(date,&dateTime);			// Jahr und Monat berechnen		if((dateTime.year>1997) /*|| (dateTime.month>4)*/) {			d = GetCenteredDialog(9997,NULL);			OwnBeep(negative);			ModalDialog((ModalFilterProcPtr)OwnDialogFilter,&t);			DisposDialog(d);			ExitToShell();					// letzter Befehl: Programm verlassen 		}#endif	}	if (s)		HUnlock((Handle)s);}#elsevoid		BetaDialog(void){}#endif