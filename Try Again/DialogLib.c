/*** *	Library für Dialoge ***/#include "DialogLib.h"#include "GeosMore.h"#include "GlobalLib.h"#include "GlobalStruct.h"#include "Utilities.h"#include "WindowsGlobal.h"#include "Windows.h"#include "rsrcDefines.h"#include "DoEvent.h"#include <FixMath.h>#include <packages.h>#include "MySound.h"WindowPtr		gBehind;		// Dialog VOR oder HINTER den Windows öffnen/*** *	aktuelle Fonteinstellungen retten bzw setzen ***/// ein Default-Font: System-Font, OR-Copymode, Default-Größe, kein spezieller StilFontStruct	fDefault = { 0,srcOr,0,0 };VOID			SaveText(REG FontStruct *f){REG GrafPtr		port = qd.thePort;	f->txFont = port->txFont;	f->txMode = port->txMode;	f->txSize = port->txSize;	f->txFace = port->txFace;}VOID			RestoreText(REG FontStruct *f){	TextFont(f->txFont);	TextMode(f->txMode);	TextSize(f->txSize);	TextFace(f->txFace);}/*** *	Item-Redraw melden ***/VOID			RedrawItem(REG DialogPtr d,WORD item){WORD		type;Rect		r;Handle		c;GrafPtr		savePort;Str255		s;RgnHandle	rgn;	GetPort(&savePort);	SetPort(d);	rgn = NewRgn();	GetDItem(d,item,&type,&c,&r);	// Daten vom Item holen	InvalRect(&r);					// und Update…	RectRgn(rgn,&r);	GetClip(rgn);					// Clipping retten	ClipRect(&r);					// und nur auf das Objekt clippen	DrawDialog(d);					// und zeichnen	SetClip(rgn);	DisposeRgn(rgn);	SetPort(savePort);}/*** *	String in einem Textfeld setzen ***/VOID			SetDialogText(DialogPtr d,WORD item,USTR s){	CtoPstr((STR)s);				// in einem Pascal-String wandeln	SetIText((Handle)GetCH(d,item),s);		// Text setzen	PtoCstr(s);						// und wieder zurückwandeln}/*** *	String aus einem Textfeld holen ***/VOID			GetDialogText(DialogPtr d,WORD item,USTR s){	GetIText((Handle)GetCH(d,item),s);		// Text holen	PtoCstr(s);						// und wieder zurückwandeln}/*** *	Routine für ein UserItem setzen ***/VOID			SetUserItem(REG DialogPtr d,REG WORD item,void *routine){WORD	type;Rect	r;Handle	c;	GetDItem(d,item,&type,&c,&r);			// Daten vom UserItem holen	if ((type & ~itemDisable) == userItem)	// auch wirklich ein Useritem?		SetDItem(d,item,(type & itemDisable) + userItem,(Handle)routine,&r);}/*** *	Radio-Button aus einer Gruppe drücken, selektierten deselektieren ***/VOID			PushRadioButton(REG DialogPtr d,WORD item,REG WORD first,WORD last){	for(;first<=last;first++) {		if (first != item)			SetButton(d,first,0);		// alle Buttons deselektieren	}	SetButton(d,item,1);				// und den neuen selektieren}/*** *	Checkbox toggeln ***/VOID			ToggleButton(DialogPtr d,WORD item){	SetButton(d,item,GetButton(d,item)?0:1);}/*** *	Button hiliten ***/VOID			HiliteButton(DialogPtr d,WORD item,WORD flag){	HiliteControl(GetCH(d,item),flag);}/*** *	Button setzen ***/VOID			SetButton(REG DialogPtr d,REG WORD item,WORD flag){	if (GetButton(d,item) != flag)			// Wert geändert?		SetCtlValue(GetCH(d,item),flag);	// dann neu setzen}/*** *	Button holen ***/WORD			GetButton(DialogPtr d,WORD item){	return(GetCtlValue(GetCH(d,item)));}/*** *	Integerzahl in einem Objekt setzen ***/VOID			SetInteger(DialogPtr d,WORD object,WORD count){Str63		s;	NumToString(count,(USTR)s);	SetIText((Handle)GetCH(d,object),(USTR)s);}/*** *	Integerzahl aus einem Objekt holen ***/WORD			GetInteger(DialogPtr d,WORD object){Str63		s;LONG		count;	GetIText((Handle)GetCH(d,object),s);	StringToNum(s,&count);	return(count);}/*** *	ControlHandle eines Items in einer Dialogbox ermitteln ***/ControlHandle	GetCH(DialogPtr d,WORD item){Rect	r;WORD	type;Handle	h;	GetDItem(d,item,&type,&h,&r);	return((ControlHandle)h);}/*** *	Diese Routine zeichnet einen “Default”-Rahmen um ein Control. Bei inaktiven *	Controls wird der Rahmen in hell dargestellt. * *	Der Radius des Default-Rahmens ist im Gegensatz zu IM I-407 NICHT 16,16, *	sondern wird aus der halben Höhe des Buttons errechnet; dies sieht auch bei *	größeren Buttons noch gut aus. * *	ACHTUNG: Der GrafPort wird auf das Control-Window umgeschaltet. ***/VOID			OutlineControl(REG ControlHandle button){Rect			theRect;PenState		curPen;REG WORD		buttonOval;GrafPtr			savePort;AuxCtlHandle	auxCtlHndl = nil;RGBColor		newRGB;RGBColor		oldRGB;	if (!button) return;	GetPort(&savePort);	SetPort((*button)->contrlOwner);	GetPenState(&curPen);	if (gQDVersion) {		if (!GetAuxCtl(button,&auxCtlHndl))			GetAuxCtl(0,&auxCtlHndl);		newRGB = (*(*auxCtlHndl)->acCTable)->ctTable[cFrameColor].rgb;		GetForeColor(&oldRGB);		RGBForeColor(&newRGB);	}	PenNormal();	theRect = (*button)->contrlRect;	InsetRect(&theRect,kButtonFrameInset,kButtonFrameInset);	buttonOval = (theRect.bottom-theRect.top)/2+2;	PenPat(((*button)->contrlHilite==kCntlActive)?&qd.black:&qd.gray);	PenSize(kButtonFrameSize,kButtonFrameSize);	FrameRoundRect(&theRect,buttonOval,buttonOval);	SetPenState(&curPen);	if (gQDVersion) {		RGBForeColor(&oldRGB);	}	SetPort(savePort);}/*** *	“Default”-Rahmen um ein Objekt in einem Dialog zeichnen ***/VOID			OutlineDialogItem(DialogPtr d,WORD item){	OutlineControl(GetCH(d,item));}/*** *	Control kurz selektieren. Sehr praktisch, wenn der User z.B. RETURN drückt um *	ein optisches “Feedback” zu erzeugen. ***/VOID			SelectControl(REG ControlHandle button){	HiliteControl(button,kSelect);	Pause(kDelayTime);	HiliteControl(button,kDeselect);}/*** *	Alert mit Id “id” darstellen. ***/WORD			DoAlert(WORD id){Str255		s;	GetIndString(s,STRcommon,id);	return(alert(1,PtoCstr(s)));}/*** *	Dialogbox ausführen. * *	angeklickter Button = DoDialog(Dialogbox-ID,“sicherer” Button) * *	Dialogbox-ID		= ID der 'DLOG'-Resource *	“sicherer” Button	= Button, falls 'DLOG'-Resource nicht gefunden ***/WORD			DoDialog(WORD dlog,WORD savebut){REG DialogPtr	d;WORD			item;	d = GetCenteredDialog(dlog,nil);	if (d) {					// Dialog vorhanden?		pfeil();		OutlineDialogItem(d,1);		ModalDialog((ModalFilterProcPtr)OwnDialogFilter,&item);		DisposDialog(d);	} else		item = savebut;			// sicher ist sicher: speichern	return(item);}////	eigener Dialogfilter für Längenbegrenzung von TextEdit-Feldern//pascal Boolean	OwnTELenFilter(DialogPtr d,REG EventRecord *event,WORD *item){REG TEHandle	t = ((DialogPeek)d)->textH;		// Handle auf aktuelles TextEdit-FeldREG WORD		key;	while (0==0) {		if ((event->what != keyDown)&&(event->what != autoKey)) break;		if ((event->modifiers & cmdKey)&&			((event->message & charCodeMask) == 'v')) {	// Paste?			if (((*t)->teLength + TEGetScrapLen()				- ((*t)->selEnd - (*t)->selStart)) <= gTEMaxLen) break;			SysBeep(1);			event->what = nullEvent;			return(false);						// Tastencode ignorieren		}		if ((*t)->teLength < gTEMaxLen) break;	// Text evtl. zu lang?		if ((event->modifiers & cmdKey)) break;	// Command gedrückt?		if ((*t)->selStart != (*t)->selEnd) break;	// Bereich selektiert?		key = event->message & charCodeMask;		if (key < 32) break;					// Cursortaste o.ä.?		SysBeep(1);		event->what = nullEvent;		return(false);						// Tastencode ignorieren	}	return(OwnDialogFilter(d,event,item));	// allgemeinen Dialoghandler aufrufen}/*** *	Ändert den Mauszeiger auf TextEdit-Zeiger, wenn er auf dem aktuellen TextEdit- *	Feld steht und auf einen Pfeil, wenn nicht ***/static VOID	IBeamIt(REG WindowPtr dwind);VOID	IBeamIt(REG WindowPtr dwind){Point		mouseAt;WORD		itemtype;Handle		itemhandle;Rect		r;REG WORD	item;	item = ((DialogPeek)dwind)->editField + 1;	if (!item) return;	GetDItem(dwind,item,&itemtype,&itemhandle,&r);	GetMouse(&mouseAt);	if (PtInRect(mouseAt,&r)) {		// Pfeil im TextEdit-Rechteck?		textmaus();	} else {		pfeil();	}}// This code expects the key equivalents to be in item #2, which is a StatText// item that is located so the text is outside of the dialog.  This allows us// to put key equivalent information in the resource fork, so the key// equivalents are localizable.pascal Boolean	OwnDialogFilter(DialogPtr d,EventRecord *event, WORD *item){WORD		itemType;Handle		itemHndl;Rect		itemRect;Str255		itemText;WORD		i,equivChr,modMask,modVal;unsigned char keyCode;WORD		itemNum,theChr,theMod;LONG		tick;Point		where = event->where;WindowPtr	w;GrafPtr		savePort;Boolean		flag = false;LONG		m = event->message;WORD		what;	gTheEvent = *event;				// aktuellen Event merken	GetPort(&savePort);	SetPort((WindowPtr)d);	IBeamIt((WindowPtr)d);			// Cursor auf Textform, wenn über TextEdit	switch(event->what) {	case updateEvt:			if (d == (DialogPtr)m) {				OutlineDialogItem(d,1);			} else {				WUpdate((WindPtr)m);			}			break;	case mouseDown:			what = FindWindow(where,&w);			if (w != d) {					// Window = der Dialog?				SysBeep(10);				// Nein! => Pieeep				break;			}			if (what == inDrag) {				DragWindow(w,where,&gDesktopRect);				event->what = nullEvent;				break;			}			{				WORD type; Handle h; Rect r;				REG OwnObjectH	l = (OwnObjectH)((WindPtr)d)->DialogRefcon;				GlobalToLocal(&where);				while(l) {					// alle List-Items durchgehen					GetHandleSize((Handle)l);		// ist l wirklich eine Handle?					if(MemError()) {		// Nein => Fehler!						OwnBeep(shit);						break;					}					GetDItem(d,(*l)->item,&type,&h,&r);					if (PtInRect(where,&r) && (*l)->klick) {// Mausklick ins Item?						flag = (*(*l)->klick)((VOID*)l,d,where,event->modifiers,item);						break;					}					l = (*l)->next;							// zum nächsten Item				}			}			break;	case keyDown:			itemNum = 0;					theChr = m & charCodeMask;			theMod = event->modifiers & keyCodeMask;					GetDItem(d,2,&itemType,&itemHndl,&itemRect);			GetIText(itemHndl,itemText);			keyCode = theChr;			UppercaseText((char*)&keyCode,1,smSystemScript);		// Taste in Großbuchstaben wandeln			for(i=1;i<=*itemText;i+=9) {				equivChr = GetHexByte((char*)itemText+i);				modMask  = GetHexByte((char*)itemText+i+2)<<8; // 1 = Command, 8 = Option, 16 = Control				modVal   = GetHexByte((char*)itemText+i+4)<<8;				itemNum  = GetHexByte((char*)itemText+i+6);				if ((theMod & modMask) == modVal)					if (keyCode == (unsigned char)equivChr) break;				itemNum = 0;			}			if (!itemNum && ((theChr == 0x0D) || (theChr == 0x03))) {				if (!(theMod & (cmdKey + optionKey + controlKey))) {					itemNum = 1;				// Return oder Enter				}			}			if (!itemNum) break;				// kein Item? => raus			if ((*GetCH(d,itemNum))->contrlHilite == kCntlActive) {				SelectControl(GetCH(d,itemNum));				*item = itemNum;				flag = true;				pfeil();			}			break;	case	kOSEvent:			switch((m>>24) & 0xFF) {			case	kSuspendResumeMessage:					gInBackground = !(m & kResumeMask);					{ G(SuspendResume)(gInBackground); }					if (gInBackground) {						ForAllWindows(HideFloats,nil,0);						gLastCursor = gCurrentCursor;						pfeil();					} else {						DoSetCursor(gLastCursor);						ForAllWindows(Show2Floats,nil,0);	// Floats anschalten					}					WActivate(gTopWindow,!gInBackground);			}	}	SetPort(savePort);	return(flag);}// Given a dialog ID and a window pointer the dialog relates to, this function// will center the dialog’s rectangle before showing it on the proper screen.// This follows the Apple Human Interface Guidelines for where to place a// centered window on the screen.  If the dialog is not closely associated with// another window, pass a nil for the window pointer of the related window.  If// you pass a nil, the dialog is simply displayed where the resource// would indicate.DialogPtr		GetCenteredDialog(WORD id,REG DialogPtr storage){REG DialogPtr	d;REG Boolean		flag = false;	if (storage == nil) {		storage = (DialogPtr)NewPtrClear(sizeof(WindStruct));		CheckAllocation(storage);		((WindPtr)storage)->DialogRefcon = 0L;		((WindPtr)storage)->magic = WINDMAGIC;		((WindPtr)storage)->Typ = (1L<<noHSlider)|(1L<<noVSlider)|									(1L<<noSizer)|(1L<<DialogWindow)|									(1L<<TrueDialog)|(1L<<NoParent);		flag = true;	}	PositionDialog('DLOG',id);	d = GetNewDialog(id,storage,gBehind);	if (flag) SelectWindow(d);	return(d);}/*** *	PositionDialog * *	Center the bounding box of a dialog or alert in the upper third *	of the screen.  This is the preferred location according to the *	Human Interface Guidelines. ***/VOID			PositionDialog(ResType theType,WORD theID){REG Handle	theTemplate;	// Handle to resource template	theTemplate = GetResource(theType,theID);	// DLOG/ALRT-Resource einlesen	CheckResource(theTemplate);					// gefunden?	HLock(theTemplate);	PositionRectInRect(gScreenRect,(Rect*)*theTemplate,FixRatio(1,2),FixRatio(1,3));	HUnlock(theTemplate);}/*** *	FindDlogPosition * *	Return the coordinates of the top left corner of a dialog or alert *	which centers the box in the upper third of the main screen. This is *	the preferred location according to the Human Interface Guidelines. ***/VOID			FindDlogPosition(ResType theType,WORD theID,REG Point *corner){Rect	theRect;	// Bounding box of dialog		theRect=**((Rect**)GetResource(theType,theID));	corner->h=(qd.screenBits.bounds.right-(theRect.right-theRect.left))/2;	corner->v=(qd.screenBits.bounds.bottom -(theRect.bottom-theRect.top))/3;}/*** *	Diese Funktion positoniert ein Rechteck in einem zweiten. Dabei wird das *	Rechteck gemäß horzRatio und vertRatio im zweiten positioniert. * *	Um z.B. das Rechteck im oberen Drittel zu zentrieren, gilt: *	horzRatio = FixRatio(1,2) *	vertRatio = FixRatio(1,3) * *	Die Benutzung der Fixed-Punkt-Zahlen hat den Vorteil, daß kein Float-Routinen *	benötigt werden! ***/VOID			PositionRectInRect(Rect outerRect,REG Rect *innerRect,Fixed horzRatio,Fixed vertRatio){REG WORD	outerRectHeight;REG WORD	outerRectWidth;REG WORD	innerRectHeight;REG WORD	innerRectWidth;REG WORD	yLocation;REG WORD	xLocation;	outerRectHeight = outerRect.bottom - outerRect.top;	outerRectWidth = outerRect.right - outerRect.left;	innerRectHeight = innerRect->bottom - innerRect->top;	innerRectWidth = innerRect->right - innerRect->left;	yLocation = Fix2Long(FixMul(Long2Fix(outerRectHeight - innerRectHeight), vertRatio))				+ outerRect.top;	xLocation = Fix2Long(FixMul(Long2Fix(outerRectWidth - innerRectWidth), horzRatio))				+ outerRect.left;	innerRect->top = yLocation;	innerRect->left = xLocation;	innerRect->bottom = yLocation + innerRectHeight;	innerRect->right = xLocation + innerRectWidth;}/***************************************************************** * Objektlisten Verwaltung für Dialogboxen *****************************************************************/OwnObjectH		NewObject(DialogPtr d,WORD item,WORD type,LONG refcon){OwnObjectH	l;OwnObjectP	lp;	l = (OwnObjectH)NewHandleClear(sizeof(OwnObjectStruct));	if (!l) DebugStr("\pOut of mem in NewObject");	SetUserItem(d,item,DrawObject);	lp = *l;	lp->next	= (OwnObjectH)((WindPtr)d)->DialogRefcon;	lp->type	= type;	lp->item	= item;	lp->refCon	= refcon;	((WindPtr)d)->DialogRefcon = (LONG)l;	return(l);}/*** *	Listenstruktur abmelden ***/VOID			DisposeObjects(DialogPtr d){REG OwnObjectH	l = (OwnObjectH)((WindPtr)d)->DialogRefcon;REG OwnObjectH	n;	while(l) {		GetHandleSize((Handle)l);		// ist l wirklich eine Handle?		if(MemError()) {		// Nein => Fehler!			OwnBeep(shit);			break;		}		n = (*l)->next;			// Folge-Objekt merken		if ((*l)->dispose)			(*(*l)->dispose)((VOID*)l);	// Object freigeben		DisposeHandle((Handle)l);		// aktuelles Objekt freigeben		l = n;	}	((WindPtr)d)->DialogRefcon = (long)nil;	// Dialogliste freigeben}/*** *	ein bestimmtes Listenelement abmelden ***/VOID			DisposeObject(DialogPtr d,WORD item){REG OwnObjectH	l = (OwnObjectH)((WindPtr)d)->DialogRefcon;REG OwnObjectH	n,o;	o = nil;					// kein Vorgängerobjekt	while(l) {		GetHandleSize((Handle)l);		// ist l wirklich eine Handle?		if(MemError()) {		// Nein => Fehler!			OwnBeep(shit);			break;		}		n = (*l)->next;						// Folgeobjekt		if ((*l)->item == item) {			// Item gefunden?			if ((*l)->dispose)				(*(*l)->dispose)((VOID*)l);	// Object freigeben			if (o)							// ein Vorgänger?				(*o)->next = n;				// dort den Next-Ptr updaten			else				((WindPtr)d)->DialogRefcon = (long)n;	// Basis neu setzen			DisposeHandle((Handle)l);			break;		}		o = l;					// Vorgängerobjekt merken		l = n;					// neues aktuelles Objekt	}}/*** *	List-Item updaten ***/pascal VOID		DrawObject(REG DialogPtr d,WORD item){REG OwnObjectH	l = (OwnObjectH)((WindPtr)d)->DialogRefcon;	while(l) {		GetHandleSize((Handle)l);		// ist l wirklich eine Handle?		if(MemError()) {		// Nein => Fehler!			OwnBeep(shit);			break;		}		if ((*l)->item == item) {		// Item gefunden?			if ((*l)->draw)				(*(*l)->draw)((VOID*)l,d);	// dann zeichnen			break;						// und raus		}		l = (*l)->next;	}}/***************************************************************** * Popup-Menü Unterstützung *****************************************************************/WORD		PopupKlick(OwnObjectH l,DialogPtr d,Point where,WORD modifiers,WORD *item);VOID		PopupDraw(OwnObjectH l,DialogPtr d);VOID		PopupDispose(OwnObjectH l);typedef struct {	WORD		choice;		// aktuelle Item	MenuHandle	mHandle;	// Handle auf das Popup-Menü	WORD		mID;		// ID vom Popup-Menü	WORD		tItem;		// Dialog-Item, welches vor dem Popup-Menü steht (0 = keins)	WORD		mItem;		// Dialog-Item vom Popup-Menü} PopupObject;#define	leftSlop	15#define	rightSlop	18#define	botSlop		5/*** *	Popup-Menü anmelden ***/VOID			NewPopup(REG DialogPtr d,REG WORD item,WORD menuId,WORD textId,WORD index){FontInfo	f;GrafPtr		savePort;PopupObject	**p;OwnObjectH	o;MenuHandle	m;WORD		width;WORD type; Handle h; Rect r;	if (index <= 0) index = 1;					// minimalen Wert vorgeben	GetPort(&savePort);	SetPort((GrafPtr)d);	TextFont(0);					// SystemFont einstellen	TextSize(0);					// Und default-Schriftgröße	TextFace(0);					// keine besonderen Schriftattribute	GetFontInfo(&f);	p = (PopupObject**)NewHandleClear(sizeof(PopupObject));	if (!p) DebugStr("\pOut of mem in NewPopup");	(*p)->mID		= menuId;					// ID des Menü	(*p)->tItem		= textId;					// Item vom Text vor dem Menü	(*p)->mItem		= item;						// Item vom Text vor dem Menü	(*p)->mHandle	= m = GetMenu(menuId);		// Handle auf das Popup-Menü	if (!m) DebugStr("\pGetMenu failed in NewPopup");	HNoPurge((Handle)m);						// Menü NICHT purgen!	CalcMenuSize(m);							// Größe vom Menü errechnen	GetDItem(d,item,&type,&h,&r);				// Größe vom Item ermitteln	r.bottom = r.top + f.ascent + f.descent + f.leading;	width = r.right - r.left - leftSlop - rightSlop;	// aktuelle Breite des Menüs	if (width > (*m)->menuWidth)				// Menü kürzer als das Useritem?		r.right = r.left + (*m)->menuWidth + leftSlop + rightSlop;	// dann die Breite neu setzen	width = r.left;	SetDItem(d,item,type,h,&r);					// und auf die Fonthöhe setzen	o = NewObject(d,item,popup,(LONG)p);		// Object anlegen	(*o)->klick	= PopupKlick;			// Klick-Routine	(*o)->draw	= PopupDraw;			// Zeichenroutine	(*o)->dispose = PopupDispose;		// Liste freigeben	PopupDraw(o,d);								// Popup sofort zeichnen	if (textId) {								// Text-Item vor dem Menü vorhanden?		GetDItem(d,textId,&type,&h,&r);			// Größe vom Textitem ermitteln		r.right = width - 1;					// und den rechten Rand ans Popup-Menü		SetDItem(d,textId,type,h,&r);		o = NewObject(d,textId,popup,(LONG)p);	// Object anlegen		(*o)->klick	= PopupKlick;		// Klick-Routine	}	SetPopupValue(d,item,index);				// aktuelles Item abhaken	SetPort(savePort);}WORD		PopupKlick(OwnObjectH l,DialogPtr d,Point where,WORD modifiers,WORD *item){REG WORD		left;REG UWORD		chosen = 0;WORD type; Handle h; Rect tRect,mRect;REG PopupObject	**p = (PopupObject**)((*l)->refCon);REG WORD		tItem = (*p)->tItem;Point			popLoc;GrafPtr			savePort;REG MenuHandle	m;	GetPort(&savePort);	SetPort(d);	if (tItem) GetDItem(d,tItem,&type,&h,&tRect);	// Größe vom Item ermitteln	GetDItem(d,(*p)->mItem,&type,&h,&mRect);		// Größe vom Item ermitteln	tRect.top = mRect.top; tRect.bottom = mRect.bottom; tRect.right = mRect.left - 1;	if (tItem) InvertRect(&tRect);					// Text invertieren	popLoc = topLeft(mRect);	LocalToGlobal(&popLoc);	m = (*p)->mHandle;	CalcMenuSize(m);								// wegen einem Fehler im Menu Manager	InsertMenu(m,hierMenu);							// hier. Menü aufbauen	chosen = PopUpMenuSelect(m,popLoc.v,popLoc.h,(*p)->choice);	DeleteMenu((*m)->menuID);	if (tItem) InvertRect(&tRect);					// Text zurück invertieren	SetPort(savePort);	if (chosen) {									// irgendwas angewählt?		chosen = LoWord(chosen);		if (chosen != (*p)->choice) {				// neuer Menüpunkt angewählt?			SetPopupValue(d,(*p)->mItem,chosen);	// Menüpunkt selektieren			*item = (*p)->mItem;					// Popup-Menü angeklickt			return(true);							// und raus		}	}	return(false);}VOID		PopupDraw(OwnObjectH l,DialogPtr d){PopupObject	**p;char		state;Str255		curFont;WORD		wid,newWid,newLen;WORD type; Handle h; Rect r;GrafPtr		savePort;FontStruct	f;	GetPort(&savePort);	SetPort(d);	state = HGetState((Handle)l);	HLock((Handle)l);	SaveText(&f);								// Fonteinstellungen retten	RestoreText(&fDefault);						// Systemfont einschalten	p = (PopupObject**)(*l)->refCon;			// Popup-Menü-Handle	GetDItem(d,(*p)->mItem,&type,&h,&r);		// Größe vom Item ermitteln	GetItem((*p)->mHandle,(*p)->choice,curFont);// aktuelles Item ermitteln	InsetRect(&r,-1,-1);						// Rechteck etwas größer machen	wid = (r.right - r.left) - (leftSlop + rightSlop);	// maximale Breite für den String	newWid = StringWidth(curFont);	if (newWid > wid) {							// paßt der Text nicht mehr?		TextFace(condense);						// dann probeweise mal enger ausgeben		newWid = StringWidth(curFont);		if (newWid > wid) {						// paßt der Text immer noch nicht?			newLen = curFont[0];				// Länge vom String merken			wid -= CharWidth('…');				// '…' an den Filenamen anhängen			do {				newWid -= CharWidth(curFont[newLen--]);	// hinten am String zeichen abcutten			} while((newWid > wid)&&(curFont[0]));	// paßt der String nun?			curFont[++newLen] = '…';			// nun noch die '…' anhängen			curFont[0] = newLen;				// und die neue Länge einsetzen		}	}	FrameRect(&r);								// Popup-Menü umrahmen	MoveTo(r.right,r.top+2); LineTo(r.right,r.bottom); LineTo(r.left+2,r.bottom); // Schatten zeichnen	MoveTo(r.left+leftSlop,r.bottom-botSlop);	DrawString(curFont);						// String ausgeben	for(wid = 0; wid < 6; ++wid) {				// und noch den Pfeil zeichnen		MoveTo(r.right - wid - 12,r.bottom - wid - 7);		Line(wid<<1,0);	}	HSetState((Handle)l,state);	RestoreText(&f);	SetPort(savePort);}//	Popup-Menü in einer Dialogbox verwerfenVOID		PopupDispose(OwnObjectH l){PopupObject	**p = (PopupObject**)(*l)->refCon;	// Popup-Menü-Handle	if ((*p)->mHandle)		DisposeMenu((*p)->mHandle);	DisposHandle((Handle)(*l)->refCon);}/*** *	aktuelle Auswahl im Popup-Menü ermitteln ***/WORD			GetPopupValue(DialogPtr d,WORD item){REG OwnObjectH	l = (OwnObjectH)((WindPtr)d)->DialogRefcon;	while(l) {		GetHandleSize((Handle)l);		// ist l wirklich eine Handle?		if(MemError()) {		// Nein => Fehler!			OwnBeep(shit);			break;		}		if ((*l)->item == item)			// Item gefunden?			return((*(PopupObject**)(*l)->refCon)->choice);		l = (*l)->next;	}	return(-1);							// Item nicht gefunden}/*** *	aktuelle Auswahl im Popup-Menü ermitteln ***/VOID			SetPopupValue(DialogPtr d,WORD item,WORD value){REG OwnObjectH	l = (OwnObjectH)((WindPtr)d)->DialogRefcon;REG PopupObject	**p;WORD			i;WORD type; Handle h; Rect mRect;GrafPtr		savePort;	if (value <= 0) value = 1;							// minimalen Wert vorgeben	GetPort(&savePort);	SetPort((GrafPtr)d);	while(l) {		GetHandleSize((Handle)l);		// ist l wirklich eine Handle?		if(MemError()) {		// Nein => Fehler!			OwnBeep(shit);			break;		}		if ((*l)->item == item) {						// Item gefunden?			p = (PopupObject**)((*l)->refCon);			LoadResource((Handle)(*p)->mHandle);			for(i=1;i<99;i++)				SetItemMark((*p)->mHandle,i,' ');		// alte Items entfernen			SetItemMark((*p)->mHandle,value,checkMark);	// und neues abhaken			(*p)->choice = value;						// neues Item merken			GetDItem(d,(*p)->mItem,&type,&h,&mRect);	// Größe vom Item ermitteln			EraseRect(&mRect);							// Item löschen			PopupDraw(l,d);								// Item neu zeichnen			break;		}		l = (*l)->next;	}	SetPort(savePort);}/*** *	String eines Popup-Menü-Eintrags zurückgeben ***/VOID			GetPopupItem(DialogPtr d,WORD item,WORD index,Str255 s){REG OwnObjectH	l = (OwnObjectH)((WindPtr)d)->DialogRefcon;REG PopupObject	**p;	s[0] = 0;					// Rückgabestring löschen	while(l) {		GetHandleSize((Handle)l);		// ist l wirklich eine Handle?		if(MemError()) {		// Nein => Fehler!			OwnBeep(shit);			break;		}		if ((*l)->item == item) {						// Item gefunden?			p = (PopupObject**)((*l)->refCon);			LoadResource((Handle)(*p)->mHandle);			GetItem((*p)->mHandle,index,s);				// String zurückgeben			break;		}		l = (*l)->next;	}}/***************************************************************** * List Manager Unterstützung *****************************************************************/WORD		ListKlick(OwnObjectH l,DialogPtr d,Point where,WORD modifiers,WORD *item);VOID		ListDraw(OwnObjectH l,DialogPtr d);VOID		ListDispose(OwnObjectH l);/*** *	eindimensionale Liste in einer Dialogbox erzeugen ***/ListHandle		NewList(REG DialogPtr d,REG WORD item,Boolean VSlider,Boolean HSlider,WORD proc){WORD			type; Rect r; Handle c;static Rect		dr = { 0,0,1,1 };GrafPtr			savePort; Cell cs = { 0,0 };REG ListHandle	l;REG WORD		i;FontInfo		f;OwnObjectH		o;	GetPort(&savePort);	SetPort((GrafPtr)d);	GetDItem(d,item,&type,&c,&r);		// Daten vom UserItem holen	GetFontInfo(&f);	i = f.ascent + f.descent + f.leading;	// Fonthöhe	i = (r.bottom - r.top) - (r.bottom - r.top) % i;	// Höhe des Items	r.bottom = r.top + i;				// untere Kante neu setzen	SetDItem(d,item,type,c,&r);	if (VSlider) r.bottom -= 15;	if (HSlider) r.right -= 15;			// Platz für den Slider	l = LNew(&r,&dr,cs,proc,d,false,false,VSlider,HSlider);	if (!l) DebugStr("\pOut of mem in NewList");	o = NewObject(d,item,list,(LONG)l);	// Object anlegen	(*o)->klick	= ListKlick;	// Klick-Routine	(*o)->draw	= ListDraw;	// Zeichenroutine	(*o)->dispose = ListDispose; // Liste freigeben	LDelRow(1,0,l);						// erste Zelle gleich wieder wegwerfen	SetPort(savePort);	return(l);}//	Liste in einer Dialogbox angeklicktWORD		ListKlick(OwnObjectH l,DialogPtr d,Point where,WORD modifiers,WORD *item){	LClick(where,modifiers,(ListHandle)(*l)->refCon);	return(false);}//	Liste in einer Dialogbox zeichnenVOID		ListDraw(OwnObjectH l,DialogPtr d){Rect	r;WORD	type;Handle	h;	GetDItem(d,(*l)->item,&type,&h,&r);	LUpdate(d->visRgn,(ListHandle)(*l)->refCon);	InsetRect(&r,-1,-1);	FrameRect(&r);}//	Liste in einer Dialogbox verwerfenVOID		ListDispose(OwnObjectH l){	LDispose((ListHandle)(*l)->refCon);}/*** *	Item an die Liste anhängen ***/WORD			AddListMgr(REG STR s,REG ListHandle l){Cell		c = {0,0};REG WORD	i = 0;	i = LAddRow(1,9999,l);			// eine Zeile anhängen	c.v = i;						// eine Zeile anhängen	LSetCell(s,Strlen(s),c,l);		// Item ändern	return(i);						// Zellen-Zeile zurückgeben}/*** *	Item in die Liste einsortieren ***/WORD			SortToListMgr(REG STR s,REG ListHandle l){Cell		c = {0,0};Str255		st;WORD		stLen;	CtoPstr(s);						// String in einen Pascal-String wandeln	LDoDraw(false,l);				// ständiges Update ausschalten	c.v = LAddRow(1,9999,l);		// erstmal eine Zeile anhängen	while(c.v>0) {					// Tabellenanfang erreicht? => raus		c.v--;		stLen = 255;		LGetCell(st+1,&stLen,c,l);	// Vorgänger-Zelle holen		st[0] = stLen;				// Pascal-String zusammensetzen		c.v++;		if(IUCompString((USTR)s,st)>=0) break; // Position gefunden?		LSetCell(st+1,stLen,c,l);	// Item hochschieben		c.v--;	}	PtoCstr((USTR)s);				// und den String wieder in einen C-String	LSetCell(s,Strlen(s),c,l);		// Item setzen	LDoDraw(true,l);				// ständiges Update wieder einschalten	LUpdate((*l)->port->visRgn,l);	return(c.v);					// Zellen-Zeile zurückgeben}/*** *	selektierte Zelle finden. Wenn keine selektiert: -1 zurückgeben ***/WORD			FindSelCell(REG ListHandle l){Cell		c;REG WORD	i;	for(i=0;i<(*l)->dataBounds.bottom;i++) {	// alle Zellen durchsuchen		c.h = 0; c.v = i;		if (LGetSelect(false,&c,l))				// selektierte Zelle gefunden?			return(i);	}	return(-1);									// keine Zelle selektiert}/*** *	zwei Routinen um zwei DITL-Resourcen und zwei hdlg-Resourcen zu verschmelzen ***/struct DITLItem {			// First, a single item	Handle	itmHndl;		// Handle or procedure pointer for this item	Rect	itmRect;		// Display rectangle for this item	SignedByte	itmType;	// Item type for this item — 1 byte	SignedByte	itmData[];	// Length byte of data};typedef	struct DITLItem		DITLItem, *pDITLItem, **hDITLItem;struct ItemList {				// Then, the list of items	WORD		dlgMaxIndex; 	// Number of items minus 1	struct DITLItem	DITLItems[]; 	// Array of items};typedef	struct ItemList		ItemList, *pItemList, **hItemList;typedef	WORD	*IntPtr;// Types for accessing the Help Manager 'hdlg' resources.typedef struct {	WORD	hdlgVers;	WORD	hdlg1stItem;	LONG	hdlgOptions;	WORD	hdlgProcID;	WORD	hdlgVarCode;	WORD	hdlgNumItems;} hdlgHeader, *hdlgHeaderPtr, **hdlgHeaderHdl;//typedef WORD *IntPtr, **IntHdl;WORD MyAppendDITL(DialogPtr theDialog,WORD theDITLID)/* version 0.1 9/11/86 Lew Rollins of Human-Systems Interface Group*//* this routine still needs some error checking *//* This routine appends all of the items of a specified DITLonto the end of a specified DLOG — We don’t even need to know the formatof the DLOG *//* this will be done in 3 steps: 1. append the items of the specified DITL onto the existing DLOG 2. expand the original dialog window as required 3. return the adjusted number of the first new user item*/{Point		offset;		// Used to offset rectangles of items being appendedRect		maxRect;	// Used to track increases in window sizehItemList	hDITL;		// Handle to DITL being appendedpDITLItem	pItem;		// Pointer to current item being appendedhItemList	hItems;		// Handle to DLOG’s item listWORD		firstItem;	// Number of where first item is to be appendedWORD		newItems,	// Count of new items			dataSize,	// Size of data for current item			i; 			// Working indexOSErr		err;		// Standard-Fehler	union {		WORD		Int;		SignedByte	SBArray[2];	} USB;	/*	 Using the original DLOG	 1. Remember the original window Size.	 2. Set the offset Point to be the bottom of the original window.	 3. Subtract 5 pixels from bottom and right, to be added		back later after we have possibly expanded window.	 4. Get working Handle to original item list.	 5. Calculate our first item number to be returned to caller.	 6. Get locked Handle to DITL to be appended.	 7. Calculate count of new items.	*/	maxRect = ((DialogPeek)theDialog)->window.port.portRect;	offset.v = maxRect.bottom;	offset.h = 0;	maxRect.bottom = maxRect.bottom - 5;	maxRect.right = maxRect.right - 5;	hItems = (hItemList)(((DialogPeek)theDialog)->items);	firstItem = (*hItems)->dlgMaxIndex + 2;	hDITL = (hItemList)GetResource('DITL', theDITLID);	HLockH((Handle)hDITL);	newItems = (*hDITL)->dlgMaxIndex + 1;	/*	 For each item,	  1. Offset the rectangle to follow the original window.	  2. Make the original window larger if necessary.	  3. fill in item Handle according to type.	*/	pItem = (*hDITL)->DITLItems;	for (i = 1; i <= newItems; i++) {		OffsetRect(&pItem->itmRect, offset.h, offset.v);		UnionRect(&pItem->itmRect, &maxRect, &maxRect);		USB.Int = 0;		 /*zero things out*/		USB.SBArray[1] = pItem->itmData[0];		/* Strip enable bit since it doesn’t matter here. */		switch (pItem->itmType & 0x7f) {			case userItem:	 /* Can’t do anything meaningful with user items. */				pItem->itmHndl = nil;				break;			case (ctrlItem + btnCtrl):			case (ctrlItem + chkCtrl):			case (ctrlItem + radCtrl):					/*build Control */				pItem->itmHndl = (Handle)						  NewControl(theDialog, 		/* theWindow */									 &pItem->itmRect, 	/* boundsRect */									 ((StringPtr)(&pItem->itmData[0])), /* title */									 true,				/* visible */									 0,0,1,				/* value, min, max */									 (pItem->itmType & 0x03), /* procID */									 0); 				/* refCon */				break;			case ctrlItem + resCtrl:	/* Get resource based Control */				pItem->itmHndl = (Handle)						  GetNewControl((*(IntPtr)&pItem->itmData[1]), /* controlID */										theDialog); 			/* theWindow */				(*(ControlHandle)pItem->itmHndl)->contrlRect = pItem->itmRect; /*give it the right																   				rectangle*/				/* An actionProc for a Control should be installed here */				break;			case (statText):			case (editText): 	/* Both need Handle to a copy of their text. */				err = PtrToHand(&pItem->itmData[1], /* Start of data */								&pItem->itmHndl, 	/* Address of new Handle */								USB.Int); 			/* Length of text */				break;			case iconItem:	 	/* Icon needs resource Handle. */				pItem->itmHndl = GetIcon(*(IntPtr)&pItem->itmData[1]); 	/* ICON resID */				break;			case picItem: 	 	/* Picture needs resource Handle. */				pItem->itmHndl = (Handle)GetPicture(*(IntPtr)&pItem->itmData[1]);	/*PICT resID*/				break;			default:				pItem->itmHndl = nil;				break;		}		dataSize = ((USB.Int + 1) & 0xfffe);		/*now advance to next item*/		pItem = (pDITLItem)((Ptr)(pItem) + dataSize + sizeof(DITLItem));	}	err = PtrAndHand		((Ptr)(*hDITL)->DITLItems, (Handle)hItems, GetHandleSize((Handle)hDITL) - 2);	(*hItems)->dlgMaxIndex = (*hItems)->dlgMaxIndex + newItems;	HUnlock((Handle)hDITL);	ReleaseResource((Handle)hDITL);	maxRect.bottom = maxRect.bottom + 5;	maxRect.right = maxRect.right + 5;	SizeWindow(theDialog, maxRect.right, maxRect.bottom, true);	return firstItem;}/*--------------------------------------------------------------------------*//*																			*//* Append2hdlg - Append one 'hdlg' resource onto another.					*//*																			*//*	So what we want to do here is append the hdlg resource with resource ID	*//* srcID, onto the end of the hdlg resource, ID dstID.  Here's what these	*//* things look like:														*//*																			*//*					*-----------------------------------*					*//*					| Header (version, options, etc.)	|					*//*					*-----------------------------------*					*//*					/ # of items in item array			/					*//*					*-----------------------------------*					*//*					| Missing item marker				|					*//*					*-----------------------------------*					*//*					/ Array of items					/					*//*					/	…								/					*//*					*-----------------------------------*					*//*																			*//* Okay, so this chart breaks up the resource into logical blocks for this	*//* excercise.  We're most interested in the blocks marked with '/'s.  The	*//* first one of these is the # of items in the item array.  We need to read	*//* this field in the source hdlg to know how many items we are adding.  We	*//* need to update this field in the destination hdlg so the Help Manager 	*//* knows that we added some items.  This missing item is a generic item 	*//* used by the Help Manager anytime it can't find a resource entry for an	*//* item.  In most hdlg resources, this item is simply HMSkipItem (a no op),	*//* but this code makes no assumptions about that.  It does however assume	*//* that you want to preserve the missing item in the DESTINATION hdlg,		*//* rather than copying from the source.  									*//* So this code does this:													*//*																			*//*					Source							Destination				*//*		*---------------------------*		*---------------------------*	*//*		| Header					|	  	| Header					|	*//*		|	(version, options, etc.)|	 	|	(version, options, etc.)|	*//*		*---------------------------*		*---------------------------*	*//*		/ # of items in item array	/--Add->/ # of items in item array	/	*//*		*---------------------------*		*---------------------------*	*//*		| Missing item 				|		| Missing item 				|	*//*		*---------------------------*		*---------------------------*	*//*											/ Array of items			/	*//*											/	…						/	*//*		*---------------------------*-Copy->*---------------------------*	*//*		/ Array of items			/										*//*		/	…						/										*//*		*---------------------------*										*//*																			*//* Nothing to it.  The number of items is updated by adding the count from	*//* source hdlg, no 'minus 1' or anything tricky.  Then just append the item	*//* array from the source onto the end of the destination.  The Help Manager	*//* finds the new items no problem.  Okay, but since we are a guest in some-	*//* one elses closet, we need to play some games with memory.  First of all,	*//* we make sure that the destination 'hdlg' resource isn't already in mem-	*//* ory using the ol' SetResLoad trick.  If it's not there, we load it, but	*//* in any case, the hdlg is loaded into memory.  Once there, we make the	*//* rather large assumption that it's not going anywhere.  This means that	*//* we don't lock the hdlg handle, we don't even mark it non-purgeable.  The	*//* assumption is that the Help Manager will be finding the resource as soon *//* as we are done with it, and he will take care of keeping it around after	*//* that.  Once the dialog is dismissed, the resource is naturally purged,	*//* along with the changes that we made to it.  Since we never told the		*//* Resource Manager that we had changed the resource, it doesn't try to save*//* it.																		*/VOID Append2hdlg(WORD srcResID,WORD dstResID){Handle			srcHdl, dstHdl;Ptr				srcPtr, dstPtr;WORD			srcLength, dstLength;WORD			missingItmSz;SignedByte		dstHState;	srcHdl = GetResource('hdlg', srcResID);		if(!srcHdl) return;	SetResLoad(false);						// System Resource, make sure it’s not	dstHdl = GetResource('hdlg', dstResID);	// already loaded.	SetResLoad(true);	if (*dstHdl == 0)		dstHdl = GetResource('hdlg', dstResID);	dstHState = HGetState(dstHdl);	if (dstHdl != nil) {		srcPtr = (Ptr)*srcHdl + sizeof(hdlgHeader);		missingItmSz = *((IntPtr)srcPtr);		srcLength = GetHandleSize(srcHdl) - (sizeof(hdlgHeader) - missingItmSz);		dstLength = GetHandleSize(dstHdl);		SetHandleSize(dstHdl, dstLength + srcLength);		if (MemError() != noErr) {			DebugStr("\pMemError");	// Use this error handler, go to jail.			ExitToShell();			// It's the law!		}		dstPtr = (Ptr)*dstHdl + dstLength;		srcPtr = (Ptr)*srcHdl + sizeof(hdlgHeader) + missingItmSz;		BlockMoveData(srcPtr,dstPtr,srcLength);		HSetState(dstHdl,dstHState);		((hdlgHeaderPtr)*dstHdl)->hdlgNumItems += ((hdlgHeaderPtr)*srcHdl)->hdlgNumItems;			}	ReleaseResource(srcHdl);}/*** *	globale Varibalen für das Meter-Useritem ***/LONG		mWmax;			// maximaler Wert (für Skalierung)LONG		mWakt;			// aktueller WertWindowPtr	mWPtr;			// interne Variable: WindowpointerRect		mWItemRect;		// interne Variable: Item-Rechteck/*** *	Useritem für Meter-Windows ***/pascal VOID		mWindowDraw(DialogPtr d,WORD item){#define fiveSize 1#define tenSize 3WORD		i;GrafPtr		savePort;WORD		type;Handle		h;WORD		tenStep;WORD		fiveStep;	mWPtr = d;	if (!d) return;	GetPort(&savePort);	SetPort(d);	GetDItem(d,item,&type,&h,&mWItemRect);	EraseRect(&mWItemRect);	tenStep = mWItemRect.right - mWItemRect.left;	fiveStep = tenStep / 2;	PenSize(1,1);	InsetRect(&mWItemRect,-1,-1);	FrameRect(&mWItemRect);	InsetRect(&mWItemRect,1,1);	MoveTo(mWItemRect.left + fiveStep, mWItemRect.top - 1);	Line(0,fiveSize);	MoveTo(mWItemRect.left + fiveStep, mWItemRect.bottom);	Line(0,-fiveSize);	for(i=1;i<=9;i++) {		MoveTo(mWItemRect.left + (i * tenStep) / 10, mWItemRect.top - 1);		Line(0,tenSize);		MoveTo(mWItemRect.left + (i * tenStep) / 10, mWItemRect.bottom);		Line(0,-tenSize);		MoveTo(mWItemRect.left + (i * tenStep) / 10 + fiveStep / 10, mWItemRect.top - 1);		Line(0,fiveSize);		MoveTo(mWItemRect.left + (i * tenStep) / 10 + fiveStep / 10, mWItemRect.bottom);		Line(0,-fiveSize);	}	SetPort(savePort);//	mWindowUpdate(mWakt);}/*** *	diese Routine ermittelt die Hilite-Color eines Fensters ***/Boolean	GetHiliteColor(WindowPtr w,RGBColor *contColor);Boolean	GetHiliteColor(WindowPtr w,RGBColor *contColor){AuxWinHandle	auxWinHdl;REG WCTabHandle	winCTable;REG short		i;	if(!GetAuxWin(w,&auxWinHdl)) return (false);	winCTable = (WCTabHandle)((*auxWinHdl)->awCTable);	i = (*winCTable)->ctSize;	while((i>=0) && ((*winCTable)->ctTable[i].value != wHiliteColor))		i--;	if (i<0) i = 0;	*contColor = (*winCTable)->ctTable[i].rgb;	return (true);}/*** *	diese Routine setzt den Füllstand des Meter-Useritem ***/VOID	mWindowUpdate(LONG curI){GrafPtr		savePort;Rect		mRect = mWItemRect;WORD		pDone;WORD		hsize = mRect.right - mRect.left;WORD		tenStep;WORD		fiveStep;WORD		i;	mWakt = curI;	if (!mWPtr) return;	GetPort(&savePort);	SetPort(mWPtr);	if (mWmax == 0)	pDone = 0;	else			pDone = (curI * hsize / mWmax);	if (pDone > hsize) pDone = hsize;	mRect.right = mRect.left + pDone;	if (gQDVersion) {		RGBColor	saveFore,saveBack;		RGBColor	myColor;		Boolean		draw = false;		GetForeColor(&saveFore);		if(GetHiliteColor(mWPtr,&myColor)) {			RGBForeColor(&myColor);			FillRect(&mRect,&qd.black);			draw = true;		}		if(!draw)			FillRect(&mRect,&qd.gray);		RGBForeColor(&saveFore);	} else {		FillRect(&mRect,&qd.gray);	}	tenStep = mWItemRect.right - mWItemRect.left;	fiveStep = tenStep / 2;	PenSize(1,1);	MoveTo(mWItemRect.left + fiveStep, mWItemRect.top - 1);	Line(0,fiveSize);	MoveTo(mWItemRect.left + fiveStep, mWItemRect.bottom);	Line(0,-fiveSize);	for(i=1;i<=9;i++) {		MoveTo(mWItemRect.left + (i * tenStep) / 10, mWItemRect.top - 1);		Line(0,tenSize);		MoveTo(mWItemRect.left + (i * tenStep) / 10, mWItemRect.bottom);		Line(0,-tenSize);		MoveTo(mWItemRect.left + (i * tenStep) / 10 + fiveStep / 10, mWItemRect.top - 1);		Line(0,fiveSize);		MoveTo(mWItemRect.left + (i * tenStep) / 10 + fiveStep / 10, mWItemRect.bottom);		Line(0,-fiveSize);	}	MoveTo(mRect.right,mRect.top);	LineTo(mRect.right,mRect.bottom);	SetPort(savePort);}