#if 1pascal long myCDEF(short VarCode,ControlHandle c,short message,long param);void	main(void){DialogPtr	d;short		itemHit;Handle		h;	InitGraf(&thePort);	InitFonts();	FlushEvents(everyEvent,0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(0L);	InitCursor();//	h = GetResource('CDEF',3);//	h = (Handle)((*(char**)h)+2);//	*(long**)h = (ProcPtr)myCDEF;	d = GetNewDialog(128,0L,(Ptr)-1L);	do {		ModalDialog(0L,&itemHit);	} while (itemHit != 1);	DisposDialog(d);}#endif/*** *	CDEF-Funktion für PopUp-Menüs ***/#define mUnused			1#define mRes			2#define mCheck			4#define mKey			8#define inPopUpBox		1#define titlePart		2#define mItemRectMsg	512#define mDrawItemMsg	513#define VISIBLE		255#define INVISIBLE	0#define INACTIVE	255#define ACTIVE		0#define DRAW_ALL	0#define	NOT_IN_CTL	0#define	L_PIXELS	13#define	GREY		16typedef struct {	MenuHandle		popMenu;	short			menuProcID;	Boolean			hasColorQD;	char			markChar;	RGBColor		wFgColor;	RGBColor		wBgColor;	RGBColor		wContColor;	RGBColor		mTitleColor;	RGBColor		mBgColor;	RGBColor		iNameColor;	RGBColor		iKeyColor;} CtlDataRec,*CtlDataPtr,**CtlDataHdl;typedef struct {	GrafPtr			savePort;	PenState		savePen;	RgnHandle		oldClip;	RgnHandle		newClip;} StateRec;/*** *	Prototypen ***/void	doDrawCntl(ControlHandle c,long VarCode,long param);long	doTestCntl(ControlHandle c,Point param);void	doCalcCRgns(ControlHandle c,long param);void	doInitCntl(ControlHandle c,long VarCode);void	doDispCntl(ControlHandle c,long VarCode);void	doAutoTrack(ControlHandle c,long VarCode,long param);void	doCalcCntlRgn(ControlHandle c,long param);void	doCalcThumbRgn(ControlHandle c,long param);void	SaveState(ControlHandle c,StateRec *s);void	RestoreState(ControlHandle c,StateRec *s);pascal long myCDEF(short VarCode,ControlHandle c,short message,long param)//pascal long main(short VarCode,ControlHandle c,short message,long param){long		ret = 0L;		// Rückgabewert erstmal löschenStateRec	s;	HLock(c);	SaveState(c,&s);	switch (message) {	case	drawCntl:	doDrawCntl(c,VarCode,param);						break;	case	testCntl:	ret = doTestCntl(c,*(Point*)&param);						break;	case	calcCRgns:	doCalcCRgns(c,param);						break;	case	initCntl:	doInitCntl(c,VarCode);						break;	case	dispCntl:	doDispCntl(c,VarCode);						break;	case	autoTrack:	doAutoTrack(c,VarCode,param);						break;	case	calcCntlRgn:doCalcCntlRgn(c,param);		// für 32Bit-Clean…						break;	case	calcThumbRgn:doCalcThumbRgn(c,param);	// für 32Bit-Clean…						break;	}	RestoreState(c,&s);	HUnlock(c);	return(ret);}/*** *	MDEF-Funktion aufrufen ***/pascal	void	CallMDEF(short message,MenuHandle theMenu,Rect *menuRect,Point hitPt,short whichItem,ProcPtr MDEFProc)    = {0x205F,0x4E90}; /*** *	Rechteck zu einem Item ermitteln ***/void	GetItemRect(ControlHandle c,short id,short item,Rect *r){Point		p = { 0,0 };MenuHandle	m;Handle		mDefProc;	m = GetMHandle(id);	mDefProc = (*m)->menuProc;	LoadResource(mDefProc);	CallMDEF(mItemRectMsg,m,r,p,item,(ProcPtr)mDefProc);}/*** *	Ein Item des Menüs im Rechteck r zeichnen ***/void	DrawMenuItem(ControlHandle c,short id,short item,Rect *r){Point		p = { 0,0 };MenuHandle	m;Handle		mDefProc;	m = GetMHandle(id);	mDefProc = (*m)->menuProc;	LoadResource(mDefProc);	CallMDEF(mDrawItemMsg,m,r,p,item,(ProcPtr)mDefProc);}/*** *	Windowfarbe vom Content-Bereich holen ***/void	GetContentColor(WindowPtr w,RGBColor *contColor){AuxWinHandle	auxWinHdl;WCTabHandle		winCTable;short			i;	GetAuxWin(w,&auxWinHdl);	winCTable = (WCTabHandle)((*auxWinHdl)->awCTable);	i = (*winCTable)->ctSize;	while((i>=0) && ((*winCTable)->ctTable[i].value != wContentColor))		i--;	if (i<0) i = 0;	*contColor = (*winCTable)->ctTable[i].rgb;}/*** *	Initialize the control´s menu color information ***/void	GetMenuColors(ControlHandle c,CtlDataHdl d){RGBColor	WhiteRGB;RGBColor	BlackRGB;MCEntryPtr	mbarPtr;MCEntryPtr	titlePtr;MCEntryPtr	itemPtr;	WhiteRGB.red	= 0xFFFF;	WhiteRGB.green	= 0xFFFF;	WhiteRGB.blue	= 0xFFFF;	BlackRGB.red	= 0x0000;	BlackRGB.green	= 0x0000;	BlackRGB.blue	= 0x0000;	mbarPtr		= GetMCEntry(0,0);	titlePtr	= GetMCEntry((*c)->contrlMax,0);	itemPtr		= GetMCEntry((*c)->contrlMax,(*c)->contrlMin);	if (mbarPtr == 0L) {		if (titlePtr == 0L) {			(*d)->mTitleColor	= BlackRGB;			(*d)->mBgColor		= WhiteRGB;		}		if (itemPtr == 0L) {			(*d)->iNameColor	= BlackRGB;			(*d)->iKeyColor		= BlackRGB;		}	} else {		if (titlePtr == 0L) {			(*d)->mTitleColor	= mbarPtr->mctRGB1;			(*d)->mBgColor		= mbarPtr->mctRGB2;		}		if (itemPtr == 0L) {			(*d)->iNameColor	= mbarPtr->mctRGB3;			(*d)->iKeyColor		= mbarPtr->mctRGB3;		}	}	if (titlePtr != 0L) {		(*d)->mTitleColor		= titlePtr->mctRGB1;		(*d)->mBgColor			= titlePtr->mctRGB4;		if (itemPtr == 0L) {			(*d)->iNameColor	= titlePtr->mctRGB3;			(*d)->iKeyColor		= titlePtr->mctRGB3;		}	}	if (itemPtr != 0L) {		(*d)->iNameColor		= mbarPtr->mctRGB2;		(*d)->iKeyColor			= mbarPtr->mctRGB3;	}}/*** *	Initialize the control´s color information ***/void	InitColorInfo(ControlHandle c,CtlDataHdl d){short		i;WindowPtr	w;	HLock(d);	w = (*c)->contrlOwner;	GetContentColor(w,&(*d)->wContColor);	GetForeColor(&(*d)->wFgColor);	GetBackColor(&(*d)->wFgColor);	GetMenuColors(c,d);	HUnlock(d);}/*** *	Get the title of the pop-up menu ***/void	GetTitleRect(ControlHandle c,Rect *r){FontInfo	fInfo;short		height;	GetFontInfo(&fInfo);	height = fInfo.ascent + fInfo.descent + fInfo.leading;	SetRect(r,(*c)->contrlRect.left,(*c)->contrlRect.top,			(*c)->contrlRect.left + StringWidth((*c)->contrlTitle),			(*c)->contrlRect.top + height);	if (r->bottom > (*c)->contrlRect.bottom - 1)		r->bottom = (*c)->contrlRect.bottom - 1;	if (r->right > (*c)->contrlRect.right - 1)		r->right = (*c)->contrlRect.right - 1;}/*** *	Get the box surrounding the pop-up box ***/void	GetBoxRect(ControlHandle c,Rect *r){short		leftEdge;MenuHandle	m;FontInfo	fInfo;short		height;short		menuProcID;CtlDataHdl	d;	d = (CtlDataHdl)(*c)->contrlData;	menuProcID = (*d)->menuProcID;	if (menuProcID == textMenuProc) {		GetFontInfo(&fInfo);		height = fInfo.ascent + fInfo.descent + fInfo.leading;		leftEdge = (*c)->contrlRect.left+StringWidth((*c)->contrlTitle);		m = (*d)->popMenu;		CalcMenuSize(m);		SetRect(r,leftEdge,(*c)->contrlRect.top,					leftEdge+(*m)->menuWidth+2,(*c)->contrlRect.top+height+1);	} else {		GetItemRect(c,(*c)->contrlMax,(*c)->contrlMin,r);	}	if (r->bottom > (*c)->contrlRect.bottom -1)		r->bottom = (*c)->contrlRect.bottom -1;	if (r->right > (*c)->contrlRect.right -1)		r->right = (*c)->contrlRect.right -1;}/*** *	Get the box surrounding the pop-up box and its title ***/void	GetCtlRect(ControlHandle c,Rect *r){Rect	boxRect;Rect	titleRect;	GetBoxRect(c,&boxRect);	GetTitleRect(c,&titleRect);	UnionRect(&boxRect,&titleRect,&r);	SetRect(r,r->left,r->top,r->right+1,r->bottom+1);}/*** *	Recursive routine to install a menu and its sub-menus, if any. It is *	only called once (from doInitCntl()) ***/void	InstallMenus(short rsrcID){MenuHandle	mh;short		ni;short		i;short		c;	mh = GetMenu(rsrcID);	InsertMenu(mh,hierMenu);	ni = CountMItems(mh);	for(i=1;i<=ni;i++) {		GetItemCmd(mh,i,&c);		if (c == hMenuCmd) {			GetItemMark(mh,i,&c);			InstallMenus((short)c);		}	}}/*** *	Recursive routine to remove a menu and its sub-menus, if any. It is *	only called once (from doDispCntl()) ***/void	RemoveMenus(short menuID){MenuHandle	mh;short		ni;short		i;short		c;	mh = GetMHandle(menuID);	ni = CountMItems(mh);	for(i=1;i<=ni;i++) {		GetItemCmd(mh,i,&c);		if (c == hMenuCmd) {			GetItemMark(mh,i,&c);			RemoveMenus(c);		}	}	DeleteMenu(menuID);	ReleaseResource(mh);}/*** *	Make the given string fir in the given box. ***/void	ShrinkString(unsigned char *s,Rect *r){short	s_pix;short	s_len;short	room;	room = (r->right - r->left) - L_PIXELS;	if (room < 0) {				// paßt der String GAR NICHT?		room = 0;		s[0] = 0;				// dann String ganz löschen	}	s_pix = StringWidth(s);		// Länge des Strings in Pixeln	if (s_pix > room) {			// genug Platz? Ja! => fertig		s_len = s[0];			// Stringlänge in Zeichen		room -= CharWidth('…');	// ein Füllzeichen kommt hinter den String		do {			s_pix -= CharWidth(s[s_len--]);	// abziehen, bis der Platz reicht		} while((s_pix < room) || (s[0] == 0));		s_len++;		s[s_len] = '…';			// Füllzeichen hinter den String		s[0] = s_len;			// neue Stringlänge	}}/*** *	Draw the title of the pop-up menu control ***/void	DrawTitle(ControlHandle c){Rect		titleRect;CtlDataHdl	d;FontInfo	fInfo;short		baseline;	d = (CtlDataHdl)(*c)->contrlData;	if ((*d)->hasColorQD) {		if ((*c)->contrlHilite == titlePart) {			RGBForeColor(&(*d)->wContColor);			RGBBackColor(&(*d)->mTitleColor);		} else {			RGBForeColor(&(*d)->mTitleColor);			RGBBackColor(&(*d)->wContColor);		}	}	GetTitleRect(c,&titleRect);	EraseRect(&titleRect);	GetFontInfo(&fInfo);	baseline = (*c)->contrlRect.top + fInfo.ascent;	MoveTo(titleRect.left+1,baseline);	DrawString((*c)->contrlTitle);	if ((*d)->hasColorQD) {			RGBForeColor(&(*d)->wFgColor);			RGBBackColor(&(*d)->wBgColor);	} else {		if ((*c)->contrlHilite == titlePart)			InvertRect(&titleRect);	}}/*** *	Draw the shadow around the pop-up box of the pop-up menu control ***/void	DrawDropShadow(ControlHandle c,Rect *r){CtlDataHdl	d;	d = (CtlDataHdl)(*c)->contrlData;	if ((*d)->hasColorQD) {		RGBForeColor(&(*d)->mTitleColor);		RGBBackColor(&(*d)->mTitleColor);	}	MoveTo(r->right,r->top+2);	LineTo(r->right,r->bottom);	LineTo(r->left+2,r->bottom);	if ((*d)->hasColorQD) {		RGBForeColor(&(*d)->wFgColor);		RGBBackColor(&(*d)->wBgColor);	}}/*** *	Draw the pop-up box of the pop-up menu control. Also draw drop shadow ***/void	DrawPopBox(ControlHandle c,long vcLong){Rect		r;Str255		itemStr;CtlDataHdl	d;FontInfo	fInfo;short		baseline;short		menuProcID;	d = (CtlDataHdl)(*c)->contrlData;	menuProcID = (*d)->menuProcID;	if (menuProcID == textMenuProc) {		if ((*d)->hasColorQD) {			RGBForeColor(&(*d)->wFgColor);			RGBBackColor(&(*d)->wBgColor);		}		GetBoxRect(c,&r);		SetPt(&botRight(r),r.right+2,r.bottom+2);		EraseRect(&r);		SetPt(&botRight(r),r.right-2,r.bottom-2);		GetItem(GetMHandle((*c)->contrlMax),(*c)->contrlMin,&itemStr);		ShrinkString(itemStr,&r);		if ((*d)->hasColorQD) {			RGBForeColor(&(*d)->mTitleColor);			RGBBackColor(&(*d)->wBgColor);		}		FrameRect(&r);		GetFontInfo(&fInfo);		baseline = (*c)->contrlRect.top + fInfo.ascent;		if ((*d)->hasColorQD) {			RGBForeColor(&(*d)->iNameColor);		}		MoveTo(r.left+L_PIXELS,baseline);		DrawString(itemStr);		if ((*d)->hasColorQD) {			RGBForeColor(&(*d)->wFgColor);			RGBBackColor(&(*d)->wBgColor);		}	} else {		GetBoxRect(c,&r);		DrawMenuItem(c,(*c)->contrlMax,(*c)->contrlMin,&r);	}	DrawDropShadow(c,&r);}/*** *	Invert the pop-up menu control´s title ***/void	DrawDisabled(ControlHandle c){PatHandle	greyPat;Rect		r;	greyPat = (PatHandle)GetResource('PAT ',GREY);	PenPat(*greyPat);	ReleaseResource(greyPat);	PenMode(patBic);	GetCtlRect(c,&r);	PaintRect(&r);}/*** *	Save the current drawing environment ***/void	SaveState(ControlHandle c,StateRec *s){CtlDataHdl	d;	GetPort(&s->savePort);	SetPort((*c)->contrlOwner);	s->oldClip = NewRgn();	s->newClip = NewRgn();	GetClip(s->oldClip);	RectRgn(s->newClip,&(*c)->contrlRect);	SectRgn(s->oldClip,s->newClip,s->newClip);	SetClip(s->newClip);	GetPenState(&s->savePen);	PenNormal;	d = (CtlDataHdl)(*c)->contrlData;	HLock(d);	GetMenuColors(c,d);	HUnlock(d);}/*** *	Restore the saved drawing environment ***/void	RestoreState(ControlHandle c,StateRec *s){	SetClip(s->oldClip);	SetPenState(&s->savePen);	SetPort(s->savePort);	DisposeRgn(s->oldClip);	DisposeRgn(s->newClip);}/*** *	Draw the pop-up menu box and title ***/void	doDrawCntl(ControlHandle c,long vcLong,long param){	if ((*c)->contrlVis == VISIBLE) {		DrawTitle(c);		DrawPopBox(c,vcLong);		if ((*c)->contrlHilite == INACTIVE)			DrawDisabled(c);	}}/*** *	Determine in which part of the control (if any) the given point *	(in ´param´) lies. ***/long	doTestCntl(ControlHandle c,Point param){Rect	r;long	ret = NOT_IN_CTL;	if ((*c)->contrlVis == VISIBLE) {		GetBoxRect(c,&r);		if (PtInRect(param,&r))			ret = inPopUpBox;	}	return(ret);}/*** *	Control Region berechnen ***/void	doCalcCntlRgn(ControlHandle c,long param){Rect	r;	GetBoxRect(c,&r);	RectRgn((RgnHandle)param,&r);}/*** *	Thump Region berechnen ***/void	doCalcThumbRgn(ControlHandle c,long param){	SetEmptyRgn((RgnHandle)param);}/*** *	Control Regionen berechnen ***/void	doCalcCRgns(ControlHandle c,long param){	if (BitAnd(param,0x80000000) == 0x80000000) {		param = BitAnd(param,0x0FFFFFFF);		doCalcThumbRgn(c,param);	} else {		param = BitAnd(param,0x7FFFFFFF);		doCalcCntlRgn(c,param);	}}/*** *	Control initialisieren ***/void	doInitCntl(ControlHandle c,long vcLong){MenuHandle	popMenu;MenuHandle	dfltMenu;Rect		ctlRect;CtlDataHdl	d;SysEnvRec	world;OSErr		err;char		markChar;short		menuProcID;	d = (CtlDataHdl)NewHandleClear(sizeof(CtlDataRec));	err = SysEnvirons(1,&world);	(*d)->hasColorQD = world.hasColorQD;	(*c)->contrlData = (Handle)d;	popMenu = (MenuHandle)GetResource('MENU',(*c)->contrlValue);	(*d)->menuProcID = HiWord((long)(*popMenu)->menuProc);	InstallMenus((*c)->contrlValue);	popMenu = GetMHandle((*c)->contrlValue);	(*d)->popMenu = popMenu;	if ((BitAnd(vcLong,mRes)==mRes)&&((*c)->contrlRfCon != 0L))		AddResMenu(popMenu,(OSType)(*c)->contrlRfCon);	if (BitAnd(vcLong,mRes)==mRes) {		dfltMenu = GetMHandle((*c)->contrlMax);		GetItemMark(dfltMenu,(*c)->contrlMin,&markChar);		if (markChar == noMark) {			markChar = checkMark;			SetItemMark(dfltMenu,(*c)->contrlMin,markChar);		}		(*d)->markChar = markChar;	}	if (world.hasColorQD)		InitColorInfo(c,d);	(*c)->contrlAction = (Ptr)-1L;	if ((*d)->hasColorQD) {		RGBForeColor(&(*d)->wFgColor);		RGBBackColor(&(*d)->wBgColor);	}	EraseRect(&(*c)->contrlRect);}/*** *	Do any de-allocation required for the given control ***/void	doDispCntl(ControlHandle c,long VarCode){MenuHandle	popMenu;CtlDataHdl	d;	d = (CtlDataHdl)(*c)->contrlData;	popMenu = (*d)->popMenu;	RemoveMenus((*popMenu)->menuID);	DisposHandle(d);					// das wurde wohl vergessen…}/*** *	This is the default action procedure for all controls of this type. *	TrackControl() will place the value inPopBox in contrlHilite before *	calling doAutoTrack, so the old value will be lost before we can save *	it here. ***/void	doAutoTrack(ControlHandle c,long vcLong,long param){MenuHandle		popMenu;short			menuResult;short			menuID;short			menuItem;Rect			r;Point			p;short			def;MCTableHandle	saveTable;CtlDataHdl		d;	(*c)->contrlHilite = titlePart;	DrawTitle(c);	GetBoxRect(c,&r);	SetPt(&p,r.left,r.top);	LocalToGlobal(&p);	d = (CtlDataHdl)(*c)->contrlData;	popMenu = (*d)->popMenu;	if ((*c)->contrlMax == (*popMenu)->menuID)		def = (*c)->contrlMin;	else		def = 1;	menuResult = PopUpMenuSelect(popMenu,p.v,p.h+1,def);	menuID = HiWord(menuResult);	menuItem = LoWord(menuResult);	if ((menuID<0)&&((menuItem!=(*c)->contrlMax)||(menuItem!=(*c)->contrlMin))) {		if (BitAnd(vcLong,mCheck)==mCheck) {			SetItemMark(GetMHandle((*c)->contrlMax),(*c)->contrlMin,noMark);			SetItemMark(GetMHandle(menuID),menuItem,(*d)->markChar);		}		SetCtlMax(c,menuID);		SetCtlMin(c,menuItem);		DrawPopBox(c,vcLong);	}}