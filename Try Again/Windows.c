#include "GlobalDefines.h"#include "Windows.h"#include "GeosMore.h"#include "GlobalLib.h"#include "GeosMore.h"#include "Utilities.h"#include "WindowsMenu.h"#include "WindowsGlobal.h"#include "GlobalStruct.h"#include "DoEvent.h"#include "DialogLib.h"#include "LongControl.h"#include "TMenus.h"#include "WindElement.h"pascal void	ScrollProc(ControlHandle c,short thePart);void		SetDeltaSlider(WindPtr w,long xd,long yd);void		ScrollWindow(WindPtr w,long x,long y);void		GetVisRect(WindPtr w,Rect *r);WindPtr		gTopFloat;					// das oberste Float (nil = keins)WindPtr		gTopWindow;					// das oberste Window (nil = keins)WindPtr		gMacWind;					// aktuelles Window bei Message#if GERDBoolean		gWindHilited;				// aktuelles Window aktiv? true = Ja!#endifBoolean		gFirstWindowFlag = false;	// true, wenn ein Window zum ersten mal geöffnetWindPtr		gWunschwind = nil;			// für “InstantActive”/*** *	Window-Library init ***/void	WindowInit(void){	gTopFloat = 0;	gTopWindow = 0;	gC = (ClassPtr)NewPtrClear(sizeof(Class)*MAXCLASSES);}/*** *	Routine, welche eine Window-Routine ausführt. false, wenn eine Routine *	vorhanden ist und ausgeführt wurde. ***/Boolean		WindowAktion3(REG WindPtr w,short offset,long (*param)(),long p2,long p3){GrafPtr		savePort;			// geretteter GrafportBoolean		ret;				// RückgabewertRgnHandle	saveClip;			// gerettetes Clip-RechteckRect		r;					// temp.RechteckDocHandle	saveDoc = gDoc;		// aktuelles Dokument merkenPoint		p;					// lokale MauspositionWindPtr		saveMacWind = gMacWind;#if GERDBoolean		saveHilited	= gWindHilited;#endif	if(w == nil) return true;	if(offset >= 0)		if((long*)((char*)w + offset) == NULL) return true;	if (!IsAppWindow((WindowPtr)w)) return(true);	// Fenster gehört uns nicht!	gMacWind = w;					// aktuelles Window#if GERD	gWindHilited = ((WindowPeek)w)->hilited;	// Hilited-Flag setzen#endif	if (!BTstQ(w->Typ,NoParent))	// Parent vorhanden?		SetDoc(w->Doc);				// dazugehöriges Dokument setzen	GetPort(&savePort);				// aktuellen GrafPort retten	SetPort((WindowPtr)w);			// Grafport auf das Window	if (!BTstQ(w->Typ,noOrigin)) {		SetOrigin(oGetCtlValue(w->HSlider),oGetCtlValue(w->VSlider));	// Ursprung verschieben		w->counter++;	}	saveClip = NewRgn();	if(!saveClip)					// reichte der Speicher nicht?		saveClip = gUtilRgn;		// dann irgendeine Region nehmen	GetClip(saveClip);				// gerettetes Clipping	r = ((WindowPtr)w)->portRect;	if (!BTstQ(w->Typ,noHSlider))	r.bottom -= SBarWidth-1;	if (!BTstQ(w->Typ,noVSlider))	r.right -= SBarWidth-1;	ClipRect(&r);					// Clipping setzen#if GERD	p.h = gMausx;	p.v = gMausy;	GlobalToLocal(&p);				// Umrechnen in lokale Koordinaten	mx = p.h;	my = p.v;	{ G(WAktion)(&r); }#endif	if (offset == -1)				// Sonderfall?		ret = (*(short(*)(long,long))param)(p2,p3);	else		ret = (**(long(**)(long,long,long))((char*)w+offset))((long)param,p2,p3);	SetClip(saveClip);	DisposeRgn(saveClip);	if (!BTstQ(w->Typ,noOrigin)) {		if (!--w->counter)			SetOrigin(0,0);			// Ursprung zurücksetzen	}	SetPort(savePort);				// Grafport zurücksetzen	if (!BTstQ(w->Typ,NoParent))	// Parent vorhanden?		SetDoc(saveDoc);	gMacWind = saveMacWind;#if GERD	gWindHilited = saveHilited;#endif	return(ret);}/*** *	GetWindowList * *	freezed die aktuelle Windowverkettung in einer Liste ***/WindPtr		*GetWindowList(void){register WindowPtr	w = LMGetWindowList();	// Listenstruktur aller Windowsregister short		anz = 2;			// ein Leerfeld Platz lassenregister WindPtr	*wList;register WindPtr	*wL;	while (w) {					// Ende der Windowliste?		if (IsAppWindow(w))			anz++;				// Windows zählen		w = (WindowPtr)((WindowPeek)w)->nextWindow;	// Nein: ein Window weiter	}	wList = (WindPtr*)NewPtr(sizeof(long) * anz);	if (!wList) return(0);	wL = wList + 1;	w = LMGetWindowList();		// Listenstruktur aller Windows	while (w) {					// Ende der Windowliste?		if (IsAppWindow(w))			*wL++ = (WindPtr)w;	// Window in Liste eintragen		w = (WindowPtr)((WindowPeek)w)->nextWindow;	// Nein: ein Window weiter	}	*wList = (WindPtr)wL;		// erster Eintrag = Ptr hinter das hinterste Window	*wL = 0;					// Liste abschließen	return(wList);}/*** *	Für alle Windows des Dokumentes d “funk” aufrufen. ***/void	ForAllWindows(REG WindCallbackProcPtr funk,REG DocHandle d,REG short flag){WindPtr		w = (WindPtr)LMGetWindowList();	// Listenstruktur aller Windows	while (w) {							// Ende der Windowliste?		if (IsAppWindow((WindowPtr)w)) {			DocHandle dh = w->Doc;			if (((flag==false)&&(dh == d)&&(dh))||	// gehört das Window zu diesem Dokument?				(d == nil)||						// oder ist das Dokument egal?				((flag==true)&&(dh != d)&&(dh)))	// alle Windows, die nicht zu diesem Dokument gehören?				if (WindowAktion(w,-1,(long)funk)) return;	// Struct-Handle, WindowHandle		}		w = (WindPtr)((WindowPeek)w)->nextWindow;	// ein Window weiter	}}/*** *	Ist das Window ein Floating-Window? ***/Boolean	IsFloating(REG WindPtr w){	if (!IsAppWindow((WindowPtr)w)) return(false);	// keins von unseren Fenstern => kein Float	return(BTstQ(w->Typ,FloatWindow)!=false);}/*** *	Ist das Window ein Dialog-Window? ***/Boolean	IsDialog(REG WindPtr w){	if (!IsAppWindow((WindowPtr)w)) return(false);	// keins von unseren Fenstern => kein Dialog	return(BTstQ(w->Typ,DialogWindow)!=false);}/*** *	Alle Floats ausschalten ***/Boolean	HideFloats(void){REG WindPtr		w = gMacWind;	if (IsFloating(w)&&!(BTstQ(w->Typ,NoHideFloat)))	// ein Float?		HideWind(w);	return(false);}/*** *	Alle Floats anschalten ***/Boolean	ShowFloats(void){	if (IsFloating(gMacWind)) {		ShowWind(gMacWind);	}	return(false);}/*** *	Alle Floats (ohne Parent und die zum akt. Parent) anschalten ***/Boolean	Show2Floats(void){	if (IsFloating(gMacWind)&&((gMacWind->Doc==nil)||(gMacWind->Doc==gDoc))) {		ShowWind(gMacWind);	}	return(false);}/*** *	Windowhandle des letzten Floating-Windows zurückgeben ***/WindPtr	LastFloat(void){REG WindPtr	w = gTopFloat;			// das oberste WindowREG WindPtr	lastFloat = nil;	while (w) {		if (!IsFloating(w)) break;	// kein Floating-Window mehr?		lastFloat = w;		w = (WindPtr)((WindowPeek)w)->nextWindow;	}	return(lastFloat);}/*** *	Windowhandle des letzten eigenen Windows zurückgeben ***/short	WindowCount;WindPtr	LastWindow(void){WindowPeek	w = (WindowPeek)LMGetWindowList();WindPtr		ownw = nil;	WindowCount = 0;	while(w) {		if (IsAppWindow((WindowPtr)w)) ownw = (WindPtr)w;	// letztes eigenes Window merken		WindowCount++;		w = w->nextWindow;				// und ein Window weiter…	}	return(ownw);}/*** *	Windowhandle des ersten sichtbaren Windows zurückgeben ***/WindPtr	FirstVisibleWindow(Boolean flag){WindowPeek	w = (WindowPeek)LMGetWindowList();	while(w) {		if (IsAppWindow((WindowPtr)w)) { // eigenes Window?			if (w->visible) {		// Window auch sichtbar?				if (flag) {			// true: Floats suchen					if (IsFloating((WindPtr)w)) return((WindPtr)w);				} else {			// false: normales Window suchen					if (!IsFloating((WindPtr)w)) return((WindPtr)w);				}			}		}		w = w->nextWindow;			// und ein Window weiter…	}	return((WindPtr)w);}/*** *	SelectWind() : Ersatzaufruf für SelectWindow(), da wir Floats haben. ***/void	SelectWind(WindPtr w){WindPtr	oldw;Boolean	aDAIsActive	= IsDAWindow(FrontWindow());	gWunschwind = nil;	if (!w) return;							// kein Window selecten	if (((w == gTopFloat)||(w == gTopWindow)) && !aDAIsActive) return;	if (aDAIsActive) {						// DA ist aktiv, wird aber inaktiv		WindowPeek	wl = (WindowPeek)LastWindow();		WindowPtr	theDA;		while(IsDAWindow(theDA = FrontWindow())) {			SendBehind(theDA,(WindowPtr)wl);			wl = (WindowPeek)theDA;		}	}	if (IsDialog(w)) {						// eine Dialogbox?		if (!((WindowPeek)w)->visible) {	// Window noch unsichtbar?			BringToFront((WindowPtr)w);		// dann unsichtbar in der Hierarchie nach vorne			ShowWindow((WindowPtr)w);		// und anschalten		} else {			SelectWindow((WindowPtr)w);		// sonst gleich selecten		}		if (!gTopWindow)					// altes Window deselecten			WActivate(gTopWindow,false);		gTopWindow = w;		WActivate(w,true);					// Window selecten		return;	} else if (IsFloating(w)) {				// ein Floating-Window?		if (w != gTopFloat) {				// Float noch nicht das oberste Window?			BringToFront((WindowPtr)w);		// Window nach vorne bringen			ShowHide((WindowPtr)w,true);	// Window darstellen			WActivate(w,true);				// Window selecten			gTopFloat = w;					// neues oberstes Float		}	} else {		oldw = gTopWindow;					// mometan noch oberes Window		if (w != oldw)			BringBehind((WindowPtr)w,(WindowPtr)LastFloat()); // Window hinter die Floats, bzw. nach vorne		ShowHide((WindowPtr)w,true);		// Window sichtbar		gTopWindow = w;						// neues oberstes Window		if (aDAIsActive) {			if (oldw) {				HiliteWindow((WindowPtr)oldw,false);			}		} else {			if (w != oldw)				WActivate(oldw,false);		// altes Window deaktivieren			WActivate(w,true);				// Window aktivieren		}	}	LMSetCurActivate(nil);					// keinen weiteren activate-Event}/*** *	Window sichtbar machen ***/void	ShowWind(WindPtr w){WindPtr	oldTop;	ShowHide((WindowPtr)w,true);			// Window anschalten	if (IsFloating(w)) {		WActivate(w,true);					// Window selecten		gTopFloat = FirstVisibleWindow(true);	// erstes passendes Float suchen	} else {		oldTop = gTopWindow;		gTopWindow = FirstVisibleWindow(false);	// erstes passendes Window suchen		if (gTopWindow == w) {				// Window nun getopped?			if (oldTop)				WActivate(oldTop,false);	// altes Window deaktivieren			WActivate(w,true);				// neues Window aktivieren		}	}}/*** *	oberstes Window selektieren ***/void	SelectTop(void){WindowPtr	frontWind;	gTopWindow = FirstVisibleWindow(false);	// erstes passendes Window suchen	frontWind = FrontWindow();		// erstes “echtes” oberes Window	if (IsDAWindow(frontWind)) {		SelectWindow((WindowPtr)frontWind);	// DA aktivieren		LMSetCurActivate(frontWind);	} else {		if (gTopWindow)				// neues Fenster aktivieren?			WActivate(gTopWindow,true);	// neues Window aktivieren	}}/*** *	Window unsichtbar machen ***/void	HideWind(WindPtr w){	ShowHide((WindowPtr)w,false);			// Window ausschalten	if (IsFloating(w)) {		WActivate(w,false);					// Window deaktivieren		if (w == gTopFloat) {				// lag dieses Float ganz oben?			gTopFloat = FirstVisibleWindow(true);	// erstes passendes Float suchen		}	} else {		WActivate(w,false);					// Window deaktivieren		if (w == gTopWindow) {				// Window war aktiv!!!			SelectTop();					// nächstes Hervorkramen		}	}}/*** *	DragWind() : Ersatzaufruf für DragWindow(), da wir Floats haben. ***/void	DragWind(WindPtr w,Point pnt,Rect *r){GrafPtr		savePort;long		newLoc;short		hDrag,vDrag;short		cmdFlag = vqkey() & 4;	// ≠0 : Command gedrückt//	DragWindow(w,pnt,r);			// Originalroutine	if (!WaitMouseUp()) {		SelectWind(w);				// damit das Window stets topped!		return;						// Maustaste nicht mehr gedrückt => raus	}#if 0	NewDragWindow((WindowPtr)w,pnt,r);	return;#else//	r->top = MAX(GetMBarHeight()+4,r->top);	GetPort(&savePort);				// GrafPort retten	SetPort(LMGetWMgrPort());		// GrafPort vom Window-Manager wählen	SetClip(GetGrayRgn());			// Desktop = Verschiebebereich	if (cmdFlag)	ClipAbove((WindowPtr)w);	// Hintergrund-Clipping	CopyRgn(((WindowPeek)w)->strucRgn,gUtilRgn);	newLoc = DragGrayRgn(gUtilRgn,pnt,r,r,noConstraint,nil);	if ((newLoc != 0x80008000L)&&(newLoc)) {	// neue Position?		Rect	rr;		rr = ((WindowPtr)w)->portBits.bounds;		// für Color QD		if (((CGrafPtr)w)->portVersion & 0x8000)			rr = (*(((CGrafPtr)w)->portPixMap))->bounds;		hDrag = ((WindowPtr)w)->portRect.left-rr.left+LoWord(newLoc);		vDrag = ((WindowPtr)w)->portRect.top-rr.top+HiWord(newLoc);		MoveWindow((WindowPtr)w,hDrag,vDrag,false);	}	SetPort(savePort);				// GrafPort zurücksetzen#endif	if (!cmdFlag)		SelectWind(w);				// Window selecten, wenn nötig}/*** *	Window aktivieren bzw. deaktivieren ***/#if USETEXTEDITvoid	teactiv(void);void	teactiv(void){	TEActivate(gTEHandle);}void	tedeactiv(void);void	tedeactiv(void){	TEDeactivate(gTEHandle);}#endifvoid	WActivate(WindPtr wind,Boolean mode){REG	short	flag;			// Hilite-Flaglong		Type;			// WindowtypRgnHandle	saveClip;		// gerettetes Clip-RechteckGrafPtr		savePort;		// geretteter Grafport	if (!IsAppWindow((WindowPtr)wind)) return;	// Window gehört nicht mir…	if (!((WindowPeek)wind)->visible) return;	// Window ist unsichtbar	GetPort(&savePort);	SetPort((WindowPtr)wind);				// GrafPort auf das Window	if (mode) {		flag = kCntlActive;					// aktiv		HiliteWindow((WindowPtr)wind,true);		WINDOW(wind,activ,(long)nil);#if USETEXTEDIT		if (gTEHandle && (wind==gTEWindow))			WindowAktion(wind,-1,(long)teactiv);	// Text-Edit aktiv#endif		if (!IsFloating(wind)) {			// Floats schalten Dokument nicht um (REKURSION!)			if (!BTstQ(wind->Typ,NoParent)) {	// Parent zum Window vorhanden?				if (!IsDialog(wind)) {					SetDoc(wind->Doc); 		// aktives Dokument gehört zum aktiven Window					SetDocFloats(gDoc);		// Floats dazu einschalten				}			}		}	} else {		flag = kCntlInactive;				// inaktiv		HiliteWindow((WindowPtr)wind,false);		WINDOW(wind,deactiv,(long)nil);#if USETEXTEDIT		if (gTEHandle && (wind==gTEWindow))			WindowAktion(wind,-1,(long)tedeactiv);	// Text-Edit aktiv#endif	}	Type = wind->Typ;						// in ein Register legen…	GetClip(gUtilRgn);						// gerettetes Clipping	ClipRect(&(((WindowPtr)wind)->portRect));	if (!BTstQ(Type,noSizer))		DrawGrowIcon((WindowPtr)wind);		// Sizer updaten	if (!BTstQ(Type,noHSlider))		oHiliteControl(wind->HSlider,flag);	// Slider en- disablen	if (!BTstQ(Type,noVSlider))		oHiliteControl(wind->VSlider,flag);	SetClip(gUtilRgn);	SetPort(savePort);}/*** *	Windowtitel neu setzen, dabei das “Windows”-Menü beachten! ***/void	SetWindowTitle(WindPtr wind,Str255 title){	if(IsFloating(wind)) return;		// bei Floats passiert nix…	if (gWindowMenu) {					// Window-Menü vorhanden?		if(gC[wind->class].type) {		// einziges Window der Klasse?			SetItem(gWindowMenu,MenuId(wind->class,wind),title);	// im Menü updaten		} else {			Str255	title2 = "\p  ";		// zwei Leerzeichen			ConcatPString(title2,title);	// Windownamen dranhängen			SetItem(gWindowMenu,MenuId(wind->class,wind),title2);	// im Menü updaten		}	}	SetWTitle(((WindowPtr)wind),title);	// Windowtitel setzen}/*** *	Window öffnen ***/WindPtr	OpenWind(REG LONG Type,Rect *r,Str255 title,REG short id,LONG w,LONG h){REG WindPtr		wind;			// die WindowhandleRect			tempRect;REG Handle		temp;WindowPtr		savePort;	if ((gC[id].type)&&(gC[id].count>0)) { // ist nur ein Fenster erlaubt?		WindowPeek	w;					// die zum Dokument gehörenden Windows schließen		w = (WindowPeek)LMGetWindowList();					// Handle des ersten Windows		while (w) {						// Ende der Windowliste?			if (IsAppWindow((WindowPtr)w)) {				if ((((WindPtr)w)->Doc == gDoc)&&	// gehört das Window zu diesem Dokument?					(((WindPtr)w)->class == id)) {	// und zu dieser Klasse					SelectWind((WindPtr)w);			// Window toppen					return(nil);		// Liste erneut durchgehen				}			}			w = w->nextWindow;			// Nein: ein Window weiter		}		return(nil);	}	temp = NewHandle(15000L);	if(MemError()||(!temp)) {#if GERDOPENErr:		alert(1,"[3][Not enough memory|to open Window!][OK]");#endif		return(nil);					// Speicher reicht nicht!	}	DisposHandle(temp);	wind = (WindPtr)NewPtrClear(sizeof(WindStruct));	wind->magic = WINDMAGIC;			// Magic einsetzen	wind->Typ = Type;					// Windowtyp merken	if (!BTstQ(Type,NoParent))			// kein Parent zum Window?		wind->Doc = gDoc;				// zum Window gehörendes Dokument	wind->MaxWidth = w; wind->MaxHeight = h;		// maximale Windowgröße merken	w += SBarWidth;	h += SBarWidth;	wind->ScrollH = 1; wind->ScrollPageH = 20;	wind->ScrollV = 1; wind->ScrollPageV = 20;	r->right = MIN(r->right-r->left,w)+r->left;	r->bottom = MIN(r->bottom-r->top,h)+r->top;	wind->class = id;					// Windowklasse	gC[id].count++;						// ein Fenster mehr offen	if (BTstQ(Type,DialogWindow))		// eine Dialogbox?		ResetDocFloats(nil);			// alle Floats ausschalten	if (BTstQ(Type,TrueDialog)) {		// ein “echter” Dialog?		gBehind = BTstQ(Type,FloatWindow)?(WindowPtr)-1L:(WindowPtr)0L;		wind = (WindPtr)GetCenteredDialog(Type & 0xFFFF,(DialogPtr)wind);		gBehind = (WindowPtr)-1;		MoveWindow((WindowPtr)wind,r->left,r->top,false);		SetWTitle((WindowPtr)wind,title);	} else {		WindowPtr	behind = BTstQ(Type,FloatWindow)?(WindowPtr)-1L:(WindowPtr)0L;#if USEWINDELEMENT		// WDEF-Funktion bei eigenen Randelementen		if(!BTstQ(Type,FloatWindow)) Type = (129 * 16) | (Type & 0xFFFF000F);#endif		if (gQDVersion)			wind=(WindPtr)NewCWindow(wind,r,(StringPtr)title,false,Type & 0xFFFFL,							behind,true,0L);	// Standard-Window definieren		else			wind=(WindPtr)NewWindow(wind,r,(StringPtr)title,false,Type & 0xFFFFL,							behind,true,0L);	// Standard-Window definieren	}	if (!wind) {#if GERD		goto OPENErr;#else		return(nil);#endif	}	GetPort(&savePort);	SetPort((WindowPtr)wind);			// Ausgabe in das neue Window	{ G(WindInit)(wind); }				// Grafport initialisieren	if (!BTstQ(Type,noHSlider)) {		SetRect(&tempRect,0,0,0,0);		wind->HSlider = oNewControl((WindowPtr)wind,&tempRect,"\p",true,						0,0,wind->MaxWidth,scrollBarProc,(long)nil);	}	if (!BTstQ(Type,noVSlider)) {		SetRect(&tempRect,0,0,0,0);		wind->VSlider = oNewControl((WindowPtr)wind,&tempRect,"\p",true,						0,0,wind->MaxHeight,scrollBarProc,(long)nil);	}	FixScrollBars(wind);				// Scroll-Bars anpassen	AdjustWindow(wind);					// Window-Variablen updaten	if (!BTstQ(Type,noShowWind))		SelectWind(wind);				// Window wird aktiv	AdjustMenus();						// evtl. Menüs disablen	SetPort(savePort);	if ((gWindowMenu)&&(title[0]))		// nur wenn das Window einen Namen hat	{									// Windowklasse suchen		short	i;						// aktueller Index		Str255	title2 = "\p  ";		// zwei Leerzeichen		ConcatPString(title2,title);	// Windownamen dranhängen		i = MenuId(id,nil);				// “echte” Menü-ID der Klasse ermitteln		if (gC[id].type)			SetItem(gWindowMenu,i,title); // nur ein Window pro Klasse		else {			InsMenuItem(gWindowMenu,"\p ",i);			SetItem(gWindowMenu,i+1,title2);			gWMenuOffset++;				// ein Eintrag mehr im Windows-Menü		}	}	gFirstWindowFlag = true;			// erstes Window geöffnet, Idle-Events starten	return(wind);}/*** *	Alle Windows eines Dokumentes schließen ***/void		CloseWindAll(DocHandle d){WindowPeek	w;					// die zum Dokument gehörenden Windows schließen	again:	w = (WindowPeek)LMGetWindowList();				// Handle des ersten Windows	while (w) {					// Ende der Windowliste?		if (IsAppWindow((WindowPtr)w)) {			if (((WindPtr)w)->Doc == d)	{	// gehört das Window zu diesem Dokument?				CloseWind((WindPtr)w);		// Window schließen				goto again;			// Liste erneut durchgehen			}		}		w = w->nextWindow;		// Nein: ein Window weiter	}}/*** *	Window “wind” schließen. ***/void	CloseWind(WindPtr wind){Str255	title;Boolean	isFloat = IsFloating(wind);	if (!wind) return;	if (IsDAWindow((WindowPtr)wind)) {		// ein DA?		CloseDeskAcc(((WindowPeek)wind)->windowKind);	// das DA schließen	} else {		if (BTstQ(wind->Typ,DialogWindow))	// eine Dialogbox?			SetDocFloats(nil);				// alle Floats ausschalten		WINDOW(wind,close,nil);			// Window wird geschlossen#if USETEXTEDIT		TEExit();#endif		HideWind(wind);						// und das Window ausschalten, deactivate		if (gC[wind->class].type)			// ist nur ein Fenster erlaubt?			gC[wind->class].count--;		// ein Fenster weniger offen		GetWTitle((WindowPtr)wind,title);		if ((gWindowMenu)&&(title[0]))		{									// Windowklasse suchen			short	id = MenuId(wind->class,wind);	// aktueller Index			if (id) {				if (gC[wind->class].type)	// einziges Window dieser Klasse?					SetItem(gWindowMenu,id,gC[wind->class].name);				else {					DelMenuItem(gWindowMenu,id);					gWMenuOffset--;				}			}		}		wind->magic = 0L;					// ID sicherheitshalber löschen		if (BTstQ(wind->Typ,TrueDialog)) {	// ein “echter” Dialog?			DisposeDialog((DialogPtr)wind);		} else {			oKillControls((WindowPtr)wind);			DisposeWindow((WindowPtr)wind);	// Window entfernen		}		SelectWind((isFloat)?gTopFloat:gTopWindow);	// neues Window toppen		AdjustMenus();						// evtl. Menüs disablen	}}/*** *	Update-Event aufgetreten, Window zeichnen ***/#if USETEXTEDITvoid	tedraw(void);void	tedraw(void){	EraseRect(&((*gTEHandle)->viewRect));	TEUpdate(&((*gTEHandle)->viewRect),gTEHandle);}#endifBoolean	WUpdate(WindPtr wind){GrafPtr		savePort;	if (!IsAppWindow((WindowPtr)wind)) return(false);	// ein DA?	GetPort(&savePort);	SetPort((WindowPtr)wind);				// GrafPort auf das Window	BeginUpdate((WindowPtr)wind);	if (!EmptyRgn(((WindowPtr)wind)->visRgn)) {	// Inhalt überhaupt sichtbar?		if (!BTstQ(wind->Typ,noSizer))			DrawGrowIcon((WindowPtr)wind);	// Sizer zeichnen		if (BTstQ(wind->Typ,TrueDialog))	// ein “echter” Dialog?			DrawDialog((DialogPtr)wind);		oDrawControls((WindowPtr)wind);		// alle Controls zeichnen		WINDOW(wind,draw,nil);		wind->RedrawFlag = true;			// Redraw ist erfolgt#if USETEXTEDIT		if (gTEHandle && (wind==gTEWindow)) WindowAktion(wind,-1,(long)tedraw);	// Text-Edit aktiv#endif	}	EndUpdate((WindowPtr)wind);	SetPort(savePort);	return(true);}/*** *	Window wurde in der Größe verändert, bzw. ein Slider wurde bewegt ***/void	AdjustWindow(WindPtr wind){	WINDOW(wind,adjust,(long)wind);}/*** *	Scrollbars auf aktuelle Windowgröße umrechnen und neu zeichnen (Sizer bei der Gelegenheit auch) ***/void	FixScrollBars(WindPtr w){ControlHandle	c;short			i = SBarWidth-1;		// Offset für den V-Slidershort			j = SBarWidth-1;		// Offset für den H-SliderLONG			Type;					// Typ-Flags vom aktuellen Window (in einem Register…)GrafPtr			oldPort;				// geretteter GrafportRect			r;short			offseth,offsetv;	GetPort(&oldPort);	SetPort((GrafPtr)w);					// Grafport auf das Window	Type = w->Typ;							// in ein Register legen…	if (!BTstQ(Type,noSizer)) {		DrawGrowIcon((WindowPtr)w);			// Sizer updaten	} else {		if (BTstQ(Type,noVSlider))			// kein V-Slider?			j = 0;							// dann den H-Slider verbreitern		if (BTstQ(Type,noHSlider))			// kein H-Slider?			i = 0;							// dann den V-Slider verlängern	}	GetVisRect(w,&r);	offseth = ((WindowPtr)w)->portRect.left;	offsetv = ((WindowPtr)w)->portRect.top;	SetOrigin(0,0);							// Ursprung zurücksetzen#if 0	Wird das Windowmaximum “von Hand” runtergesetzt, muß ggf. die Windowgröße angepaßt werden	if ((w->MaxHeight > ((WindowPtr)w)->portRect.bottom - ((WindowPtr)w)->portRect.top - SBarWidth)||		(w->MaxWidth > ((WindowPtr)w)->portRect.right - ((WindowPtr)w)->portRect.left - SBarWidth)) {		SizeWind(w,w->MaxWidth,w->MaxHeight,true);	}#endif	// erstmal beide Controls ausschalten	if (!BTstQ(Type,noVSlider)) oHideControl(w->VSlider);	if (!BTstQ(Type,noHSlider)) oHideControl(w->HSlider);	// und nun einzeln neu positionieren	if (!BTstQ(Type,noVSlider)) {		c = w->VSlider;						// ControlHandle des V-Sliders		oMoveControl(c,((WindowPtr)w)->portRect.right-(SBarWidth-1),-1);		oSizeControl(c,SBarWidth,(((WindowPtr)w)->portRect.bottom + 1)-(((WindowPtr)w)->portRect.top - 1)-i);		i = ((WindowPtr)w)->portRect.bottom - ((WindowPtr)w)->portRect.top - SBarWidth;		if (i >= w->MaxHeight)			oSetCtlMax(c,0);		else			oSetCtlMax(c,w->MaxHeight - (r.bottom - r.top));		oShowControl(c);	}	if (!BTstQ(Type,noHSlider)) {		c = w->HSlider;						// ControlHandle des H-Sliders		oMoveControl(c,-1,((WindowPtr)w)->portRect.bottom-(SBarWidth-1));		oSizeControl(c,(((WindowPtr)w)->portRect.right + 1)-(((WindowPtr)w)->portRect.left - 1)-j,SBarWidth);		i = ((WindowPtr)w)->portRect.right - ((WindowPtr)w)->portRect.left - SBarWidth;		if (i >= w->MaxWidth)			oSetCtlMax(c,0);		else			oSetCtlMax(c,w->MaxWidth - (r.right - r.left));		oShowControl(c);	}	SetOrigin(offseth,offsetv);				// Ursprung wieder setzen	SetPort(oldPort);}/*** *	Sichtbares Rechteck (Sliderpositionen) vom Window zurückgeben ***/void	GetVisRect(REG WindPtr w,REG Rect *r){	*r = (*(((WindowPtr)w)->visRgn))->rgnBBox;	OffsetRect(r,oGetCtlValue(w->HSlider),oGetCtlValue(w->VSlider));	if (!BTstQ(w->Typ,noVSlider)) r->bottom -= SBarWidth;	if (!BTstQ(w->Typ,noHSlider)) r->right -= SBarWidth;}/*** *	SizeWind() : Ersatzaufruf für SizeWindow(), da wir Floats haben. ***/void	SizeWind(REG WindPtr wind,REG LONG w,REG LONG h,Boolean flag){REG LONG	dw,dh;REG LONG	typ;REG LONG	sw,sh;	if (!wind) return;							// WindowPtr = nil => raus	if (!(w|h)) return;							// wenn w & h = 0 => nix tun!	typ = wind->Typ;	sw = w; if (!BTstQ(typ,noHSlider)) sw -= SBarWidth;	sh = h; if (!BTstQ(typ,noVSlider)) sh -= SBarWidth;	// maximale Windowgröße fix?	if (sw > wind->MaxWidth) {		if (!BTstQ(typ,MaxW))			wind->MaxWidth = sw;				// neue Maximalgröße setzen		else {			w = sw = wind->MaxWidth;			if (!BTstQ(typ,noHSlider)) w += SBarWidth;		}	}	if (sh > wind->MaxHeight) {		if (!BTstQ(typ,MaxH))			wind->MaxHeight = sh;		else {			h = sh = wind->MaxHeight;			if (!BTstQ(typ,noVSlider)) h += SBarWidth;		}	}	dw = sw + oGetCtlValue(wind->HSlider) - wind->MaxWidth;	if (dw < 0) dw = 0;	dh = sh + oGetCtlValue(wind->VSlider) - wind->MaxHeight;	if (dh < 0) dh = 0;	SizeWindow((WindowPtr)wind,w,h,flag);		// Windowgröße ändern	FixScrollBars(wind);						// Scroll-Bars anpassen	AdjustWindow(wind);							// Window-Variablen updaten	ScrollWindow(wind,-dw,-dh);//	(wind,dh,dh);					// Slider neu positionieren//	InvalRect(&((WindowPtr)w)->portRect);		// Gesamtes Window neuzeichnen	WUpdate(wind);								// Windowinhalt updaten}void		ScrollWindow(WindPtr w,long x,long y){Rect	r;		if (BTstQ(w->Typ,NoAutoscroll)) return;	// Window nicht automatisch scrollen!	if (!(x|y)) return;					// Sliderwerte unverändert => raus	r = ((WindowPtr)w)->portRect;		// Arbeitsbereich des Windows errechnen	if ((x > 32767L)||(y > 32767L)||(x < -32768L)||(y < -32768L)) {		InvalRect(&r);					// Gesamtes Window neuzeichnen	} else {		if (!BTstQ(w->Typ,noVSlider))			r.right -= SBarWidth-1;		// V-Slider nicht scrollen		if (!BTstQ(w->Typ,noHSlider))			r.bottom -= SBarWidth-1;	// H-Slider nicht scrollen		ScrollRect(&r,-x,-y,gUtilRgn);	// Bereich scrollen		InvalRgn(gUtilRgn);				// Windoregion neu zeichnen	}}/*** *	beide Slider versetzen. Window-Redraw sofort machen. ***/void		SetDeltaSlider(WindPtr w,long xd,long yd){ControlHandle	ch = w->HSlider;ControlHandle	cv = w->VSlider;long			x = oGetCtlValue(ch);	// temp.Sliderwertlong			y = oGetCtlValue(cv);Rect			r;						// Arbeitsbereich des WindowsRgnHandle		uRgn;					// upzudatende Region	oSetCtlValue(ch,x + xd);			// neuen H-Sliderwert setzen	oSetCtlValue(cv,y + yd);			// neuen V-Sliderwert setzen	ScrollWindow(w,oGetCtlValue(ch) - x,oGetCtlValue(cv) - y);	WUpdate(w);							// Windowinhalt updaten}/*** *	Slider wurde bewegt (Funktion wird von TrackControl aufgerufen) ***/pascal void	ScrollProc(ControlHandle c,short thePart){WindPtr	w		= (WindPtr)(*c)->contrlOwner;	// Window, in dem das Control liegtBoolean	flag	= w->HSlider == c;		// true, wenn horizontaler Sliderlong	offset	= 0;					// Scrolloffset = 0 (nicht gescrollt)long	xd,yd;Rect	r;	switch(thePart) {					// angeklicktes Control-Element	case	inPageDown:	case	inPageUp:			GetVisRect(w,&r);			if (flag) {				offset = w->ScrollPageH;				if (!offset) offset = r.right - r.left + 1;			} else {				offset = w->ScrollPageV;				if (!offset) offset = r.bottom - r.top + 1;			}			if (thePart == inPageUp) offset = - offset;			break;	case	inDownButton:	case	inUpButton:			offset = (flag)?w->ScrollH:w->ScrollV;			if (thePart == inUpButton) offset = - offset;			break;	}	if (flag) {							// Horizontaler Slider:		xd = offset;		yd = 0;	} else {							// Vertikaler Slider:		xd = 0;		yd = offset;	}	SetDeltaSlider(w,xd,yd);			// Slider versetzen}/*** *	Window-Sizer wurde angeklickt, Window nun ggf. vergrößern ***/void	WGrowClick(WindPtr wind,Point p){long		newSize;GrafPtr		oldPort;Rect		size;Rect		r = ((WindowPtr)wind)->portRect;// das Window-RechteckLONG		maxw = wind->MaxWidth;LONG		maxh = wind->MaxHeight;REG LONG	typ = wind->Typ;REG WORD	z32767 = 32767;	if (!BTstQ(typ,noVSlider)) maxh += SBarWidth;	if (!BTstQ(typ,noHSlider)) maxw += SBarWidth;	maxw = MIN(BTstQ(typ,MaxW)?maxw+1:z32767,z32767);	maxh = MIN(BTstQ(typ,MaxH)?maxh+1:z32767,z32767);	SetRect(&size,MIN_WINDOW_X,MIN_WINDOW_Y,maxw,maxh);	if (newSize = GrowWindow((WindowPtr)wind,p,&size)) {	// Größe verändert?		maxw = LoWord(newSize); maxh = HiWord(newSize);		GetPort(&oldPort);		SetPort((WindowPtr)wind);			// Grafport auf das Window		if (BTstQ(typ,noSmartSizer)) {			EraseRect(&r);					// Window komplett löschen			SizeWind(wind,maxw,maxh,true);			InvalRect(&r);					// Window KOMPLETT neuzeichnen		} else {		{		Rect t = r;							// alten H-Slider beim Vergrößern entfernen			t.top = t.bottom-SBarWidth+1;			InvalRect(&t);EraseRect(&t);			t = r;							// alten V-Slider beim Vergrößern entfernen			t.left = t.right-SBarWidth+1;			InvalRect(&t);EraseRect(&t);		}		SizeWind(wind,maxw,maxh,true);		{	Rect t = ((WindowPtr)wind)->portRect;	// Sizer beim Verkleinern neuzeichnen			t.top = t.bottom-SBarWidth; t.left = t.right-SBarWidth;			InvalRect(&t);		}		}		SetPort(oldPort);	}}/*** *	es wurde der Fuller angeklickt (für Multi-Screen-Umgebungen) ***/void	WZoomClick(WindPtr w,short zoomDir){GrafPtr		savePort;			// gretteter GrafportLONG		width = w->MaxWidth;LONG		height = w->MaxHeight;	if (!BTstQ(w->Typ,noVSlider)) height += SBarWidth;	if (!BTstQ(w->Typ,noHSlider)) width += SBarWidth;	GetPort(&savePort);					// Grafport retten	SetPort((WindowPtr)w);				// Grafport vom Window setzen	ZoomToWindowDevice((WindowPtr)w,width,height,zoomDir,false);	FixScrollBars(w);					// Scroll-Bars anpassen	InvalRect(&(((WindowPtr)w)->portRect));	// Window KOMPLETT neuzeichnen	AdjustWindow(w);					// Window-Variablen updaten	SetPort(savePort);					// Grafport zurücksetzen}/*** *	es wurde der Closer angeklickt ***/void	WCloseClick(WindPtr wind){KeyMap			theKeys;	// 8 Byte Tastaturmatrix	GetKeys(theKeys);					// aktuelle Tastaturmatrik holen	if (CheckKey(0x3A)) {				// Option gedrückt? 		if (CheckKey(0x38)) {			// Shift gedrückt?			REG DocHandle d = gDocList;			while(d) {				CloseWindAll(d);		// alle Fenster eines Dokumentes schließen				d = (*d)->next;			// ein Dokument weiter			} 		} else 			CloseWindAll(gDoc);			// alle Windows vom aktuellen Dokument schließen 	} else 		CloseWind(wind);				// Window schließen}/*** *	Klick ins Windowinnere ***/#if USETEXTEDITPoint	gThePoint;void	te_click(void);void	te_click(void){	TEClick(gThePoint,(keystate & 1)==1,gTEHandle);}#endifvoid	WContentClick(WindPtr wind,Point thePoint){GrafPtr			savePort;short			thePart;		// angeklicktes itemControlHandle	c;				// angeklicktes ControlBoolean			aDAIsActive	= IsDAWindow(FrontWindow());Rect			r;	if (!wind) return;					// kein Window => raus	if ((wind->Doc)&&(wind->Doc != gDoc)) SetDoc(wind->Doc);	if (((wind != gTopFloat)&&(wind != gTopWindow)) || aDAIsActive) {		if (!BTstQ(wind->Typ,InstantActive)) {			SelectWind(wind);			// und raus (d.h. noch keine Aktion)			if (!IsFloating(wind))		// kein Floating-Window?				return;					// dann erstmal wieder raus		} else			gWunschwind = wind;	}	GetPort(&savePort);	SetPort((WindowPtr)wind);			// GrafPort auf das Window	GlobalToLocal(&thePoint);			// lokale Mauskoordinate#if USETEXTEDIT	if (gTEHandle && (wind==gTEWindow) && PtInRect(thePoint,&((*gTEHandle)->viewRect))) {// Text-Edit aktiv?		gThePoint = thePoint;		WindowAktion(wind,-1,(long)te_click);	// Text-Edit aktiv	} else#endif	{	thePart = oFindControl(thePoint,(WindowPtr)wind,&c);	if (((c != wind->HSlider)&&(c != wind->VSlider))|| (c == nil))	// kein Control vom Window		WINDOW(wind,klick,nil);				// Klick ins Window	else {		if (thePart == 0) return;			// nix im Control angeklickt		if(!oGetCtlMax(c)) return;			// Control maximal == 0 => kein Control		if (thePart == inThumb)	{			// Slider direkt bewegen?			REG LONG	offset = TrackThumb(thePoint,c,nil);	// Thumb bewegen			REG LONG	xd,yd;			if (offset) {					// Thumb bewegt?				if (wind->HSlider == c) {	// Horizontaler Slider:					xd = offset;					yd = 0;				} else {					// Vertikaler Slider:					xd = 0;					yd = offset;				}				SetDeltaSlider(wind,xd,yd);	// Slider versetzen			}		} else			oTrackControl(c,thePoint,ScrollProc);		if (!BTstQ(wind->Typ,noOrigin))			AdjustWindow(wind);					// Window-Variablen updaten		}	}	SetPort(savePort);							// GrafPort auf das Window	if (gWunschwind && (gWunschwind != gTopWindow)) {		SelectWind(gWunschwind);		gWunschwind = nil;	}}