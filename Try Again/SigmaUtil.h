/*** *	Utility-Library * *	Diese Library enthält einige praktische Funktionen für Pascal-Strings als Inline-Code. *	Dazu gehören: * *	strpcpy()	- Pascal String kopieren *	strpcat()	- einen Pascal String an einen anderen anhängen. Eine Abfrage auf die maximale *				  Stringlänge von 255 Bytes wird ebenfalls gemacht. *	strpcat2()	- wie strpcat(), jedoch ohne Abfrage *	strpcmp()	- Vergleich von zwei Pascal-Strings * *	Als kleines, ja winziges, Schmankerl gibt´s die Funktion “Pause”, die exakt der Delay- *	Funktion entspricht, jedoch a) ohne lästigen Pointer-Parameter auskommt und b) nur ZWEI *	Bytes Code kostet. Der Pointer-Parameter wird nun — wie es sich für eine Funktion gehört — *	in D0 zurückgegeben: * *	finalTicks = Pause(long numTicks); *		entspricht *	Delay(numTicks,&finalTicks); * *	Vorteil dieser Library: Die Routinen sind kurz und schnell. strpcat() läßt sich somit *	auch noch als Unterprogramm sinnvoll einsetzen (da ziemlich lang, jedoch sehr kompakt). * *	Diese Library funktioniert NUR unter Think C 5.0 und (wahrscheinlich) MPW C (konnte *	ich nicht ausprobieren) * *	©1991 ∑-Soft, Markus Fritze ***/#pragma	once/*** *	folgende Inline-Funktion kopiert einen Pascal-String. Syntax, wie bei C, d.h. * *		strpcpy(destination,source); * ***/#pragma parameter	Strpcpy(__A1,__A0)void	Strpcpy(unsigned char *d,const unsigned char *s) = { 0x7000,0x1010,0x5280,0xA02E };/*** *	folgende Inline-Funktion hängen einen Pascal-String an einen anderen an. Syntax, wie bei C, d.h. * *		strpcat(destination,source); * *	Die Routine sorgt dafür, daß der String nicht länger als 255 Bytes wird (mehr geht in Pascal *	ja nicht…) ***/#pragma parameter	Strpcat(__A1,__A0)void	Strpcat(unsigned char *d,const unsigned char *s) = { 0x7000,0x1018,0x7200,0x1211,0x1400,0xD401,0x6404,0x1001,0x4600,0xD119,0xD2C1,0xA02E };/*** *	und weil die Routine ganz witzig ist, hier der Sourcecode dazu: ***		moveq	#0,D0		move.b	(A0)+,D0		;Länge vom Sourcestring (anzuhängender String)		moveq	#0,D1		move.b	(A1),D1			;Länge vom Destinationstring (hier wird angehängt)		move.b	D0,D2		add.b	D1,D2			;Gesamtstringlänge (Überlauf wird ignoriert)		bcc.s	@0				;kein Überlauf => String paßt!		move.b	D1,D0			;nur bis 255 Zeichen auffüllen		not.b	D0				;etwas “tricky”: D0 = 255 - D1 (DestLen)@0:		add.b	D0,(A1)+		;neue Stringlänge setzen		add.w	D1,A1			;ab hier wird der Sourcestring angehängt…		dc.w 0xA02E				;BlockMove() ***//*** *	folgende Inline-Funktion hängen einen Pascal-String an einen anderen an. Syntax, wie bei C, d.h. * *		Strpcat2(destination,source); * *	Im Gegensatz zu “strpcat” wird bei dieser Funktion die Gesamtlänge NICHT abgetestet! ***/#pragma parameter	Strpcat2(__A1,__A0)void	Strpcat2(unsigned char *d,const unsigned char *s) = { 0x7000,0x1018,0x7200,0x1211,0xD119,0xD2C1,0xA02E };/*** *	folgende Inline-Funktion vergleicht einen Pascal-String an einen anderen an. Syntax, wie bei C, d.h. * *		strpcmp(string1,string2); ***/#pragma parameter __D0 Strpcmp(__A1,__A0)Boolean	Strpcmp(unsigned char *d,const unsigned char *s) = { 0x7001,0x1210,0x6004,0x5301,0x6506,0xB308,0x67F8,0x7000 };/*** *	finalTicks = Pause(numTicks); entspricht EXAKT der Delay()-Prozedur. Jedoch ohne *	die lästige Rückgabe von “finalTicks”. Zudem ist sie so nur 2 Bytes lang… ***/#pragma parameter __D0	Pause(__A0)long	Pause(long numTicks) = { 0xA03B };/*** *	Diese Funktion gibt das obere bzw. das untere Word eines übergebenen Paramters *	zurück. ***/#pragma parameter __D0	HIWord(__D0)short	HIWord(long p) = { 0x4240,0x4840 };#pragma parameter __D0	LOWord(__D0)short	LOWord(long p) = { 0x0280,0x0000,0xFFFF };