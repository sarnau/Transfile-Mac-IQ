// Float.c - Alles was mit dem Float zu tun hat…#include "Float.h"#include "DialogLib.h"#include "Geos.h"#include "Install.h"#include "Memo.h"#include "Windows.h"#include "Utilities.h"#include "Calendar.h"#include "Outline.h"// folgende Include-Files werden für Option-Klick auf den Telefonfilenamen// d.h. Sprung in den Telefonnamens-Editor benötigt:#include "GeosMore.h"#include "MoreOptions.h"#include "IQComm.h"// Wird für die Positionierung des Floats auf dem Screen benötigt#include "GlobalLib.h"extern WORD	gWindows; 				// Anzahl der offenen WindowsWindPtr		gTheFloatWind;static Rect	FloatRect = { 50,50,0,0 };	// Windowposition merken// Float zeigen, solange mindestens ein Window offen ist.// ACHTUNG: Float unbedingt NACH dem Window öffnen, da sonst die xWindStruct// noch nicht definiert ist!void	ShowFloat(WindPtr w){Str255		title;REG WindPtr	wfloat;Rect		rs,rw;	if (!gTheFloatWind) {			// Vorher keins offen?		if (gS.FloatPos.v) topLeft(FloatRect) = gS.FloatPos;	// gespeicherte Position		GetIndString(title,strWindowNamen,strFloatClose);		// Neuer Titel: … schließen		wfloat = OpenWind(TRUEDIALOG+129|(STDFLOAT & 0xFFFF0000L)|(1L << NoParent)|(1L << noShowWind),&FloatRect,title,1,350,300);	// Window mit Fuller 		if (!wfloat) return;		// Speicher reichte nicht mehr!		rs = gScreenRect;			// Bildschirmrechteck		rw = ((WindowPtr)wfloat)->portBits.bounds;			// Windowrechteck		if ((-rw.top > rs.bottom)||(-rw.left > rs.right)) {	// Float außerhalb?			rw.top = 50;			// Defaultpositionen nehmen			rw.left = 50;			MoveWindow((WindowPtr)wfloat,rw.left,rw.top,false);	// Window neu positionieren		}		WFUNC(wfloat,button,Floatklick);		WFUNC(wfloat,close,Floatclose);		gTheFloatWind = wfloat;		UpdateFloat(w);		SelectWind(wfloat);	} else		UpdateFloat(w);	gS.FloatPos = topLeft(FloatRect);	gS.FloatShouldBeOpen = true;	gSaveSettings = true;			// Einstellungen sichern }////	Ein Float öffnen, wenn ein Window geöffnet wurde und das Float schon//	früher offen war//void	OpenFloatIfNecessary(WindPtr w){	gWindows++;						// Ein Window mehr offen	if(gS.FloatShouldBeOpen && !gTheFloatWind)	// Float sollte eigentlich offen sein…		ShowFloat(w);				// Dann jetzt öffnen	else		if(gTheFloatWind)			// Wenn aber ein Float schon offen ist			UpdateFloat(w);			// dann die Buttons ans aktuelle Window anpassen}////	Updated den Inhalt des Floats. ACHTUNG: Diese Routine darf nur aufgerufen werden,//	wenn auch ein Float offen ist (gTheFloatWind definiert).//void	UpdateFloat(WindPtr w){REG Handle			xWindow;REG WORD			i;REG DialogPtr		d = (DialogPtr)gTheFloatWind;	// globale Variable in ein RegisterREG WORD			temp;REG ControlHandle	c;IQFileType			baseType;			// Telefon oder User File	if(!d) {							// Sicher ist sicher…		SysBeep(20);		DoDialog(DLOGgFloatErr,1);		return;	}	xWindow = w->MoreMem;	if (!xWindow) {						// Handle trotzdem nicht initialisiert?		DebugStr("\pxWindow = NIL in UpdateFloat");		return;	}	switch(XWIN->windowType) {			// Je nach Window gibt's oben andere Buttons	case ANN1:				for(i=flAll;i<=flNotFound;i++)		// Untere 5 Buttons enabeln					HiliteControl(GetCH(d,i),0);				for(i=flTel1;i<=flTel3;i++ )					HideDItem(d,i);				for(i=flPrev;i<=flNext;i++ )					HideDItem(d,i);				for(i=flDay;i<=flMonth;i++)	{		// Monatsbuttons anschalten					temp = (XWIN->floatVar == i)?kSelect:kDeselect;					c = GetCH(d,i);					// Controlhandle ermitteln					if ((*c)->contrlHilite == kCntlInactive)	// Button disabled?						HiliteControl(c,kCntlActive);			// dann enablen					if (GetCtlValue(c) != temp)		// Button geändert?						SetCtlValue(c,temp); 		// dann setzen					ShowDItem(d,i);					// Button anschalten				}				break;	case TEL1DATA:		case USERFILE1:	case TEL2DATA:		case USERFILE2:	case TEL3DATA:		case USERFILE3:				baseType=(XWIN->windowType==TEL1DATA)?TEL1FILE:USER1FREE;	// UserFile oder Telefondateinamen					for(i=flAll;i<=flNotFound;i++)		// Untere 5 Buttons enabeln					HiliteControl(GetCH(d,i),0);				for(i=flDay;i<=flMonth;i++)					HideDItem(d,i);				for(i=flPrev;i<=flNext;i++)					HideDItem(d,i);				for(i=flTel1;i<=flTel3;i++) {	// Telefonbuttons durchgehen					REG Boolean	found = false;	// Name in der Organizer-Handle gefunden?					Str255		s;				// neuer Name vom Button					Str255		sOld;			// alter Name vom Button					GetTelName(i-flTel1+baseType,s); // Namen des Bereiches ermitteln					c = GetCH(d,i);					GetCTitle(c,sOld);			// alten Namen vom Button holen					if (!Strpcmp(sOld,s))		// String geändert?						SetCTitle(c,s);			// dann setzen					if ((*c)->contrlHilite == kCntlInactive)	// Button disabled?						HiliteControl(c,kCntlActive);			// dann enablen					temp = (BTstQ(XWIN->floatVar,(i-flTel1)))?kSelect:kDeselect;					if (GetCtlValue(c) != temp)		// Buttonstatus geändert?						SetCtlValue(c,temp);		// dann setzen					ShowDItem(d,i);					// Button darstellen				}				break;	case OUTLINE:				for(i=flDay;i<=flMonth;i++)			// Tag/Woche/Monats-Button wegblenden					HideDItem(d,i);				for(i=flTel1;i<=flTel3;i++ )		// Telefon genauso					HideDItem(d,i);									if((w->firstspec) && ((*(ListH)(w->firstspec))->next))	// Gibt's einen Folgeeintrag?					i=0;				else					i=255;				HiliteControl(GetCH(d,flNext),i);				if((w->firstspec) && ((*(ListH)(w->firstspec))->prev))	// Und einen vorigen					i=0;				else					i=255;				HiliteControl(GetCH(d,flPrev),i);				for(i=flPrev;i<=flNext;i++ )					ShowDItem(d,i);									for(i=flAll;i<=flNotFound;i++)		// Untere 5 Buttons disabeln					HiliteControl(GetCH(d,i),255);									break;	default:										// Alle Buttons wegschalten				for(i=flAll;i<=flNotFound;i++)		// Untere 5 Buttons enabeln					HiliteControl(GetCH(d,i),0);				for(i=flPrev;i<=flNext;i++ )		// Outline					HideDItem(d,i);				for(i=flTel1;i<=flTel3;i++)			// die Telefon-Buttons					HideDItem(d,i);					// wegschalten				for(i=flDay;i<=flMonth;i++)				{					SetButton(d,i,kDeselect);		// Ja, dann deselecten					HiliteButton(d,i,kCntlInactive);	// und hiliten				}				c = GetCH(d,flDay);					// Tages-Button				if ((*c)->contrlRect.left >= 8192) 	// Tages-Buttons inaktiv?					for(i=flDay;i<=flMonth;i++)		// Dann Tages-Buttons						ShowDItem(d,i);				// einschalten	}	PushRadioButton(d,XWIN->floatDisp,flAll,flNotFound);// Radio-Buttons unten}////	Window-Routine beim Klick ins Float –Button-Event–//VOID	Floatklick(REG LONG item){REG DialogPtr	d = (DialogPtr)gTheFloatWind;	// globale Variable in ein RegisterREG WORD		fieldWidth,maxDays,oldFloatVar;REG Handle		xWindow;REG WindPtr		w;	if(!d) {								// Zur Sicherheit…		DoDialog(DLOGgFloatErr,1);			// Gar kein Float da!?		return;	}	w = gTopWindow;							// WindPtr des obersten Windows	if(!w)		return;	xWindow = w->MoreMem;	XWIN->lastKlick = -1;	switch(item) {	case flDay:	case flWeek:	case flMonth:			SetButton(d,XWIN->floatVar,kDeselect);	// alten Button deselektieren			oldFloatVar = XWIN->floatVar;			XWIN->floatVar = item;			SetButton(d,item,kSelect);		// …und neuen selektieren			if (oldFloatVar==flDay)			// Vorher Tag? Dann Liste freigeben				DisposeDay(gTopWindow);			if (item==flMonth) {			// Ein Monat beginnt immer mit dem 1.				maxDays = ndays[XWIN->theUnion.schedule.month-1];	// Tageszahl im akt. Monat				if ((XWIN->theUnion.schedule.month==2) && !(XWIN->theUnion.schedule.year % 4))	// Schaltjahr 					maxDays++;				if ((oldFloatVar==flWeek)&&(XWIN->theUnion.schedule.day+7>maxDays)) // Umschaltung Woche->Monat?					if((XWIN->theUnion.schedule.month++)>12) {	// Dann Folgemonat anzeigen						XWIN->theUnion.schedule.year++;						XWIN->theUnion.schedule.month = 1;						XWIN->theUnion.schedule.theSelectedDay-=maxDays; // Selektierter Tag nicht hinter Monatsletztem					}				XWIN->theUnion.schedule.day = 1;			} else {				if (XWIN->theUnion.schedule.theSelectedDay)					XWIN->theUnion.schedule.day = XWIN->theUnion.schedule.theSelectedDay;				if (item == flWeek)			// Bei Wochen auf Montag alignen					AlignWeek(xWindow);				else					PrepareDay(gTopWindow);			}			DoMultiRedraw(XWIN->windowType,redrawAll,nil);			break;	case flTel1:	case flTel2:	case flTel3:			if ((vqkey() & 8)&&(NewLinkFormat(gDoc))) {	// Option auch gedrückt?				DoTelfname();						// Filenamen-Editor aufrufen				break;			}			SetButton(d,item,!GetButton(d,item));	// Button invertieren			XWIN->floatVar = XWIN->floatVar ^ (1<<(item-flTel1));			DoMultiRedraw(XWIN->windowType,redrawAndRecalc,nil);			break;	case flPrev:							// Outliner: zurückblättern		if((w->firstspec) && ((*(ListH)(w->firstspec))->prev))	// Geht's noch zurück?		{GrafPtr oldPort;			w->firstspec=(*(ListH)(w->firstspec))->prev;		// Handle des akt. Datensatzes			GetPort(&oldPort);			SetPort((GrafPtr)w);			InvalRect(&(((GrafPtr)w)->portRect));		// Redraw forcieren			WUpdate(w);			SetPort(oldPort);			AdjustWindow(w);			FixScrollBars(w);			UpdateFloat(w);								// Button en-/disabeln		}		break;	case flNext:							// Outliner: vorblättern (s. o.)		if((w->firstspec) && ((*(ListH)(w->firstspec))->next))		{GrafPtr oldPort;			w->firstspec=(*(ListH)(w->firstspec))->next;		// Handle des akt. Datensatzes			GetPort(&oldPort);			SetPort((GrafPtr)w);			InvalRect(&(((GrafPtr)w)->portRect));			WUpdate(w);			SetPort(oldPort);			AdjustWindow(w);			FixScrollBars(w);			UpdateFloat(w);								// Button en-/disabeln		}		break;	case flAll:	case flMarked:	case flUnmarked:	case flFound:	case flNotFound:			SetFloatDisp((flType)item);		// Setzen mit Redraw			break;	}}////	Testen, ob alle Windows geschlossen wurden, dann auch das Float schließen//VOID	TestHideFloat(VOID){REG Boolean 	temp,tempDirty;	temp = gS.FloatShouldBeOpen;	tempDirty = gSaveSettings;				// Dirty-Flag der Prefs auch	if((--gWindows == 0) && gTheFloatWind)	// Kein Window mehr offen?		CloseWind(gTheFloatWind);			// Dann auch Float schließen	gS.FloatShouldBeOpen = temp;			// Float nicht freiwillig geschlossen	gSaveSettings = tempDirty;				// Prefs werden hierdurch nicht dirty}////	Der Closer vom Float wurde angeklickt => Float schließen//VOID	Floatclose(VOID){REG WindPtr	w = gTheFloatWind;	if (w) {								// Float wirklich offen? => Position merken		FloatRect = ((WindowPtr)w)->portBits.bounds;		FloatRect.top = -FloatRect.top;		FloatRect.left = -FloatRect.left;	}	gTheFloatWind = nil;					// Momentan gibt es kein Float	gS.FloatShouldBeOpen = false;			// Es wurde wohl absichtlich geschlossen	gS.FloatPos = topLeft(FloatRect);		// Position auch merken	gSaveSettings = true;					// Einstellungen sichern }////	Float des aktuellen Windows auf neue Anzeigeart setzen [untere 5 Buttons]//	Der Screen wird gleich mit redrawt//VOID	SetFloatDisp(flType newType){REG Handle		xWindow;REG DialogPtr	d;	if(!gTopWindow)	return;					// ist ein Window offen?	if(!gTheFloatWind) ShowFloat(gTopWindow);	// Float zu? Dann öffnen…	d = (DialogPtr)gTheFloatWind;	xWindow=gTopWindow->MoreMem;			// Handle auf xWindStruct	if(XWIN->floatDisp==newType) return;	// Hat sich nix geändert? Dann raus =>	SetButton(d,XWIN->floatDisp,kDeselect);	// alten deselektieren…	XWIN->floatDisp = newType;				// Neuer Wert für unteren Float-Button	XWIN->lastKlick = -1;					// Noch nix angeklickt [Zeilen verschieben sich]	SetButton(d,XWIN->floatDisp,kSelect);	// …und neuen selektieren	DoMultiRedraw(XWIN->windowType,redrawAndRecalc,nil);// Und noch ein Komplettredraw}