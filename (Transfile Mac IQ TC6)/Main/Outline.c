/*** *	Outline.c ***/#include "Outline.h"#include "Windows.h"#include "rsrcDefines.h"#include "xRsrcDefines.h"#include "Geos.h"#include "Memo.h"#include "AktDocStruct.h"#include "Utilities.h"#include "Float.h"VOID	outlineadjust(VOID){REG WindowPtr	w = (WindowPtr)gMacWind;	// spart Platz… (und einige Casts)REG ListH		l = (ListH)((WindPtr)w)->firstspec;	// erstes Outliner-DokumentREG USTR		s;xWindStruct**	x = (xWindStruct**)((WindPtr)w)->MoreMem;	(*x)->contentSize = 0;					// erstmal keine Zeilen…	(*x)->selectedNo = 0;					// Kein selektierter Datensatz	if(!l) return;							// keine Daten => raus	HLock((Handle)l);	s = (USTR)&(*l)->d;						// Ptr auf den Outliner-Text	{	REG WORD	topics;	REG USTR	sp = &s[10];				// Ptr auf einen String	REG WORD	voffset;	REG Boolean	AllLines = sp[1] & 0x01;	// True: nicht einzeilig darstellen	topics = GetHexByte((STR)&s[6])+(GetHexByte((STR)&s[8])<<8);	for(voffset=1;topics;topics--) {		// alle Topics durchgehen		if ((sp[1] & 0x02)==0x00) {			// Topic anzeigen?			REG Boolean	First = true;			REG Boolean	Draw = true;			REG WORD	hoffset = sp[0] & 0x0F;		// Faktor der Einrückung			sp	+= 2;						// Flags überspringen			do {				REG LONG	len = 0;				do {					REG UCHAR c = sp[len];	// Zeichen holen					if (c == '\r') break;	// Ende vom Thema…					if (c == '\t') break;	// Return					if (AllLines)						if (len >= (ORG.width-1-hoffset)) break;	// maximal 40 Zeichen pro Zeile					len++;				} while(1==1);				if (Draw) {					// erster Aufruf?					voffset++;					if (AllLines == false) Draw = false;	// nur die erste Zeile ausgeben				}				sp += (len>=(ORG.width-1-hoffset))?len:len+1;			} while (sp[-1] != '\r');		// Topic fertig?		} else {			sp += 2;			while(*sp++ != '\r');			// Topic überspringen		}	}	(*x)->contentSize = voffset;	}	HUnlock((Handle)l);	testadjust((WindPtr)w);}/*** *	Outliner-Font anpassen ***/VOID	AdjustOutliner(WindPtr w);VOID	AdjustOutliner(WindPtr w){FontInfo	inf;WORD		font;GrafPtr		oldPort;	GetPort(&oldPort);	SetPort((GrafPtr)w);	GetFNum(ADOC.font,&font);			// Fontname aus AktDocStruct	TextFont(font);						// Font setzen	TextSize(ADOC.fontSize);			// Größe setzen	GetFontInfo(&inf);					// Höhe des aktuellen Fonts	w->ScrollH=CharWidth('x');	w->ScrollPageH=w->ScrollPageV=VPAGE;// 12 Einheiten bei Page scrollen	w->ScrollV=(long)(inf.ascent+inf.descent+inf.leading);	AdjustWindow(w);					// Slider neu skalieren	SetPort(oldPort);}/*** *	Window öffnen ***/OSErr	OpenOutlineWindows(VOID)		// Window für Outliner öffnen{REG Handle	xWindow;REG WindPtr	w;	w = MyOpenWind(FULLER /*| (1L<<noOrigin)*/,WindOutline,strOutliner,OUTLINE);	/* Window mit Slidern */	if(!w)		return(memFullErr);				// Fehler beim Öffnen 	xWindow=w->MoreMem;	XWIN->floatDisp = flAll;	WFUNC(w,draw,outlinedraw);			// Zeichenroutine	WFUNC(w,rename,WindRename);			// Nach "Save as…"	WFUNC(w,adjust,outlineadjust);		// Nach "Save as…"	WFUNC(w,close,testclose);			// evtl. Float abmelden	WFUNC(w,activ,testactivate);		// Zum Float-Update nötig	WFUNC(w,menuupdate,orgupdate);		// Outliner kann nicht gedruckt werden	{	ListH	l = ORG.outline;			// Datensatz, der im Fenster dargestellt wird//	l = (*l)->next;	w->firstspec = (void*)l;	}	AdjustOutliner(w);	OpenFloatIfNecessary(w);	return(noErr);						// alles ok!}////	Redraw fürs Business-Card-Window//VOID	outlinedraw(VOID){REG WORD		zeilenHoehe;REG WindowPtr	w = (WindowPtr)gMacWind;	// spart Platz… (und einige Casts)REG ListH		l = (ListH)((WindPtr)w)->firstspec;	// erstes Outliner-DokumentREG USTR		s;static WORD		fontsize = 0;static WORD		fontnum = -1;WORD			font;FontInfo		inf;	GetFNum(ADOC.font,&font);				// Fontname aus AktDocStruct	if((fontsize != ADOC.fontSize)||		(font != fontnum)) {				// Fontgröße oder -art geändert?		fontsize = ADOC.fontSize;		fontnum = font;		AdjustOutliner((WindPtr)w);	}	GetFontInfo(&inf);						// Höhe des aktuellen Fonts	EraseRect(&w->portRect);				// Window löschen	if(!l) return;							// keine Daten => raus	zeilenHoehe = gMacWind->ScrollV;		// Zeilenhöhe beim applFont	HLock((Handle)l);	s = (USTR)&(*l)->d;						// Ptr auf den Outliner-Text	{	REG WORD	topics;	REG USTR	sp = &s[10];				// Ptr auf einen String	REG WORD	voffset;	REG Boolean	AllLines = sp[1] & 0x01;	// True: nicht einzeilig darstellen	topics = GetHexByte((STR)&s[6])+(GetHexByte((STR)&s[8])<<8);	for(voffset=0;topics;topics--) {		// alle Topics durchgehen		if ((sp[1] & 0x02)==0x00) {			// Topic anzeigen?			REG Boolean	First = true;			REG Boolean	Draw = true;			REG WORD	hoffset = sp[0] & 0x0F;		// Faktor der Einrückung			WORD		lastOffset = voffset;			sp	+= 2;						// Flags überspringen			do {				REG LONG	len = 0;				do {					REG UCHAR c = sp[len];	// Zeichen holen					if (c == '\r') break;	// Ende vom Thema…					if (c == '\t') break;	// Return					if (AllLines)						if (len >= (ORG.width-1-hoffset)) break;	// maximal 40 Zeichen pro Zeile					len++;				} while(1==1);				if (Draw) {					// erster Aufruf?					if (First) {						MoveTo(hoffset * CharWidth('◊'),inf.ascent + zeilenHoehe * voffset);						DrawChar('◊');						First = false;					}					MoveTo((hoffset+1) * CharWidth('◊'),inf.ascent + zeilenHoehe * voffset);					DrawText(sp,0,len);		// Zeile ausgeben					voffset++;					if (AllLines == false) Draw = false;	// nur die erste Zeile ausgeben				}				sp += (len>=(ORG.width-1-hoffset))?len:len+1;			} while (sp[-1] != '\r');		// Topic fertig?#if 0			{			Rect	r;			r.top = zeilenHoehe * lastOffset;			r.left = 0;			r.bottom = zeilenHoehe * voffset;			r.right = 9999;			InvertRect(&r);			}#endif		} else {			sp += 2;			while(*sp++ != '\r');			// Topic überspringen		}	}	}	HUnlock((Handle)l);}////	Drucken-Menü beim Outliner disabeln//void	orgupdate(void){	MenuHandle	mHandle;		mHandle=GetMHandle(mAblage);	DisableItem(mHandle,iPrint);}