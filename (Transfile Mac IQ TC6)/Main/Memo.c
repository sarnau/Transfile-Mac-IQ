/*** *	Memo.c ***/#include "GlobalDefines.h"#include "DialogLib.h"#include "Install.h"#include "rsrcDefines.h"#include "GlobalStruct.h"#include "GlobalLib.h"#include "Geos.h"#include "Memo.h"#include "Calendar.h"#include "Float.h"#include <BDC.h>#include "String.h"#include "Utilities.h"#include "IQComm.h"#include "Document.h"#include "AktDocStruct.h"#include "DoEvent.h"#include "List.h"#include "Editor.h"							// für EditReturnType#include "Options.h"#include "Scheduler.h"#include "LongControl.h"#include "MySound.h"#include "CheckList.h"#include <stdio.h>IQFileType	gRedrawIQType;RedrawType	gRedrawRdType;short		gOpenCount[MaxWindowClass];		// Anzahl der offenen Windows einer Artshort		gOpenNo[MaxWindowClass];		// Nummern dazushort		gNoWindowsOpen=0;				// Anzahl der insgesamt geöffneten WindowsBoolean		gCalcDateAndTimeNormally=true;	// false bei LookForEntry, da schneller in CopyListToDatasetchar		zeilenDerTerminarten[9]={3,1,1,2,1,2,1,0,2};Boolean		useCache[MaxIQFileType]={true,false,true,true,true,true,true,true,true,true,true,true,true,true,	//SCHEDULE - TEL3FREE, ANN1=Calendar kein Caching									true,false,true,true,true,true,true,true,true,true,true,true,true,true,true}; // MEMO - USER3FREE, OUTLINE = kein Caching#if BETA && CACHEextern Boolean	gCacheDisabled;#endif/*** *	Window öffnen ***/OSErr	OpenMemoWindows(void)		// Window für Terminplaner öffnen{	Str255		title;	REG WindPtr	w1;	w1 = MyOpenWind(FULLER | (1L<<noOrigin),WindMemo,strMemo,MEMO);	/* Window mit Slidern */	if(!w1) 		return(memFullErr);				// Fehler beim Öffnen 	MultiOpen(w1,MEMO);	WFUNC(w1,menuupdate,calendarupdate);	// Darstellung disabeln etc.	return(noErr);						// alles ok!}////	Öffnet ein Window, wobei Windows gleichen Typs durchnumeriert werden//WindPtr	MyOpenWind(long Type,short id,short titleIndex,IQFileType type){	Str255			s,s2,title;	WindPtr			w1;	static short	inset;	short			h,v;	Rect			r;	Handle			xWindow;	if(gNoWindowsOpen++==0)							// kein Window war offen?		inset=1;									// Dann Einrückung wieder zurücksetzen		GetIndString(title,strWindowNamen,titleIndex);	CopyPString(s,(*gDoc)->f.fss.name);				// Dateinamen holen	GetIndString(s2,strWindowNamen,strNameColon);	// Doppelpunkt als Trenner	ConcatPString(s,s2);	ConcatPString(s,title);							// Daran den Originaltitel anhängen		if(++gOpenCount[id]>1)							// Gibt's schon ein Window dieser Art?	{		NumToString((long)++gOpenNo[id],title);		// Dann neue Nummer erzeugen		GetIndString(s2,strWindowNamen,strNameNo);	// # als Trenner		ConcatPString(s,s2);		ConcatPString(s,title);						// und hintenanhängen	}	h=screenBits.bounds.right-screenBits.bounds.left;	// Ausmaße der Bildschirme holen	v=screenBits.bounds.bottom-screenBits.bounds.top;		do												// Einrückung des Windows berechnen	{		r.top=WINDOW_BORDER+GetMBarHeight()+Y_ADD*inset;		r.left=WINDOW_BORDER+X_ADD*inset++;		r.bottom=v-WINDOW_BORDER;		r.right=h-WINDOW_BORDER;				if((r.right<(r.left+WINDOW_MIN_X)) || (r.bottom<(r.top+WINDOW_MIN_Y)))	// Window wird zu klein?			inset=1;								// Dann von vorn anfangen	}while(inset==1);		w1=OpenWind(Type,&r,s,id,h,v);	if(!w1) return(nil);							// Das war nix		xWindow=NewHandle(sizeof(xWindStruct));			// xWindowStruct anlegen	if(!xWindow) return(nil);	w1->MoreMem=xWindow;	XWIN->windowType=type;	XWIN->cacheEnable=useCache[type-1];				// Cache je nach Typ erlauben oder verbieten#if CACHE	XWIN->theUnion.cache=nil;						// Bisher gab's keinen Cache#endif	return(w1);}////	Diveses beim Windowöffnen//void	MultiOpen(WindPtr w1, IQFileType type){	short		zeilenHoehe,font;	FontInfo	inf;	short		fieldWidth;	GrafPtr		oldPort;	long		groesse=0;	Handle		xWindow;	ListH		lHandle;	WindPtr		tempWindPtr;		if(!w1)		return;		xWindow=w1->MoreMem;	w1->ScrollPageH=w1->ScrollPageV=VPAGE;	// 12 Einheiten bei Page scrollen	XWIN->floatDisp=ALL_DEFAULT;			// Default = Alles anzeigen	WFUNC(w1,adjust,testadjust);			// Slidergrenzen neu berechnen	WFUNC(w1,close,testclose);				// evtl. Float abmelden	WFUNC(w1,activ,testactivate);			// Zum Float-Update nötig	WFUNC(w1,klick,testklick);				// Klick in das Fenster	WFUNC(w1,rename,WindRename);			// Beim Speichern den Namen ändern	WFUNC(w1,draw,multidraw);				// Zeichenroutine	GetPort(&oldPort);	SetPort((GrafPtr)w1);	GetFNum(ADOC.font,&font);				// Fontname aus AktDocStruct	TextFont(font);							// Font setzen	TextSize(ADOC.fontSize);				// Größe setzen	CalcSecondColumn((GrafPtr)w1);			// Offset für 2. Spalte berechnen	tempWindPtr=gMacWind;					// Mit DoMultiRedrawSub wird die Länge der	gMacWind=w1;							// Datensätze ausgerechnet und gecached.	gRedrawIQType=XWIN->windowType;			// Dazu ist dieses als aktuelles Window	gRedrawRdType=redrawAndRecalc;			// einzusetzen und ein Redraw vorzutäuschen		DoMultiRedrawSub();		gMacWind=tempWindPtr;					// Alte Werte restaurieren	SetPort(oldPort);	OpenFloatIfNecessary(w1);				// wieder öffnen, wenn nur wegen Fenstermangels geschlossen}////	Adjust - Nach dem Sizen den VSlider neu skalieren//void	testadjust(WindPtr w){	Handle		xWindow;	long		zeilenHoehe,windowHoehe;	FontInfo	inf;	short		breite;		GetFontInfo(&inf);					// Höhe des aktuellen Fonts	zeilenHoehe=inf.ascent+inf.descent+inf.leading;	xWindow=w->MoreMem;	if(!xWindow)	{		OwnBeep(shit);		return;	}	windowHoehe=XWIN->contentSize*zeilenHoehe;	w->MaxHeight=windowHoehe;//	Das ganze nochmal für den horizontalen Slider	#if WYSIWYG		breite=WYSIWYG;						// WYSIWYG versauen	#else		breite=ORG.width;					// Breite für 8-zeilige Einträge	#endif	breite*=CharWidth('—');	breite+=ADOC.columnOffset+COLUMN_LINE_OFFSET;	w->MaxWidth=breite;	FixScrollBars(w);}////	Universelles Redraw für Telefon, Memo, Business-Card//void	multidraw(void){	dataset		**actset;	Rect		r;	long		y,zeilenZahl,slider;	ListH		handle,listHandle;	short		zeilenHoehe,temp;	short		round;					// Um Rundungsfehler beim Sliden zu kompensieren	REG IQFileType	startType;	REG	Handle	xWindow;	IQFileType	type;	//	FILE		*debug;		if(!gMacWind || !gDoc)		return;		xWindow=gMacWind->MoreMem;	type=XWIN->windowType;	listHandle=GetListH(GetOrgH(gDoc),type);		if(type==SCHEDULE)					// Wenn Scheduler und keine Daten in ORG.schedule	{		startType=SCHEDULE;				// Dann andere Terminplanereinträge durchsuchen		while((!listHandle) && (startType<DALARM))			listHandle=GetListH(GetOrgH(gDoc),++startType);	}	actset=(dataset**)NewHandle(sizeof(dataset));	if(actset)			// Wenn der Speicher nicht reicht, kann nix ausgegeben werden	{		zeilenHoehe=gMacWind->ScrollV;			// Zeilenhöhe beim applFont		SetRect(&r,0,0,SCREEN_MAX,SCREEN_MAX);		EraseRect(&r);		MoveTo(ADOC.columnOffset-oGetCtlValue(gMacWind->HSlider),0);		// Senkrechte Linie		Line(0,SCREEN_MAX);			HLock((Handle)actset);		FillOut(type,actset);		//		debug=fopen("Redrawing Protocol","a");				if(listHandle)			// Nur, wenn auch Daten für uns da sind…		{			zeilenZahl=(((GrafPort*)gMacWind)->portRect.bottom-((GrafPtr)gMacWind)->portRect.top)/zeilenHoehe;			slider=oGetCtlValue(gMacWind->VSlider);	// Wert des VSliders			round=slider % zeilenHoehe;				// Rundungsfehler kompensieren			handle=LookForEntry(slider/zeilenHoehe,listHandle,&y,zeilenZahl,type);	// Ab welchem Eintrag redrawn?//			fprintf(debug,"\nStart of new redraw at %ld\n\n",slider);//			CheckListData(GetListHA(GetOrgH(gDoc),type),(*GetOrgH(gDoc))->type);			while((zeilenZahl>=y) && handle)			{				if((*handle)->type!=type)			// Typ geändert (z. B. Ann1 -> Ann2)				{					type=(*handle)->type;					FillOut(type,actset);	// Dann Feldnamen neu holen				}				HLock((Handle)handle);				//strcpy((*actset)->data,(*handle)->d);				CopyListToDataset(actset,handle);//				fprintf(debug,"Display: act:%lX next:%lX prev:%lX\n",handle,(*handle)->next,(*handle)->prev);//				fprintf(debug,"Text: %s\n",(*handle)->d);				DisplayEntry(COLUMN_LINE_OFFSET,y*zeilenHoehe-round,actset,zeilenHoehe,handle,displayNormal);				temp=EntryLength(handle,(*handle)->type)+1;	// Eintragslänge + Platz für Linie				HUnlock((Handle)handle);				y+=temp;				handle=NextListH(handle,getTheNextOne);		// Nächsten Listeneintrag holen//				fprintf(debug,"NextListH: act:%lX next:%lX prev:%lX\n",handle,(*handle)->next,(*handle)->prev);//				fflush(debug);			}		}//		fclose(debug);		HUnlock((Handle)actset);		DisposHandle((Handle)actset);	}else		DoDialog(DLOGgFloatErr,1);}////	Holt den nächsten Listeneintrag, Scheduler wird berücksichtigt.//ListH	NextListH(ListH handle, TheMode	mode){	IQFileType	theType;		if(!handle)							// Keine Handle, dann auch kein Folgeeintrag		return(nil);		theType=(*handle)->type;						// Handle-Art	do	{		if(mode==getTheNextOne)			handle=(*handle)->next;		else			handle=(*handle)->prev;	}while(handle && !CheckEntry(handle,gMacWind));		if(!handle && (((theType<DALARM) && (mode==getTheNextOne))				|| ((theType>SCHEDULE) && (theType<=DALARM) && (mode==getThePreviousOne))))		// Listenende, aber Scheduler-Window	{		if(mode==getTheNextOne)						// Dann nächste Liste abgrasen			do{				handle=GetListH(GetOrgH(gDoc),++theType);	// Anfang der nächsten Liste			}while(!handle && (theType<DALARM));	// Mehrfach nötig, falls leere Teile dazwischen		else		{			do{				handle=GetListH(GetOrgH(gDoc),--theType);	// Vorige Liste			}while(!handle && (theType>SCHEDULE));	// bzw. wenn leer, dann die davor			while(handle && (*handle)->next)		// Ende der vorigen Liste				handle=(*handle)->next;		}		if(!handle || !CheckEntry(handle,gMacWind))	// Erster Eintrag nicht sichbar?			handle=NextListH(handle,mode);			// Dann rekursiv weitersuchen	}	return(handle);}////	Ausfüllen der Feldnamen je nach Windowtyp//void	FillOut(IQFileType type, datasetH actset){	short	i,j;	char	hstate;	//	hstate=HLockH((Handle)actset);	// erstmal beide Handle locken	hstate=HGetState((Handle)actset);	HLock((Handle)actset);	memset((*actset)->maxLen,0,sizeof((*actset)->maxLen)*MAX_NAMES);	// Default: Keine Feldlängen	(*actset)->setLength=(NewLinkFormat(gDoc))?2048:512;	// Gesamtmaximallänge	switch(type)	{	case BUSINESS:		for( i=strFirma ; i<=strDurchwahl ; i++ )			GetIndString((*actset)->text[i-strFirma],strBusi,i);		(*actset)->text[i-strFirma][0]=END_OF_LIST;		GetFreeFields(actset,ORG.busfree,BUSINESS,BUSFREE,BUSINESS,8);		(*actset)->visible=ADOC.display[type];	// Welche Felder anzeigen? (Bitfeld)		(*actset)->maxLen[0]=40;				// Maximal 40 Zeichen für den Firmennamen		break;		case MEMO:		GetIndString((*actset)->text[0],strNotiz,strNotizeintrag);		(*actset)->text[1][0]=END_OF_LIST;		(*actset)->visible=-1;		break;	case TEL1DATA: case TEL2DATA: case TEL3DATA:		// Beim 8000 Freifeldnamen mitnehmen, sonst halt nicht		for( i=strTelName ; i<=((ORG.type & IQ8x00)?strFree5:strTelAddress) ; i++ )			GetIndString((*actset)->text[i-strTelName],strTelefon,i);		(*actset)->text[i-strTelName][0]=END_OF_LIST;		(*actset)->visible=ADOC.display[TEL1DATA];	// Welche Felder anzeigen? (Bitfeld)		break;	case USERFILE1: case USERFILE2: case USERFILE3:		if(!ORG.userfree)		{			(*actset)->text[0][0]=END_OF_LIST;		// Keine Feldnamen!?//			OwnBeep(shit);			break;		}				{char *s,*t,c;		HLock((Handle)ORG.userfree);		s=strchr((*ORG.userfree)->d,RETURN)+1;		// Hier beginnen die Freifeldnamen, erstes		j=0;										// Freifeld überspringen, da dies Dateiname ist.		while( (t=strchr(s,RETURN))!=nil )			// Felder durch RETURN getrennt		{			c=t[0];			t[0]=0;									// String nullterminieren,			strcpy((char*)((*actset)->text[j]),s);	// kopieren …			CtoPstr((STR)((*actset)->text[j++]));	// und nach Pascal konvertieren			t[0]=c;			s=t+1;									// Ab dort weiterdurchsuchen		}		if(s[0])									// Gibt es noch Zeichen?		{			strcpy((char*)((*actset)->text[j]),s);		// Der letzte ist nicht terminiert,			CtoPstr((STR)((*actset)->text[j++]));		// sollte aber trotzdem kopiert werden		}		HUnlock((Handle)ORG.userfree);		(*actset)->text[j][0]=END_OF_LIST;			// Liste noch terminieren		(*actset)->visible=-1;						// Welche Felder anzeigen? (Bitfeld)		}		break;	case SCHEDULE:		for( i=strTag ; i<=strTermineintrag ; i++ )			GetIndString((*actset)->text[i-strTag],strTermin,i);		(*actset)->text[i-strTag][0]=END_OF_LIST;		(*actset)->visible=-1;		(*actset)->maxLen[0]=-10;				// Maximal 10 Zeichen für den Tag (nicht Gesamtlänge)		(*actset)->maxLen[1]=-30;				// Maximal 30 Zeichen für die Zeit		(*actset)->maxLen[2]=-15;				// Maximal 15 Zeichen für die Alarmzeit		(*actset)->visible=ADOC.display[type];	// Welche Felder anzeigen? (Bitfeld)		break;	case ANN1:		GetIndString((*actset)->text[0],strTermin,strAnn1);		GetIndString((*actset)->text[1],strTermin,strTermineintrag);		(*actset)->text[2][0]=END_OF_LIST;		(*actset)->visible=-1;		(*actset)->maxLen[0]=-5;				// Maximal 5 Zeichen für den Tag		break;	case ANN2:		GetIndString((*actset)->text[0],strTermin,strAnn2);		GetIndString((*actset)->text[1],strTermin,strTermineintrag);		(*actset)->text[2][0]=END_OF_LIST;		(*actset)->visible=-1;		(*actset)->maxLen[0]=-10;				// Maximal 10 Zeichen für das ganze		break;	case PERIOD:		GetIndString((*actset)->text[0],strTermin,strPStart);		GetIndString((*actset)->text[1],strTermin,strPEnd);		GetIndString((*actset)->text[2],strTermin,strTermineintrag);		(*actset)->text[3][0]=END_OF_LIST;		(*actset)->visible=-1;		(*actset)->maxLen[0]=-10;				// Maximal 10 Zeichen für das ganze		(*actset)->maxLen[1]=-10;				// Maximal 10 Zeichen für das ganze		break;	case DALARM:		GetIndString((*actset)->text[0],strTermin,strAlarm);		(*actset)->text[1][0]=END_OF_LIST;		(*actset)->visible=-1;		(*actset)->maxLen[0]=-15;				// Maximal 10 Zeichen für das ganze		break;	case EXPENSE:		for( i=strExpDatum ; i<=strBemerkung ; i++ )			GetIndString((*actset)->text[i-strExpDatum],strExpenseTxt,i);		(*actset)->text[i-strExpDatum][0]=END_OF_LIST;		(*actset)->visible=ADOC.display[EXPENSE];		(*actset)->maxLen[0]=-10;				// Maximal 10 Zeichen Datum		(*actset)->maxLen[1]=-30;				// Maximal 30 Zeichen Expense Type		(*actset)->maxLen[2]=-8;				// Maximal 8 Zeichen Amount		(*actset)->maxLen[3]=-30;				// Maximal 30 Zeichen Zahlungsart		(*actset)->maxLen[4]=512;				// Maximal 512 Zeichen Description		break;	case DOLIST:		for( i=strDoStichtag ; i<=strDoProjekt ; i++ )			GetIndString((*actset)->text[i-strDoStichtag],strDoListTxt,i);		(*actset)->text[i-strDoStichtag][0]=END_OF_LIST;		(*actset)->maxLen[0]=-10;				// Maximal 10 Zeichen für den Tag (nicht Gesamtlänge)		(*actset)->maxLen[1]=-2;				// Maximal 2 Zeichen für die Priorität		(*actset)->maxLen[2]=512;				// Maximal 512 Zeichen für die eigentliche Bezeichnung		(*actset)->maxLen[3]=-30;				// Maximal 30 Zeichen für Manager Name		(*actset)->maxLen[4]=-30;				// Maximal 30 Zeichen für Project Name		(*actset)->visible=ADOC.display[DOLIST];		break;	case TODO:		for( i=strToDoStichtag ; i<=strToDoKat5 ; i++ )			GetIndString((*actset)->text[i-strToDoStichtag],strToDoTxt,i);		(*actset)->text[i-strToDoStichtag][0]=END_OF_LIST;		(*actset)->maxLen[0]=-10;				// Maximal 10 Zeichen für den Tag (nicht Gesamtlänge)		(*actset)->maxLen[1]=-1;				// Maximal 1 Zeichen für die Priorität		(*actset)->maxLen[2]=2048;				// Maximal 2048 Zeichen für die eigentliche Bezeichnung		for( i=3 ; i<=7 ; i++ )			(*actset)->maxLen[i]=-12;			// Maximal 12 Zeichen für die 5 Kategorien		(*actset)->visible=ADOC.display[TODO];		break;	default:		(*actset)->text[0][0]=END_OF_LIST;	// Nicht identifiziert = Keine Einträge			(*actset)->visible=-1;	}	HSetState((Handle)actset,hstate);}////	Freifelder aus der Übergebenen ListHandle rausholen und in den DataSet eintragen//void	GetFreeFields(datasetH actset, ListH lhandle, IQFileType type, IQFileType first, IQFileType data,short start){	REG short	i,j=0,k;		if(!IQIsAvailable(GetOrgH(gDoc),type))	// Gibt es diese Felder hier überhaupt?		return;								// Sonst gibt das nix!			if(lhandle)								// Sind überhaupt welche da?	{		while(((*lhandle)->type!=type-data+first) && ((*lhandle)->next))			lhandle=(*lhandle)->next;		if((*lhandle)->type==type-data+first)	// Ein hübscher Name gefunden		{			k=start;						// Hier gehen die Freifelder los			if(first==USER1FREE)		// Bei User-Files erstes Feld überlesen, da nur Dateiname			{				while((*lhandle)->d[j] && ((*lhandle)->d[j]!=RETURN))					j++;				j++;			}			while((*lhandle)->d[j])			// Bis 0-Byte alle Einträge kopieren			{				i=0;				while(((*lhandle)->d[j]!=RETURN) && (k<MAX_NAMES-1) && (i<MAX_LENGTH-1))					(*actset)->text[k][i++]=(*lhandle)->d[j++];				(*actset)->text[k][i]=0;	// String Null-terminieren				j++;						// Return (Endekennung) überlesen				CtoPstr((STR)(*actset)->text[k++]);			}			if((k>=MAX_NAMES-1) || (i>=MAX_LENGTH-1))	// Fehler: zu viele oder lange Felder				SysBeep(20);			(*actset)->text[k][0]=END_OF_LIST;	// Liste wieder terminieren			return;		}	}		// Wenn wir hier ankommen, haben wir keine Feldnamen gefunden	j=((type>=USERFILE1)&&(type<=USERFILE3))?16:5;// Userfiles haben 16 Freifelder, andere 5	k=0;	if(((type>=TEL1DATA) && (type<=TEL3DATA) && IQIsAvailable(GetOrgH(gDoc),TEL1FREE))		 || ((type>=USERFILE1) && (type<=USERFILE3) && IQIsAvailable(GetOrgH(gDoc),USER1FREE)))	// Gibt es diese Freifelder hier überhaupt?		for( ; k<j ; GetIndString((*actset)->text[k+start],strTelefon,strFree1+k++) );	(*actset)->text[k+start][0]=END_OF_LIST;	// Liste wieder terminieren}////	Anzeigen eines Eintrags vom Memo, Telefon oder der Business-Card//void	DisplayEntry(int x, int y, dataset **actset, int zeilenHoehe, ListH lHandle, displayType displayMode){	short		i,j=0,k,feld=-1;		// feld = Bit im maske-Array	Rect		r;						// zum Invertieren	long		HSlider;	Str255		str;	short		fieldWidth;	IQFileType	type=(*lHandle)->type;	if(displayMode!=displayNormal)		HSlider=0;	else		HSlider=oGetCtlValue(gMacWind->HSlider);	r.top=y; r.left=0; r.right=SCREEN_MAX;	y+=zeilenHoehe;		#if WYSIWYG	if(displayMode==displayEditor)		// In der Übersicht immer 40 Zeichen		fieldWidth=FieldWidthCalc(lHandle);	// Zeichen pro Zeile berechnen	else		fieldWidth=WYSIWYG;	#else	fieldWidth=FieldWidthCalc(lHandle);	// Zeichen pro Zeile berechnen	#endif	HLock((Handle)actset);	if((type>=TEL1DATA) && (type<=TEL3DATA))	// Bei Telefon gibt's Freifelder		GetFreeFields(actset,ORG.telfree,type,TEL1FREE,TEL1DATA,3);	else		if((type>=USERFILE1) && (type<=USERFILE3))	// Bei UserFiles erst recht			GetFreeFields(actset,ORG.userfree,type,USER1FREE,USERFILE1,0);		if(displayMode!=displayEditor)		ShortenEntry((*actset)->data);			// Leerzeilen Wegcutten	i=-1;				// Damit nicht in den Conditions inkrementiert werden muß	if((type==TEL2DATA) || (type==TEL3DATA))	// 2 & 3 haben keine eigenen Einträge		type=TEL1DATA;		if((type==USERFILE2) || (type==USERFILE3))	// 2 & 3 haben keine eigenen Einträge		type=USERFILE1;	while((i<0) || (((*actset)->data[i+1]) && ((*actset)->data[i])))		// Bis 0-Byte ganzen String analysieren	{				//  ^^^für Telefon (mit \r terminiert)  ^^^für Memo (nur \0)		MoveTo(x-HSlider,y);					// Neues Feld: Bezeichnung ausgeben		if((*actset)->text[j][0]!=END_OF_LIST)	// Nur, wenn Text vorhanden (Länge ≠ 255)			if(BTstQ((*actset)->visible,++feld))	// …und Feld nicht ausgeblendet				DrawString((*actset)->text[j++]);			else				j++;							// sonst nächstes Feld		do{			k=0;								// Neuer Zeilenanfang = Pos. 0			do{				str[k++]=(*actset)->data[++i];	// Zeichen für Zeichen kopieren			}while(((*actset)->data[i]) && ((*actset)->data[i]!=CRLF) &&				((*actset)->data[i]!=RETURN) && (k<fieldWidth));	// Bis Return oder MaxZeichen			if(BTstQ((*actset)->visible,feld))				// Dieses Feld anzeigen?			{				str[k]=0;						// Nullterminieren				MoveTo(x+ADOC.columnOffset-HSlider,y);				CtoPstr((STR)str);				DrawString((StringPtr)str);				y+=zeilenHoehe;			}			if((k==fieldWidth) && ((((*actset)->data[i+1]==RETURN)				 && (*actset)->data[i]!=RETURN)|| (*actset)->data[i+1]=='\0'))			 	i++;								// Wenn Return und Zeile voll,													// dann Return überlesen.		}while(((*actset)->data[i]) && (*actset)->data[i]!=RETURN);	}	r.bottom=y-zeilenHoehe/2;	if(displayMode==displayEditor)	// Im Editor werden auch die Bezeichnungen	{							// von leeren Feldern angezeigen		while((*actset)->text[j][0]!=END_OF_LIST)		{			MoveTo(x-HSlider,y);					// Im Editor ist nie ein			DrawString((*actset)->text[j++]);		// Feld ausgeblendet			y+=zeilenHoehe;		}	}	if(displayMode==displayNormal)	{		MoveTo(0,r.bottom);		// Noch eine hübsche Linie unter den Datensatz		Line(SCREEN_MAX,0);	}		{short yMax,saveFont,breite; FontInfo inf;		y=r.top; yMax=r.bottom;			// Bei Bedarf noch * und 4/8 ausgeben//	GetFNum(ADOC.font,&saveFont);	// Fontname aus AktDocStruct//	TextFont(systemFont);			// In Chicago ausgeben	GetFontInfo(&inf);				// Höhe des aktuellen Fonts	zeilenHoehe=inf.ascent+inf.descent+inf.leading;	breite=CharWidth(MARK_CHAR);//	if(CharWidth(FOUR_CHAR)>breite)//		breite=CharWidth(FOUR_CHAR);//	if(CharWidth(EIGHT_CHAR)>breite)//		breite=CharWidth(EIGHT_CHAR);	y+=zeilenHoehe;	if(((*lHandle)->b.marked) && (y<yMax))	{		MoveTo(x+ADOC.columnOffset-COLUMN_LINE_OFFSET-HSlider-breite-3,y); // *		DrawChar(MARK_CHAR);	}#if 0	y+=zeilenHoehe;	if(y<yMax)	{		MoveTo(x+ADOC.columnOffset-COLUMN_LINE_OFFSET-HSlider- ,y); // 4/8		if((*lHandle)->b.displaymode)			DrawChar(FOUR_CHAR);		else			DrawChar(EIGHT_CHAR);	}	TextFont(saveFont);#endif	}		if((*lHandle)->b.selected && (displayMode==displayNormal))	// Selektierte Einträge invertieren	{		if(r.top)							// Bei Einträgen >0 die Linie freilassen			r.top-=zeilenHoehe/2;		LMSetHiliteMode(LMGetHiliteMode() & ~(1<<hiliteBit));		InvertRect(&r);	}	HUnlock((Handle)actset);}//// Sucht alle Daten entsprechend Y-Offset durch, bis er den ersten gefunden// hat, der auf dem Bildschirm sichtbar ist.//ListH	LookForEntry(long zeilen,ListH handle,long *y,long maxsize,IQFileType type){	REG Handle			xWindow;	REG short			temp;	REG short			i=0;	REG positionCacheP	actual;		if(!handle || !gMacWind)		return(nil);	if(!CheckEntry(handle,gMacWind))			// Dieser Eintrag nicht sichtbar?		handle=NextListH(handle,getTheNextOne);	// Nächsten Listeneintrag holen	#if CACHE	xWindow=gMacWind->MoreMem;	if(XWIN->theUnion.cache && *(XWIN->theUnion.cache))	// Cache wurde nicht gepurged	{		HLock((Handle)XWIN->theUnion.cache);		actual=*XWIN->theUnion.cache;		if(!actual->theLine)						// Fenster ist leer			return(nil);		while(handle && (zeilen>maxsize+(temp=(actual++)->theLine)))	// Solange Daten im Cache stehen		{			zeilen-=temp;							// Eintragslänge abziehen			if(!actual->theLine)				return(nil);		}		handle=(--actual)->theHandle;		HUnlock((Handle)XWIN->theUnion.cache);	}else#endif	while(handle && (zeilen>maxsize+(temp=EntryLength(handle,type)+1)))	// Solange suchen, bis alle Zeilen	{		zeilen-=temp;								// Eintragslänge abziehen		if(zeilen>=0)			handle=NextListH(handle,getTheNextOne);	// Nächsten Listeneintrag holen	}	*y=-zeilen;	return(handle);}////	Zeichen pro Zeile für gegebenen Datensatz berechnen//short	FieldWidthCalc(ListH handle){	if((*handle)->b.displaymode)			// 4 oder 8-zeilig?		return(ORG.width-ORG.width/4);		// 4, dann 75% weniger Platz	else		return(ORG.width);					// Sonst volle Breite}//// Bestimmt die Länge eines Eintrags in Zeilen//short	EntryLength(ListH handle, IQFileType type){	int		i=0,k=0,zeilen,fieldCounter=0,maske,w;	char	*d,hstate;	dataset	**actset;	REG IQFileType temp;		if(!handle)								// Keine Handle, keine Länge		return(0);		temp=type;	type=(*handle)->type;//	if(type<=DALARM)//		type=SCHEDULE;	if((type==TEL2DATA) || (type==TEL3DATA))	// 2 & 3 haben keine eigenen Einträge		type=TEL1DATA;		if((type==USERFILE2) || (type==USERFILE3))	// 2 & 3 haben keine eigenen Einträge		type=USERFILE1;		//	if(temp!=type) DebugStr("\pGülliger Typ!");		actset=(datasetH)NewHandle(sizeof(dataset));	if(MemError()!=noErr)		return(1);	HLock((Handle)actset);	d=(*actset)->data;						// Platz für einen temporären String	gCalcDateAndTimeNormally=false;			// Datum u Zeit nicht nach ASCII wandeln	CopyListToDataset(actset,handle);	gCalcDateAndTimeNormally=true;		zeilen=CountSpecialLines((*handle)->type);		if((*handle)->type!=DALARM)				// Beim Daily Alarm gibt es kein Textfeld	{		#if WYSIWYG			w=WYSIWYG;						// WYSIWYG versauen		#else			w=FieldWidthCalc(handle);		#endif				if((type==TEL1DATA) || (type==BUSINESS) || (type==DOLIST) ||		 (type==EXPENSE) || (type==TODO) || (type==SCHEDULE))	// Nur dabei gibt's "Darstellung"		{			maske=ADOC.display[type];			if(zeilen)						// "anormale" Zeilen (aus dem IQType-Feld) vorhanden?			{				fieldCounter=zeilen;		// Beim Zählen im data-Teil diese überspringen				for( ; i<zeilen ; i++ )	// Dann gucken, ob davon welche ausgeblendet sind					if(!BTstQ(maske,i))		// 0-Bit (=ausgeblendet)?						k++;				// Sowas zählen				zeilen-=k;					// Ausgeblendete von Feldzahl abziehen				if(zeilen<0)					zeilen=0;				i=k=0;			}		}		else			maske=-1;						// Sonst alle Felder zeigen (Memo)		ShortenEntry(d);					// Leerzeilen Wegcutten		while(d[i])							// Bis 0-Byte = Stringende zählen		{			if((d[i]!=CRLF) && (d[i]!=RETURN) && (k<w))	// Bei Return oder w Zeichen oder Feldende				k++;			else			{				if(BTstQ(maske,fieldCounter))	// Eine Zeile mehr, wenn das					zeilen++;				// Feld nicht ausgeblendet wurde				if(d[i]==RETURN)			// Feld zu ende?					fieldCounter++;				if((k==w) && (d[i]!=RETURN))// Zeile voll?					i--;					// dann i++ ausgleichen;				k=0;						// fängt ne neue Zeile an			}			i++;		}		if((BTstQ(maske,fieldCounter)) && (((d[i-1]!=RETURN) && (k!=w)) || ((d[i]!=RETURN) && (k==w))))	// Nicht \r-terminiert (Memo)?			zeilen++;							// Dann noch eine extra-Zeile	}	DisposHandle((Handle)actset);	return(zeilen);}short	CountSpecialLines(IQFileType type){	REG short	zeilen;		if(type>DALARM)				// Nur Termine kriegen Sonderbehandlung (Datum & Zeit)	{		if((type<DOLIST) || (type>TODO))			zeilen=0;						// Andere voll durchzählen		else			zeilen=zeilenDerTerminarten[type-DOLIST+DALARM];	}	else		zeilen=zeilenDerTerminarten[type-SCHEDULE];	// Sonst nur Text zählen			return(zeilen);}////	Kopiert einen String von einer ListHandle in einen Dataset - wichtig für//	Scheduler o.ä., wo noch weitere Daten in den String gesetzt werden//void CopyListToDataset(datasetH theSet, ListH theList){	char		hstateL,hstateD,temp;	short		i;	DateTimeRec	theDate;	ULONG		dateInSecs;	Str255		s;	//	hstateL=HLockH((Handle)theList);	// erstmal beide Handle locken//	hstateD=HLockH((Handle)theSet);		// (für strcpy)	hstateL=HGetState((Handle)theList);	HLock((Handle)theList);	hstateD=HGetState((Handle)theSet);	HLock((Handle)theSet);	(*theSet)->data[0]=0;				// Zielstring löschen	if(gCalcDateAndTimeNormally)		// Bei EntryLength nicht Fall (da schneller)	{		theDate.hour=theDate.minute=0;	// Zeit = 0, da zufällige		theDate.second=0;				// Overflows das Datum weiterschalten				// In dieser switch-Struktur werden die Daten gewandelt, die nicht in ASCII		// in der internen Strukttur stehen, sondern meist im Zeit-Teil (->t-Union).				switch((*theList)->type)		// Je nach Typ was vorhängen		{		case SCHEDULE:					// Beim Scheduler Termin und Alarm			if((*theList)->t.schedule.year>0)			{				theDate.year=(*theList)->t.schedule.year;	// Tag des Termins				theDate.month=(*theList)->t.schedule.month;				theDate.day=(*theList)->t.schedule.day;				Date2Secs(&theDate,&dateInSecs);								GetDateString(s,dateInSecs,shortDate);	// Datum kopieren				PtoCstr(s);			}else			{				theDate.day=theDate.month=theDate.year=0;	// Für AddTimeToList zu löschen				s[0]=0;			}			strcpy((*theSet)->data,(char*)s);			strcat((*theSet)->data,"\r");				AddTimeToString((*theSet)->data,(*theList)->t.schedule.shour,(*theList)->t.schedule.sminute,&theDate);			if(((*theList)->t.schedule.shour!=-1) && ((*theList)->t.schedule.ehour!=-1))			{				strcat((*theSet)->data,"-");				AddTimeToString((*theSet)->data,(*theList)->t.schedule.ehour,(*theList)->t.schedule.eminute,&theDate);			}			strcat((*theSet)->data,"\r");				AddTimeToString((*theSet)->data,(*theList)->t.schedule.ahour,(*theList)->t.schedule.aminute,&theDate);			strcat((*theSet)->data,"\r");			break;		case ANN1:						// Anniversary 1: Tag.Monat			if((*theList)->t.ann1.date>0)			{				NumToString((long)(*theList)->t.ann1.date,s);				PtoCstr(s);				strcat((*theSet)->data,(char*)s);				strcat((*theSet)->data,".");				NumToString((long)(*theList)->t.ann1.month,s);				PtoCstr(s);				strcat((*theSet)->data,(char*)s);			}			strcat((*theSet)->data,"\r");			break;		case ANN2:			if((*theList)->t.ann2.month>0)			{				NumToString((long)(*theList)->t.ann2.month,s);	// Monat kopieren				PtoCstr(s);				strcat((*theSet)->data,(char*)s);				strcat((*theSet)->data,"/");				NumToString((long)(*theList)->t.ann2.week,s);	// …Wochennummer…				PtoCstr(s);				strcat((*theSet)->data,(char*)s);				strcat((*theSet)->data,"/");				NumToString((long)(*theList)->t.ann2.day,s);	// … und noch den Wochentag				PtoCstr(s);				strcat((*theSet)->data,(char*)s);			}			strcat((*theSet)->data,"\r");			break;		case PERIOD:			if((*theList)->t.psched.syear>0)			{				theDate.year=(*theList)->t.psched.syear;	// Anfangstag				theDate.month=(*theList)->t.psched.smonth;				theDate.day=(*theList)->t.psched.sday;				theDate.hour=theDate.minute=0;				// Zeit = 0, da zufällige				theDate.second=0;							// Overflows das Datum weiterschalten				Date2Secs(&theDate,&dateInSecs);								GetDateString(s,dateInSecs,shortDate);		// Datum kopieren				PtoCstr(s);				strcat((*theSet)->data,(char*)s);			}			strcat((*theSet)->data,"\r");				if((*theList)->t.psched.eyear>0)			{				theDate.year=(*theList)->t.psched.eyear;	// Endtag				theDate.month=(*theList)->t.psched.emonth;				theDate.day=(*theList)->t.psched.eday;				Date2Secs(&theDate,&dateInSecs);								GetDateString(s,dateInSecs,shortDate);		// Datum kopieren				PtoCstr(s);				strcat((*theSet)->data,(char*)s);			}			strcat((*theSet)->data,"\r");			break;		case DALARM:			theDate.second=theDate.year=theDate.month=theDate.day=0;	// Overflows könnten das Datum weiterschalten			AddTimeToString((*theSet)->data,(*theList)->t.dalarm.hour,(*theList)->t.dalarm.minute,&theDate);			break;		case EXPENSE:			if((*theList)->t.expense.year>0)			{				theDate.year=(*theList)->t.expense.year;	// Tag der Ausgabe				theDate.month=(*theList)->t.expense.month;				theDate.day=(*theList)->t.expense.day;				Date2Secs(&theDate,&dateInSecs);								GetDateString(s,dateInSecs,shortDate);	// In ASCII wandeln				i=s[0];				PtoCstr(s);				s[i++]=RETURN;				s[i++]=0;				strcpy((*theSet)->data,(STR)s);			}else			{				(*theSet)->data[0]=RETURN;				(*theSet)->data[1]=0;			}			break;		case DOLIST: case TODO:			if((*theList)->t.todo.year>0)				// Datum gültig?			{				theDate.year=(*theList)->t.todo.year;	// Tag des Termins				theDate.month=(*theList)->t.todo.month;				theDate.day=(*theList)->t.todo.day;				Date2Secs(&theDate,&dateInSecs);								GetDateString(s,dateInSecs,shortDate);	// Datum kopieren				i=s[0];				PtoCstr(s);				s[i++]=RETURN;							// Mit Feldtrenner terminieren			}else			{				s[0]=RETURN;							// Sonst kein Datum				i=1;			}			if((*theList)->t.todo.prio!=-1)				// Priorität gültig?			{				temp=(*theList)->t.todo.prio >> 8;		// Priorität (obere 8 Bits)				if(temp)					s[i++]=temp;						// Vorhanden? Dann reinkopieren				s[i++]=(*theList)->t.todo.prio & 0xFF;	// untere 8 Bits			}			s[i++]=RETURN;							// Noch ein Return hintendran			s[i++]=0;								// Nochmal nullterminieren			strcpy((*theSet)->data,(STR)s);			break;		}	}	strcat((*theSet)->data,(*theList)->d);				// Restliche Daten ungewandelt anhängen	HSetState((Handle)theList,hstateL);					// HLock wieder aufheben	HSetState((Handle)theSet,hstateD);}////	Uhrzeit an einen Pascal-String anhängen//	ACHTUNG: theDate darf KEINE ungültigen Daten enthalten (Year, Month…),//	da nur hour und minute überschrieben werden!//void	AddTimeToString(char *s, char hour, char minute,DateTimeRec	*theDate){	ULONG			dateInSecs;	Str255			tempString;	if((hour>=0) && (hour<24) && (minute>=0) && (minute<60))	// Uhrzeit gültig?	{		theDate->hour=hour;		theDate->minute=minute;		Date2Secs(theDate,&dateInSecs);		GetTimeString(tempString,dateInSecs);		// Alarm kopieren		PtoCstr(tempString);		strcat(s,(char*)tempString);	}}//// Testet, ob der Eintrag bei den aktuellen Float-Einstellungen sichtbar// sein soll ->true<- oder nicht ->false<-//Boolean	CheckEntry(ListH handle,WindPtr w){	Handle		xWindow;	if(!w)							// Kein gültiger WindPtr?		return(true);				// Dann immer "sichtbar" zurückgeben	xWindow=w->MoreMem;	switch(XWIN->windowType)	{	case TEL1DATA:					// Bei Telefon noch Gruppe (1-3) abtesten		if(!(BTstQ(XWIN->floatVar,(*handle)->type-TEL1DATA)))			return(false);			// Falsche Gruppe: Schon mal nicht anzeigen		break;	case USERFILE1:					// Bei UserFiles entsprechend		if(!(BTstQ(XWIN->floatVar,(*handle)->type-USERFILE1)))			return(false);			// Falsche Gruppe: Schon mal nicht anzeigen		break;	}	switch(XWIN->floatDisp)			// Mark*iert und Gefunden abtesten	{		case flAll:			return(true);		case flMarked:			if((*handle)->b.marked==true)				return(true); 			break;		case flUnmarked:			if((*handle)->b.marked==false)				return(true); 			break;		case flFound:			if((*handle)->b.found==true)				return(true); 			break;		case flNotFound:			if((*handle)->b.found==false)				return(true); 			break;	}	return(false);}//// Leerzeilen am Eintragsende wegcutten//void	ShortenEntry(char *text){	short		i;		for( i=strlen(text) ; i>1 ; i--)	// String von hinten nach doppelten \r durchsuchen	{		if(text[i-1]==RETURN)		// Text[i] ist immer ein Return; wenn 2			text[i]=0;				// Aufeinanderfolgen, dann 2. wegschmeißen		else			return;	}}//// Bearbeiten-Menü wurde angeklickt//void	BearbeitenMenu(short entry){	ListH		lHandle;	Handle		xWindow;	EditRetType	result;	IQFileType	newType;	xWindow=gTopWindow->MoreMem;	lHandle=GetListH(GetOrgH(gDoc),XWIN->windowType);	switch(entry)	{	case mEditNewEntry:		newType=XWIN->windowType;		if(newType==ANN1)					// Im Calendar-Window erstellt man auch SCHEDULEs			newType=SCHEDULE;		result=Editor(nil,newType,nil);		if(result.redrawNecessary)			// Noch ein Redraw nötig?		{			if(newType==ANN1)				// Neuer Termin im Calendar				newType=SCHEDULE;			// = Redraw im Scheduler			if(result.recalcNecessary)		// Hat sich evtl. die Länge geändert?				DoMultiRedraw(newType,redrawAndRecalc,nil);				if(newType==SCHEDULE)		// Kalender und Scheduler sind immer gekoppelt					DoMultiRedraw(ANN1,redrawAndRecalc,nil);			else				DoMultiRedraw(newType,redrawAll,nil);			if(newType==SCHEDULE)			// Bei Terminen auch den Calendar redrawn				DoMultiRedraw(ANN1,redrawAll,nil);		}		UnloadSeg(Editor);		break;	case mEditSelectAll:		// Alle Einträge selektieren, die sichtbar sind		if(gDoc)		{			if(gTheEvent.modifiers & shiftKey)	// Shift, dann auch nicht sichtbare selektieren			{				MySearchOList(XWIN->windowType,"c04=1");				CLCount=0;				// Und noch zählen				MySearchOList(XWIN->windowType,"c00=S");				XWIN->selectedNo=CLCount;				DoMultiRedraw(XWIN->windowType,redrawAll,nil);			}else			{				MySearchOList(XWIN->windowType,"c04=voS");				CLCount=0;				// Und noch zählen				MySearchOList(XWIN->windowType,"c00=Sav");				XWIN->selectedNo=CLCount;				DoMultiRedraw(XWIN->windowType,redrawAll,nil);			}		}		break;	case mEditSelectNone:		// Alle Einträge deselektieren, die sichtbar sind		if(gDoc)		{			if(gTheEvent.modifiers & shiftKey)	// Shift, dann auch nicht sichtbare deselektieren			{				MySearchOList(XWIN->windowType,"c04=0");				CLCount=0;				// Und noch zählen				MySearchOList(XWIN->windowType,"c00=S");				XWIN->selectedNo=CLCount;				DoMultiRedraw(XWIN->windowType,redrawAll,nil);			}else			{				MySearchOList(XWIN->windowType,"c04=nvaS");				CLCount=0;				// Und noch zählen				MySearchOList(XWIN->windowType,"c00=Sav");				XWIN->selectedNo=CLCount;				DoMultiRedraw(XWIN->windowType,redrawAll,nil);			}		}		break;	}}////	Menüs Markieren/Demarkieren & 4/8-zeilig//VOID	DoMark(SSType what,WORD id){REG Handle		xWindow;Str255			s;REG USTR		sp = s;REG WORD		typ;REG RedrawType	mode;	if (!gTopWindow) {		OwnBeep(shit);		return;	}	xWindow=gTopWindow->MoreMem;	typ = XWIN->windowType;	GetIndString(sp,id,what);	PtoCstr(sp);	mode = redrawAll;	if (*sp == '!') {				// Recalc nötig?		mode = redrawAndRecalc;		// Ja!		sp++;	}	if (*sp == '-') sp += 3;	MySearchOList(typ,(STR)sp);	DoMultiRedraw(typ,mode,nil);	AppDocumentDirty(gDoc,true);	// Document ist jetzt dirty}/*** *	Diese Routine ermittelt den Namen eines Telefonregisters ***/Boolean		GetTelName(REG IQFileType id,USTR s){REG Boolean found = false;	if (gDoc) {		ListH	l = id<USERFILE1?ORG.telfile:ORG.userfree;	// ListH auf die Dateinamen		if (l) {						// Gibt es Namen fürs Telefonregister?			while (((*l)->type != id) && ((*l)->next))				l = (*l)->next;			// passenden Telefonnamen suchen			if (((*l)->type == id)) { 	// gefunden?				REG USTR	s1; REG USTR	s2;				strncpy((STR)s,(*l)->d,10);// String kopieren, max. 10 Zeichen lang				s[10]=0;				s1 = s; s2 = s;				while(*s1++ == ' ');	// führende Leerzeichen überspringen				s1--;				while(*s2++ = *s1++);	// String nach vorne übertragen				CtoPstr((STR)s);				found = true;			// gefunden!			}		}	}	if (!found)						// Namen gefunden, sonst aus der Resource holen		GetIndString(s,strTelefon,id-TEL1FILE+strTel1);	return(found);}////	Redraw aller Windows, für die ein Bit gesetzt ist.//void	DoBitFieldRedraw(ULONG typearray){	REG IQFileType	i;	REG	ULONG		tmp;	if(typearray&0x1F)						// SCHEDULE bis DALARM wird zu SCHEDULE		tmp=1;	else		tmp=0;	typearray=(typearray&0xffffffe0)|tmp;	if(typearray&0x3FE0)					// TEL1DATA bis TEL3FREE wird zu TEL1DATA		tmp=0x20;	else		tmp=0;	typearray=(typearray&0xffffC01F)|tmp;	if(typearray&0x30000)					// BUSINESS und BUSFREE wird zu BUSINESS		tmp=0x10000;	else		tmp=0;	typearray=(typearray&0xFFFCFFFF)|tmp;	if(typearray&0x1F800000)				// USERFILE1 bis USER3FREE wird zu USERFILE1		tmp=0x800000;	else		tmp=0;	typearray=(typearray&0xE07FFFFF)|tmp;	for( i=0 ; i<MaxIQFileType ; i++ )		if(BTstQ(typearray,i))			DoMultiRedraw(i+1,redrawAndRecalc,nil);}////	Redraw für alle Windows des aktuellen Dokuments eines bestimmten Typs//void	DoMultiRedraw(IQFileType type, RedrawType rType, ListH lHandle){	switch(rType)	{	case redrawSingle:	case redrawAll: case redrawAndRecalc:		gRedrawIQType=type;				// Bei ForAllWindows keine Parameterübergabe		gRedrawRdType=rType;		ForAllWindows((ProcPtr)DoMultiRedrawSub,gDoc,false);	// Redraw für alle Windows dieses Dokuments		if(type==SCHEDULE)										// Scheduler-Redraw? Dann		{														// Auch den Kalender neu zeichnen			gRedrawIQType=ANN1;			ForAllWindows((ProcPtr)DoMultiRedrawSub,gDoc,false);	// Redraw für alle Windows dieses Dokuments		}		break;	}}////	Redraw-Routine für alle Windows -kann von ForAllWindows aufgerufen werden-//Boolean	DoMultiRedrawSub(void){	REG positionCacheP actual;				// Pointer auf aktuell aufgebauten Cache-Eintrag	REG Handle		xWindow;	REG short		selected=0,temp;		// Zahl der selektierten Einträge (xWindStruct)	short			i;#if CACHE	long			noOfCachedEntries=0;	// Anzahl der bereits gecacheten Einträge (für Cachegröße)	short			cacheAnzahl=CACHE_STEP;	// Anzahl der noch reservierten Einträge (bis zum Nachallozieren)	Boolean			doCaching;				// Wenn FALSE, wurde Caching abgebrochen (kein Speicher frei)#endif	REG long		groesse=0;				// Gesamtzeilenzahl für die xWindStruct	ListH			lHandle;	FontInfo		inf;		if(!IsFloating(gMacWind))				// Floats haben kein MoreMem und	{										// sind hier nie erwünscht		if((gRedrawIQType==TEL2DATA) || (gRedrawIQType==TEL3DATA))			gRedrawIQType=TEL1DATA;		if((gRedrawIQType==USERFILE2) || (gRedrawIQType==USERFILE3))			gRedrawIQType=USERFILE1;		if((gRedrawIQType>ANN1) && (gRedrawIQType<=DALARM))			gRedrawIQType=SCHEDULE;		xWindow=gMacWind->MoreMem;			// Sonst den Window-Typen abtesten		if((XWIN->windowType)==gRedrawIQType)		{			if((gRedrawIQType==ANN1) && (gRedrawRdType==redrawAndRecalc) && // Kalender in Tagesübersicht zu redrawn?				(XWIN->floatVar==flDay))					UpdateDay(gMacWind);					// Dann ListManager neu versorgen					if((gRedrawRdType==redrawAndRecalc) && XWIN->cacheEnable)	// Windowinhalt geändert? (Beim Calender NIX zu berec hnen!)			{								// Dann Größe und Slider neu berechnen#if CACHE				biene();				if(XWIN->theUnion.cache)					// Gab's zu diesem Window schon einen Cache?					DisposHandle((Handle)XWIN->theUnion.cache);		// Dann verwerfen								XWIN->theUnion.cache=(positionCacheH)NewHandle(sizeof(positionCache)*(cacheAnzahl+1));				if(XWIN->theUnion.cache)				{					doCaching=true;							// Genug Speicher frei					HLock((Handle)XWIN->theUnion.cache);			// Locken, weil wir einen Pointer darauf brauchen					actual=*XWIN->theUnion.cache;			// Da isser schon				}else					doCaching=false;						// Kein Speicher, kein Cache#endif				lHandle=GetListH(GetOrgH(gDoc),gRedrawIQType);				if(gRedrawIQType==SCHEDULE)				{					i=SCHEDULE;					while(!lHandle && i<DALARM)				// Wenn Scheduler und keine Daten in ORG.schedule						lHandle=GetListH(GetOrgH(gDoc),++i);				}					while(lHandle)				// Solange suchen, bis alle Zeilen durch				{					if(CheckEntry(lHandle,gMacWind))		// Ist dieser Eintrag sichtbar?					{						HLock((Handle)lHandle);						temp=EntryLength(lHandle,gRedrawIQType)+1; // 1 für Linie#if CACHE						if(doCaching)						// Cache-Pointer ist gültig						{							actual->theLine=temp;			// Eintragsgröße abspeichern							actual++->theHandle=lHandle;	// Und entsprechende Handle dazu							noOfCachedEntries++;			// Einen Eintrag mehr gecached							if(--cacheAnzahl<0)				// Cache ist voll?							{								cacheAnzahl+=CACHE_STEP;	// Dann vergrößern								HUnlock((Handle)XWIN->theUnion.cache);	// Dazu muß er verschiebbar sein								SetHandleSize((Handle)XWIN->theUnion.cache,GetHandleSize((Handle)XWIN->theUnion.cache)+sizeof(positionCache)*CACHE_STEP);								if(MemError())				// Hat geklappt?								{									doCaching=false;		// Sonst Caching abbrechen									DisposHandle((Handle)XWIN->theUnion.cache);	// Reste wieder freigeben								}								else								{									HLock((Handle)XWIN->theUnion.cache);	// Wenn's okay ist, wieder locken									actual=(*XWIN->theUnion.cache)+noOfCachedEntries;	// und den Pointer neu berechnen								}							}						}#endif						groesse+=temp;						if((*lHandle)->b.selected)							selected++;				// Selektierte Einträge zählen						HUnlock((Handle)lHandle);					}					lHandle=NextListH(lHandle,getTheNextOne);				}#if CACHE				if(doCaching)						// War soweit alles okay mit dem Caching?				{					actual->theLine=0;				// Dann terminieren wir das Ganze					actual->theHandle=nil;					HUnlock((Handle)XWIN->theUnion.cache);	// Die Größe nochmal richtig anpassen (verkleinern)					SetHandleSize((Handle)XWIN->theUnion.cache,(noOfCachedEntries+1)*sizeof(positionCache)); // Nur soviel Platz verbraten wie nötig					HPurge((Handle)XWIN->theUnion.cache);	// Cache ist immer purgeable#if BETA					if (gCacheDisabled)						PurgeMem(16000000);			// Wenn disabelt, dann gleich weg damit#endif				}else					XWIN->theUnion.cache=nil;		// Sonst ist der Cache ungültig!				pfeil();#endif				XWIN->contentSize=groesse;			// Inhaltsgröße in Zeilen				XWIN->selectedNo=selected;			// Anzahl selektierter Einträge				XWIN->lastKlick=-1;					// Shift-Klick disabeln				GetFontInfo(&inf);					// Höhe des aktuellen Fonts				gMacWind->ScrollH=CharWidth('x');				gMacWind->ScrollV=(long)(inf.ascent+inf.descent+inf.leading);				AdjustWindow(gMacWind);				// Slider neu skalieren			}			InvalRgn(((GrafPtr)gMacWind)->visRgn);	// Bei Telefon neuzeichnen		}	}	return(false);							// Weitere Windows durchsuchen}void	testklick(void){	Point		click;	long		zeilen,y,zeilenZahl=0;	ListH		lHandle,secondHandle;	Handle		xWindow;					// Handle auf xWindStruct	short		zeilenHoehe,fieldWidth;		// Zeilenhöhe in Pixeln & Zeichen/Zeile	long		lastKlick,temp;				// Zeile mit dem letzten Klick (für Shift)	REG IQFileType	startType;	xWindow=gMacWind->MoreMem;	if(!gMacWind)		return;	lHandle=GetListH(GetOrgH(gDoc),XWIN->windowType);// Handle auf ersten Eintrag		if(XWIN->windowType==SCHEDULE)		// Wenn Scheduler und keine Daten in ORG.schedule	{		startType=SCHEDULE;				// Dann andere Terminplanereinträge durchsuchen		while((!lHandle) && (startType<DALARM))			lHandle=GetListH(GetOrgH(gDoc),++startType);	}		if(lHandle)	{		secondHandle=lHandle;					// Für Deselektion (ohne Shift)		click=gTheEvent.where;					// y-Koordinate		GlobalToLocal(&click);		zeilenHoehe=gMacWind->ScrollV;			// Zeilenhöhe beim applFont		zeilen=(--click.v+zeilenHoehe/2+oGetCtlValue(gMacWind->VSlider))/zeilenHoehe+1;		lHandle=LookForEntry(zeilen,lHandle,&y,zeilenZahl,XWIN->windowType);	}	if(gClicks==1)					// Erster Klick ins Feld	{		if(lHandle)		{#if BETA			CLCount=0;						// Test, ob selectedNo korrekt			MySearchOList(XWIN->windowType,"c00=Sav");			if(XWIN->selectedNo!=CLCount)	// Falsch?			{				OwnBeep(shit);				// Dann beepen				XWIN->selectedNo=CLCount;	// Und korrigieren			}#endif						lastKlick=XWIN->lastKlick;			switch(gTheEvent.modifiers&(shiftKey|cmdKey))	// Welche Umschalt-Taste			{			case shiftKey:						// Shift: Bereich selektieren				if(lastKlick==-1)				// Nie was angeklickt?				{								// Dann wie Command					if((*lHandle)->b.selected^=1)	// Hinterher selektiert?						XWIN->selectedNo++;			// Dann Gesamtselektiertzahl erhöhen					else						XWIN->selectedNo--;					DoMultiRedraw(XWIN->windowType,redrawSingle,lHandle);					lastKlick=zeilen;				}else				{					temp=zeilen;					DeselectAllEntries(XWIN->windowType);					XWIN->selectedNo=0;					secondHandle=(ListH)StripAddress(LookForEntry(lastKlick,secondHandle,&y,zeilenZahl,XWIN->windowType));					while(lHandle && ((ListH)StripAddress(lHandle)!=secondHandle))					{						if(!(*lHandle)->b.selected)						{							(*lHandle)->b.selected=1;							XWIN->selectedNo++;						}else							SysBeep(20);						if(zeilen<lastKlick)		// Diesmal tiefer geklickt?							lHandle=NextListH(lHandle,getTheNextOne);						else							lHandle=NextListH(lHandle,getThePreviousOne);					}					if(lHandle)					{						(*lHandle)->b.selected=1;						XWIN->selectedNo++;					}					DoMultiRedraw(XWIN->windowType,redrawAll,lHandle);					lastKlick=temp;				}				break;			case cmdKey:						// Command: Einzelnen toggeln				if((*lHandle)->b.selected^=1)	// Hinterher selektiert?					XWIN->selectedNo++;			// Dann Gesamtselektiertzahl erhöhen				else					XWIN->selectedNo--;				DoMultiRedraw(XWIN->windowType,redrawSingle,lHandle);				break;			default:							// Ohne alles: einzelnen selektieren				if((*lHandle)->b.selected==0)	// Nur wenn Feld deselektiert				{								// (Sonst ignorieren)					DeselectAllEntries(XWIN->windowType);					(*lHandle)->b.selected=1;		// angeklickten selektieren					XWIN->selectedNo=1;				// Genau einer selektiert					DoMultiRedraw(XWIN->windowType,redrawAll,lHandle);					lastKlick=zeilen;				}				break;			}		}	XWIN->lastKlick=lastKlick;	}else	{EditRetType	result;		result=Editor(lHandle,XWIN->windowType,nil);	// Editor aufrufen		if(result.redrawNecessary)			// Noch ein Redraw nötig?			if(result.recalcNecessary)		// Hat sich evtl. die Länge geändert?				DoMultiRedraw(XWIN->windowType,redrawAndRecalc,nil);				if(XWIN->windowType==SCHEDULE)	// Bei geänderten Terminen					DoMultiRedraw(ANN1,redrawAndRecalc,nil);	// …auch den Kalender updaten			else				DoMultiRedraw(XWIN->windowType,redrawSingle,lHandle);		UnloadSeg(Editor);	}}////	Löscht bei allen Einträgen der Liste das "selected"-Bit//void DeselectAllEntries(IQFileType type){REG ListH		lHandle;REG IQFileType	startType;//	MySearchOList(type,"c04=0");	lHandle=GetListH(GetOrgH(gDoc),type);// Handle auf ersten Eintrag		if(type==SCHEDULE)					// Wenn Scheduler und keine Daten in ORG.schedule	{		startType=SCHEDULE;				// Dann andere Terminplanereinträge durchsuchen		while((!lHandle) && (startType<DALARM))			lHandle=GetListH(GetOrgH(gDoc),++startType);	}		while(lHandle)	{		(*lHandle)->b.selected=0;		lHandle=NextListH(lHandle,getTheNextOne);	}}////	Eigener SearchOList-Aufruf, der die Termineinträge verkettet//void	MySearchOList(IQFileType type,char *s){	IQFileType		i;		SearchOList(GetOrgH(gDoc),type,s);		// Erstmal den normalen	if(type==SCHEDULE)						// Scheduler?		for(i=ANN1 ; i<=DALARM ; i++)		// Dann auch noch Anniversary - Daily Alarm			SearchOList(GetOrgH(gDoc),i,s);	if(type==TEL1DATA)						// Telefon?		for(i=TEL2DATA ; i<=TEL3DATA ; i++)	// Dann auch noch Tel2 und Tel3			SearchOList(GetOrgH(gDoc),i,s);	if(type==USERFILE1)						// Telefon?		for(i=USERFILE2 ; i<=USERFILE3 ; i++)	// Dann auch noch Tel2 und Tel3			SearchOList(GetOrgH(gDoc),i,s);}