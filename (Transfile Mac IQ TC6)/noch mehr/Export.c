/*** *	Export-Dialog ***/#include "rsrcDefines.h"#include "Geos.h"#include "Windows.h"#include "GeosMore.h"#include "List.h"#include "DialogLib.h"#include "Memo.h"#include "AktDocStruct.h"#include "Utilities.h"#include "GlobalLib.h"#include "GlobalStruct.h"#include "File.h"#include <String.h>#include <stdio.h>#define	dExport			147#define	sSharpNames		1000enum {									// die verschiedenen Export-Formate	ExFmBasic = 1,	ExFmSYLK,	ExFmTab,	ExFmKomma,	ExFmSerienbrief};short		ExportTyp = ExFmBasic;		// aktuelles Export-FormatdatasetH	ExportData;					// Handle auf die Export-Daten-Strukturshort		ExSatzNo;					// aktueller Datensatz (Ausgabe) 1…nvoid		DoExport(void);/*** *	String in die Exportdatei schreiben ***/short		ExFRefNum;				// RefNum für die AusgabeOSErr		ExString(char *s);OSErr		ExString(char *s){OSErr		err;long		count = Strlen(s);	err = FSWrite(ExFRefNum,&count,s);	if (!err)		if (count != Strlen(s))			err = ioErr;	return(err);}/*** *	Header für den Export schreiben ***/OSErr		ExportHeader(void);OSErr		ExportHeader(void){OSErr		err = noErr;char		s[200];short		i;	switch(ExportTyp) {	case ExFmBasic:						break;	case ExFmSYLK:	sprintf(s,"ID;PTransfile Mac IQ\rB;Y%u;X%u\r",						*(short*)((*ExportData)->data+2),						*(short*)((*ExportData)->data));					err = ExString(s);					break;	case ExFmTab:						break;	case ExFmKomma:						break;	case ExFmSerienbrief:					s[0] = 0;					for(i=0;i<*(short*)((*ExportData)->data);i++) {						if (i != 0) strcat(s,";");						strcat(s,(char*)(*ExportData)->text[i]);					}					strcat(s,"\r");					err = ExString(s);					break;	}	return(err);}/*** *	Daten für den Export schreiben ***/void		AppendString(ListH l,register short i,char *s,char *sc);void		AppendString(ListH l,register short i,char *s,char *sc){short	index = *(char*)((*ExportData)->data+4+i-1);char	*p = &(*l)->d[0];char	c = 13;	for(i=0;i<index;i++) {			// unerwünschte Index überlesen		do {			c = *p++;		} while ((c != 13)&&(c != 0));		if (c == 0) break;			// Ende erreicht!	}	if (!c) return;					// Stringende bereits erreicht? Ja => raus	do {		c = *p;						// übertragen		for(i=0;i<Strlen(sc);i += 2) {			if(sc[i] == c) c = sc[i+1];		}		*s++ = c;		c = *p++;					// Zeichen nochmal holen	} while ((c != 13)&&(c != 0));	*--s = 0;						// Stringende setzen}OSErr		ExportMain(ListH l);OSErr		ExportMain(ListH l){OSErr		err = noErr;char		s[4200];short		i;	s[0] = 0;		// String löschen	switch(ExportTyp) {	case ExFmSYLK:	for(i=1;i<=*(short*)((*ExportData)->data);i++) {						if (i == 1)							sprintf(s,"C;Y%u;X%u;K\"",ExSatzNo,i);						else							sprintf(s,"C;X%u;K\"",i);						AppendString(l,i,s+Strlen(s),"\r \"'");						strcat(s,"\"\r");						err = ExString(s);			// String schreiben						if (err) break;					}					break;	case ExFmTab:	for(i=1;i<=*(short*)((*ExportData)->data);i++) {						if (i != 1) strcat(s,"\t");						AppendString(l,i,s+Strlen(s),"\t\013\r\035");					}					strcat(s,"\r");					err = ExString(s);				// String schreiben					break;	case ExFmBasic:		case ExFmKomma:	for(i=1;i<=*(short*)((*ExportData)->data);i++) {						if (i == 1)							strcat(s,"\"");						else							strcat(s,",\"");						AppendString(l,i,s+Strlen(s),"\r \"'");						strcat(s,"\"");					}					strcat(s,"\r");					err = ExString(s);				// String schreiben					break;	case ExFmSerienbrief:					for(i=1;i<=*(short*)((*ExportData)->data);i++) {						if (i == 1)							strcat(s,"\"");						else							strcat(s,";\"");						AppendString(l,i,s+Strlen(s),"\r \"'");						strcat(s,"\"");					}					strcat(s,"\r");					err = ExString(s);				// String schreiben					break;	}	ExSatzNo++;	return(err);}/*** *	Footer für den Export schreiben ***/OSErr		ExportFooter(void);OSErr		ExportFooter(void){OSErr	err = noErr;	switch(ExportTyp) {	case ExFmSYLK:	err = ExString("E\r");					break;	case ExFmBasic:		case ExFmTab:		case ExFmKomma:		case ExFmSerienbrief:					break;	}	return(err);}/*** *	Fileselector und Datei erzeugen für den Export ***/OSErr		ExportFile(short type);OSErr		ExportFile(short type){OSErr				err = noErr;FInfo				f;StandardFileReply	reply;long				fpos;Str63				untitled;OSType				saveType;	while(1) {			// WHILE nehme ich, damit BREAK funktioniert!		GetIndString(untitled,STRcommon,strUNTITLED);// einen “Dummy”-Namen setzen		CopyPString(reply.sfFile.name,untitled);		if (!DisplayPutFile(&reply,false)) break;	// Daten wegschreiben? Nein!		biene();		saveType = gG.FileTypes[0]; gG.FileTypes[0] = 'TEXT';	// Backup-Filetype		err = CreateOpenFile(&(reply.sfFile),&ExFRefNum);		gG.FileTypes[0] = saveType;		if (err) break;		FCopyResource(&reply.sfFile,'STR ',-16396,'STR ',-16396);	// Resource übertragen		if (BTstQ(reply.sfFlags,isStationery)) { // Stationery?			err = FGetFInfo(&reply.sfFile,&f);			if (err) break;			f.fdFlags |= 1<<isStationery;		// Stationery erzeugen			err = FSetFInfo(&reply.sfFile,&f);			if (err) break;		}		err = SetFPos(ExFRefNum,fsFromStart,0);	// an den Dateistart		if (err) break;		err = ExportHeader();		if (!err) {			ExSatzNo = 1;						// erster Datensatz			CLFErr = noErr;			CLFProc = ExportMain;			SearchList(GetListH(GetOrgH(gDoc),type),"c03=v");	// Daten senden			CLFProc = Return;			err = CLFErr;						// erzeugter Fehlercode		}		if (!err)			err = ExportFooter();		if (!err)			err = GetFPos(ExFRefNum,&fpos);		// Dateiende setzen		if (!err)			err = SetEOF(ExFRefNum,fpos);		FSClose(ExFRefNum);		if (err)			FDelete(&reply.sfFile);		FFlushVol(&reply.sfFile);	// Volume updaten		break;						// Schleife stets am Ende verlassen	}	CheckOSError(err);	pfeil();}/*** *	Export-Dialog ***/Boolean		DoExportSub(void);void	DoExport(void){WindPtr		w;						// Windowhandle vom obersten FensterHandle		xWindow;IQFileType	typ;	if (!gDoc) return;				// kein Dokument offen 	w = gTopWindow;					// oberstes Window 	if (!w) return;					// keins offen…	xWindow = w->MoreMem;	ExportData = (datasetH)NewHandle(sizeof(dataset));	CheckOSError(MemError());	if (!ExportData) return;	typ = XWIN->windowType;	switch(typ) {//	case ANN1://	case SCHEDULE://					typ = SCHEDULE;	case TEL1DATA:	case TEL2DATA:	case TEL3DATA:	case BUSINESS:	case MEMO:					FillOut(typ,ExportData);		// Feldnamen eintragen					HLockH((Handle)((WindowPeek)w)->titleHandle);					ParamText(*((WindowPeek)w)->titleHandle,0L,0L,0L);	// Windowtitel einsetzen					if (DoExportSub()) {			// Exportieren?						CLCount=0;					// Zähler = 0						SearchList(GetListH(GetOrgH(gDoc),typ),"c00=v");						*(short*)((*ExportData)->data+2) = CLCount;	// die Anzahl merken						ExportFile(typ);					}					HUnlock((Handle)((WindowPeek)w)->titleHandle);					DisposHandle((Handle)ExportData);					ExportData = nil;	}}/*** *	Export-Dialog ***/Boolean		DoExportSub(void){DialogPtr		d;					// Ptr auf diverse Dialogeshort			button;				// Exit-ButtonListHandle		ls,ld;				// für die Auswahllistenshort			i;					// allg. VariableCell			c;					// Zellen-AdresseStr63			s;					// String für Kopierarbeiten	d = GetCenteredDialog(dExport,nil);	if (!d) return(false);			// Dialog nicht zu öffnen	ls=NewList(d,4,false,true,0);	(*ls)->selFlags = lNoExtend|lUseSense|lExtendDrag;	// Flags für Mehrfachselektierung	ld=NewList(d,5,false,true,0);		// Destination-Liste	(*ld)->selFlags = lNoExtend|lUseSense|lExtendDrag;	// Flags für Mehrfachselektierung	{	short i,j; Cell c; unsigned char *s;		for(i=0;i<MAX_NAMES-1;i++) {			s = (*ExportData)->text[i];			if (s[0] == END_OF_LIST) break;	// Ende der Liste			AddListMgr(PtoCstr(s),ls);		// an die Liste anhängen			if (BTstQ((*ExportData)->visible,i)) {	// Zelle dargestellt?				AddListMgr((char*)s,ld);	// dann auch gleich in die Export-Liste			}		}	}	LDoDraw(true,ls);	LDoDraw(true,ld);	NewPopup(d,9,161,11,ExportTyp);				// zu suchende Gruppe	while (d) {		if (FindSelCell(ls)<0) {				// im Sourcebereich eine Zelle selektiert?			HiliteButton(d,7,kCntlInactive);	// Kopieren disablen		} else {			HiliteButton(d,7,kCntlActive);		// Kopieren enablen		}		if (FindSelCell(ld)<0) {				// im Zielbereich eine Zelle selektiert?			HiliteButton(d,8,kCntlInactive);	// Löschen disablen		} else {			HiliteButton(d,8,kCntlActive);		// Löschen enablen		}		if ((*ld)->dataBounds.bottom)			HiliteButton(d,1,kCntlActive);		// Export enablen		else			HiliteButton(d,1,kCntlInactive);	// Export disablen		OutlineDialogItem(d,1);					// Default-Button zeichnen		ModalDialog((ModalFilterProcPtr)OwnDialogFilter,&button);		if ((button==1)||(button==3)) break;	// Ok, Abbruch		switch(button) {		case 7:	do {				c.h = 0; c.v = FindSelCell(ls);	// kopieren				LSetSelect(false,c,ls);			// Zelle deselecten				i = 255;						// maximal 255 Bytes holen				LGetCell(&s[1],&i,c,ls);		// Text aus der Zelle holen				s[0] = i;						// echte Länge setzen				if (FindSelCell(ld)<0) {		// nix selektiert?					c.v = AddListMgr(PtoCstr(s),ld);// an die Liste anhängen				} else {					c.v = FindSelCell(ld);					LSetCell(&s[1],s[0],c,ld);	// Text in die Zelle setzen					LSetSelect(false,c,ld);		// Zelle deselektieren				}				} while(FindSelCell(ls)>=0);				break;		case 8:	do {				LDelRow(1,FindSelCell(ld),ld);	// Löschen => Zelle wegwerfen				} while(FindSelCell(ld)>=0);				break;		case 9:	ExportTyp = GetPopupValue(d,9);	// Wert vom Popup-Menü merken				break;		}	}	HLockH((Handle)ExportData);	for(i=0;i<(*ld)->dataBounds.bottom;i++) {	// alle Zellen durchsuchen		short j;		c.h = 0; c.v = i;		j = 255;								// maximal 255 Bytes holen		LGetCell(&s[1],&j,c,ld);				// Text aus der Zelle holen		s[0] = j;								// echte Länge setzen		c.v = 0;								// ab Feld 0 suchen!		if (!LSearch(&s[1],s[0],nil,&c,ls))			DebugStr("\pLSearch-Index nicht gefunden");		*(char*)((*ExportData)->data+4+i) = c.v;// Index merken;	}	*(char*)((*ExportData)->data+4+i) = -1;		// Ende markieren	(*ExportData)->text[0][0] = END_OF_LIST;	// Ende der Liste	for(i=0;i<(*ld)->dataBounds.bottom;i++) {	// alle Zellen durchsuchen		short j;		c.h = 0; c.v = i;		j = 255;							// maximal 255 Bytes holen		LGetCell(&s[1],&j,c,ld);			// Text aus der Zelle holen		s[0] = j;							// echte Länge setzen		CopyPString((*ExportData)->text[i],s);		PtoCstr((*ExportData)->text[i]);		(*ExportData)->text[i+1][0] = END_OF_LIST;// Ende der Liste	}	*(short*)((*ExportData)->data) = i;		// Anzahl merken;	HUnlock((Handle)ExportData);	DisposeObjects(d);	DisposeDialog(d);	return((button == 1)==true);}