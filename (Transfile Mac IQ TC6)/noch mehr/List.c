/*** *	Routinen für die Listenverwaltung der eigenen Strukturen ***/#include "List.h"#include "AktDocStruct.h"#include "Document.h"#include "IQComm.h"#include "Utilities.h"#include "GlobalLib.h"#include "DialogLib.h"#include "GeosMore.h"#include "CheckList.h"#include <String.h>#include <Packages.h>#include "Memo.h"				// Für 'v'isible-Bit#include "MySound.h"short	SuchProc(ListH l,LONG *offset,Boolean IgnoreBig,char *SuchBegriff,Boolean ersetzen,char *ErsetzBegriff);	// Suchprozedur/*** *	C-String in Großbuchstaben wandeln (mit Mac-OS-Routine) ***/Boolean	CharCmp(register char c1,char c2,Boolean flag);Boolean	CharCmp(register char c1,char c2,Boolean flag){unsigned char	c;	if (!flag) return(c1 == c2);	// Groß- Kleinschreibung beachten? => das ist leicht	UppercaseText(&c2,1,smSystemScript);	// Pascal-String in Großbuchstaben wandeln	return(c1 == c2);				// gewandelte Zeichen vergleichen}/*** *	Suchen, ob der Suchstring im Datensatz steht. * *	Die ListHandle _MUSS_ gelockt sein!!! ***/short		DoSuch(STR SuchBegriff,STR *st,STR *sp,Boolean IgnoreBig);short		DoSuch(STR SuchBegriff,STR *st,STR *sp,Boolean IgnoreBig){REG STR		s = *st;REG STR		savepos = *sp;REG char	*t;REG char	c;REG Boolean found = false;		// Default: nicht gefunden	t = SuchBegriff;	savepos = s;	while((*s)&&(!found)) {		c = *t++;					// nächstes Zeichen im Suchbegriff holen		switch(c) {		case '*':	c = *t++;		// Folgezeichen holen					while(c == '*')	// doppelte Joker überspringen						c = *t++;					if (!c) {		// Suchstring “ganz” am Ende?						while((*s) && (*s != '\r') && (*s != '\t')) s++;	// bis zum Stringende skippen						found = true;	// dann: gefunden!						break;					}					if ((!*s) || (*s == '\r')) {// Zeile zuende (aber es muß noch was folgen)?						s = savepos+1;						t = SuchBegriff;	// Zeichen paßte nicht (von vorne los)						savepos = s;						break;				// nicht gefunden!!!					}					*st = s; *sp = savepos;					found = DoSuch(--t,st,sp,IgnoreBig);					s = *st; if (!found) savepos = *sp;					break;		case '?':	s++;			// Joker => Zeichen ignorieren					break;		case 0:		found = true;	// Stringende vom Suchbegriff => gefunden					break;		default:					if (CharCmp(c,*s,IgnoreBig))						s++;		// Zeichen paßt => weiter					else {						s = savepos+1;						t = SuchBegriff; // Zeichen paßte nicht (von vorne los)						savepos = s;					}		}	}	if (!*t) found = true;	*st = s;	*sp = savepos;	return(found);}short	SuchProc(REG ListH l,LONG *offset,Boolean IgnoreBig,char *SuchBegriff,Boolean ersetzen,char *ErsetzBegriff){char		*savepos;REG char	c;REG Boolean found = false;		// Default: nicht gefundenchar		*s;	s = (*l)->d + *offset;			// Ptr auf den zu durchsuchenden String	*offset = -1;					// Offset verwerfen	if (IgnoreBig == true) {		// Groß-/Kleinschreibung ignorieren?		CtoPstr(SuchBegriff);		UppercaseText(SuchBegriff+1,SuchBegriff[0],smSystemScript);	// Pascal-String in Großbuchstaben wandeln		PtoCstr((USTR)SuchBegriff);	}	found = DoSuch(SuchBegriff,&s,&savepos,IgnoreBig);	// rekursiv suchen	if (ersetzen && found) {		// Ersetzen?		REG ULONG	len = Strlen(ErsetzBegriff);// Länge vom zu ersetzenden Begriff		REG LONG	delta = len - (s - savepos);// Differenz zwischen neu <-> alt		REG ULONG	size = GetHandleSize((Handle)l);	// Länge der Datenstruktur		REG STR		base = (void*)&(**l);		// Basisadresse der Handle		REG OSErr	err = noErr;				// Default: kein Fehler		if (size >= 8192) return(false);		// Datensatz wird zu lang!		if (!CheckMem(30000)) {					// kein Speicher mehr?			return(false);						// dann raus!		}		if (delta < 0) {							// Ergebnis wird kürzer			BlockMove(s,savepos + len,base + size - s);			SetHandleSize((Handle)l,size + delta);			// Struktur verkleinern		} else if (delta > 0) {						// Ergebnis wird länger			savepos = (VOID*)(savepos - base);		// Anfangsadresse abziehen			s = (VOID*)(s - base);					// Anfangsadresse abziehen			HUnlock((Handle)l);			SetHandleSize((Handle)l,size + delta);			// Struktur vergrößern			HLock((Handle)l);			base = (STR)*l;							// Basisadresse der Handle			savepos = (LONG)savepos + base;			// evtl. verschobene Basisadresse			s = (LONG)s + base;						// wieder hinzuaddieren			err = MemError();						// reichte der Speicher nicht?			if (!err) {				BlockMove(s,savepos + len,base + size - s);			}		}		if (!err)			BlockMove(ErsetzBegriff,savepos,len);	// ersetzenden Begriff einsetzen 		*offset = savepos + len - (STR)&(*l)->d;		AppDocumentDirty(gDoc,true);				// Dokument ist “dirty”	}	return(found);}/*** *	Listeneintrag auf bestimmte Bedinungen abtesten ***/short		CLEntry1(void);short		CLEntry2(void);short		CLEntry3(void);short		CLEntry4(void);short		GetCLVar(void);short		CLGetDez(void);char		*CLCond;		// Ptr auf die globale ConditionListH		CLList;			// Handle auf das aktuelle ListenelementJumpBuffer	CLError;		// Rücksprung im Fehlerfalltypedef	short (*CLAktionFunk)(ListH h,short flag);CLAktionFunk	CLAktionFList[100];		// 100 Funktionen für Aktionen sind möglichshort		CLGetDez(void)				// 2stellige Dezimalzahl aus dem String holen{REG short	i;	i = (*CLCond++ - '0') * 10;	i += *CLCond++ - '0';	return(i);}short		GetCLVar(void){REG Boolean		flag = false;	switch(*CLCond++) {					// Variable auswerten	case '0':	flag = false;			// stets False				break;	case '1':	flag = true;			// stets True				break;	case 't':	flag = (*CLList)->type == CLGetDez();				break;					// stimmt der Typ?	case 's':	{	Boolean f;			// Case-Sensitiv-Flag?					char	s[128];		// Suchbegriff-Buffer					register char	*sp = &s[0];// Ptr auf den Suchbegriff					char	e[128];		// Ersetzbegriff-Buffer					register char	*ep = &e[0];// Ptr auf den Ersetzbegriff					register Boolean	ersetzen = false;				f = *CLCond == '+';		// Case-Insensitiv?				if (f) CLCond++;				if (*CLCond++ != '|') f_LongJump(CLError,CLNOANF);				while((*CLCond != 0)&&(*CLCond != ';')&&(*CLCond != '|'))					*sp++ = *CLCond++;			// Suchbegriff kopieren				*sp = 0;				if ((*CLCond == 0)||(*CLCond == ';'))					f_LongJump(CLError,CLNOEND);	// Nein! => Fehler: Ausdruck zuende				if (*++CLCond == '>') {	// Ersetzen?					CLCond++;					while((*CLCond != 0)&&(*CLCond != ';')&&(*CLCond != '<'))						*ep++ = *CLCond++;				// Suchbegriff kopieren					if ((*CLCond == 0)||(*CLCond == ';'))						f_LongJump(CLError,CLNOEND);	// Nein! => Fehler: Ausdruck zuende					CLCond++;					ersetzen = true;				}				*ep = 0;				{ LONG offset = 0; Boolean flaggy;					do {						flaggy = SuchProc(CLList,&offset,f,s,ersetzen,e);						flag |= flaggy;					} while(flaggy && (offset>0));				}				}				break;	case 'c':	flag = (*CLAktionFList[CLGetDez()])(CLList,flag);				break;	case 'S':	flag = (*CLList)->b.selected;				break;	case 'F':	flag = (*CLList)->b.found;				break;	case 'M':	flag = (*CLList)->b.marked;				break;	case 'A':	flag = (*CLList)->b.alarm;	// Flags direkt abfragen				break;	case 'D':	flag = (*CLList)->b.displaymode;				break;	case 'v':	flag = gTopWindow?CheckEntry(CLList,gTopWindow):false;	// 'v'isible: Eintrag ist nach				break;						// Float-Einstellungen sichtbar	}	return(flag);}// oberste Ebene: Klammerauswertung und Variablenshort		CLEntry4(void){REG Boolean		flag;	if (*CLCond == '(') {				// Klammernauswertung		CLCond++;		flag = CLEntry1();				// wieder (fast) zur obersten Ebene		if (*CLCond++ != ')') {			// schließende Klammer auch vorhanden?			f_LongJump(CLError,CLNOKLAM);// Nein! => Fehler		}		return(flag);	}	return(GetCLVar());					// Variablenwert zurückgeben}// 3. Ebene: Vorzeichenauswertungshort		CLEntry3(void){REG Boolean		flag;	if (*CLCond == 'n') {				// NOT		CLCond++;		flag = !CLEntry4();	} else		flag = CLEntry4();	return(flag);}// 2. Ebene: “Punkt”rechnungshort		CLEntry2(void){REG Boolean		flag;	flag = CLEntry3();	while((*CLCond == 'a')&&(flag != false)) {	// AND?		CLCond++;		flag &= CLEntry3();	}	return(flag);}// 1. Ebene: “Strich”rechnungshort		CLEntry1(void){REG Boolean		flag;	flag = CLEntry2();	while((*CLCond == 'o')&&(flag != true)) {		switch(*CLCond++) {		case 'o':	flag |= CLEntry2();	// OR					break;		}	}	return(flag);}// 0. Ebene: Funktionsaufruf, Aufruf der höheren Ebenenshort		CheckListEntry(ListH l,char *cond){REG Boolean	flag;WORD		num = -1;						// keine globale Funktion vorhandenWORD		error;BYTE		state = HGetState((Handle)l);			// Datensatz-Status merken	CLCond = cond;							// globale Funktion setzen	CLList = l;	HLock((Handle)l);	error = f_SetJump(CLError);				// Fehlerrücksprung setzen	if (error) {		OwnBeep(shit);		DebugStr("\pSyntaxfehler in der Suchsprache!");		return(error);						// und Fehlercode zurückgeben	}	if (*CLCond == 'c') {		CLCond++;		num = CLGetDez();					// Funktionsnummer merken		if (*CLCond++ != '=') {				// wirklich eine Zuweisung?			CLCond = cond;					// Nein, normaler Ausdruck…			num = -1;		}	}	flag = CLEntry1();						// Ausdruck auswerten//	if ((*CLCond != ';')&&(*CLCond != 0))	// Ende vom Ausdruck auch erreicht?//		f_LongJump(CLError,CLNOEND);		// Nein! => Fehler	if (num>=0) {							// noch eine Funktion aufrufen?		flag = (*CLAktionFList[num])(CLList,flag);	}	HSetState((Handle)l,state);	return(flag);}/*** *	Aktion-Funktionen für die Suchroutine ***/short		CLFCount(ListH l,short flag);short		CLFFound(ListH l,short flag);short		CLFListAdd(ListH l,short flag);short		CLFCallSub(ListH l,short flag);short		CLFSelect(ListH l,short flag);short		CLFMarked(ListH l,short flag);short		CLFDisplaymode(ListH l,short flag);short		CLFList1(ListH l,short flag);short		CLFList2(ListH l,short flag);short		CLFList3(ListH l,short flag);short		CLFupper(REG ListH l,short flag);short		CLFlower(REG ListH l,short flag);short		CLFcaps(REG ListH l,short flag);short		CLFListSort(REG ListH l,short flag);short		CLFUser1(ListH l,short flag);short		CLFUser2(ListH l,short flag);short		CLFUser3(ListH l,short flag);CLAktionFunk	CLAktionFList[100] = {					CLFCount,			// 00 : CLCount-Zähler hochzählen					CLFFound,			// 01 : Found-Flag setzen/löschen					CLFListAdd,			// 02 : Element an CLFList anhängen					CLFCallSub,			// 03 : Funktion für ListH aufrufen (IMMER wieder										//		auf “Return” setzen!!!)					CLFSelect,			// 04 : Selektiert-Flag setzen/löschen					CLFMarked,			// 05 : Markiert-Flag setzen/löschen					CLFDisplaymode,		// 06 : Displaymode-Flag setzen/löschen					CLFList1,			// 07 : Typ auf Telefondata 1 setzen					CLFList2,			// 08 : Typ auf Telefondata 2 setzen					CLFList3,			// 09 : Typ auf Telefondata 3 setzen					CLFupper,			// 10 : Eintrag in Großbuchstaben wandeln					CLFlower,			// 11 : Eintrag in Großbuchstaben wandeln					CLFcaps,			// 12 : Erste Buchstaben eines Wortes in Großbuchstaben wandeln					CLFListSort,		// 13 : Element in CLFList einsortieren					CLFUser1,			// 14 : Typ auf Userfile 1 setzen					CLFUser2,			// 15 : Typ auf Userfile 2 setzen					CLFUser3			// 16 : Typ auf Userfile 3 setzen				};short		CLCount;short		CLFCount(REG ListH l,short flag){	if (flag) {							// Bedingung erfüllt?		CLCount++;						// dann hochzählen	}	return(flag);}short		CLFFound(REG ListH l,short flag){	if (flag) {							// Bedingung erfüllt?		(*l)->b.found = true;			// dann gefunden	} else {		(*l)->b.found = false;			// sonst nicht gefunden	}	return(flag);}ListHandle	CLFList;short		CLFListAdd(REG ListH l,short flag){	if (flag) {		if (l) {						// Listen-Struktur vorhanden?			AddListMgr((*l)->d,CLFList);	// an die Liste anhängen		}	}	return(flag);}short		CLFListSort(REG ListH l,short flag){	if (flag) {		if (l) {						// Listen-Struktur vorhanden?			SortToListMgr((*l)->d,CLFList);	// in die Liste einsortieren		}	}	return(flag);}OSErr		(*CLFProc)(ListH l) = Return;	// Funktion für SendenOSErr		CLFErr;short		CLFCallSub(REG ListH l,short flag){	if (flag) {		if (!CLFErr) {					// nur aufrufen, wenn noch KEIN Fehler			CLFErr = (*CLFProc)(l);		// Funktion aufrufen		}	}	return(flag);}short		CLFSelect(REG ListH l,short flag){	if (flag) {							// Bedingung erfüllt?		(*l)->b.selected = true;		// dann selektieren	} else {		(*l)->b.selected = false;		// sonst nicht selektieren	}	return(flag);}short		CLFMarked(REG ListH l,short flag){	if (flag) {							// Bedingung erfüllt?		(*l)->b.marked = true;			// dann selektieren	} else {		(*l)->b.marked = false;			// sonst nicht selektieren	}	return(flag);}short		CLFDisplaymode(REG ListH l,short flag){	if (flag) {							// Bedingung erfüllt?		(*l)->b.displaymode = true;		// dann selektieren	} else {		(*l)->b.displaymode = false;	// sonst nicht selektieren	}	return(flag);}short		CLFList1(REG ListH l,short flag){	if (flag)						// Bedingung erfüllt?		(*l)->type = TEL1DATA;		// dann Typ neu setzen	return(flag);}short		CLFList2(REG ListH l,short flag){	if (flag)						// Bedingung erfüllt?		(*l)->type = TEL2DATA;		// dann Typ neu setzen	return(flag);}short		CLFList3(REG ListH l,short flag){	if (flag)						// Bedingung erfüllt?		(*l)->type = TEL3DATA;		// dann Typ neu setzen	return(flag);}short		CLFUser1(REG ListH l,short flag){	if (flag)						// Bedingung erfüllt?		(*l)->type = USERFILE1;		// dann Typ neu setzen	return(flag);}short		CLFUser2(REG ListH l,short flag){	if (flag)						// Bedingung erfüllt?		(*l)->type = USERFILE2;		// dann Typ neu setzen	return(flag);}short		CLFUser3(REG ListH l,short flag){	if (flag)						// Bedingung erfüllt?		(*l)->type = USERFILE3;		// dann Typ neu setzen	return(flag);}short		CLFupper(REG ListH l,short flag){Str255		s;REG STR		adr = (STR)&(*l)->d;REG WORD	len = Strlen(adr);REG WORD	i;	if (flag) {						// Bedingung erfüllt?		if (gScriptMgrVersion >= 0x700) {			UpperText(adr,len);		} else if (gScriptMgrVersion >= 0x200) {			UprText(adr,len);		} else {			while(len>0) {				i = MIN(255,len);				BlockMove(adr,&s[1],i);				s[0] = i;				// ein Pascal-String…				UppercaseText(s+1,s[0],smSystemScript);				BlockMove(&s[1],adr,i);				len -= i;				adr += i;			}		}	}	return(flag);}short		CLFlower(REG ListH l,short flag){REG STR		adr = (STR)&(*l)->d;REG WORD	len = Strlen(adr);	if (flag) {						// Bedingung erfüllt?		if (gScriptMgrVersion >= 0x700) {			LowerText(adr,len);		} else if (gScriptMgrVersion >= 0x200) {			LwrText(adr,len);		}	}	return(flag);}short		CLFcaps(REG ListH l,short flag){REG STR		adr = (STR)&(*l)->d;REG WORD	len = Strlen(adr);REG UCHAR	c;UCHAR		stemp;	if (flag) {						// Bedingung erfüllt?		if (gScriptMgrVersion >= 0x700)			LowerText(adr,len);		else if (gScriptMgrVersion >= 0x200)			LwrText(adr,len);		while(c = *adr) {			if (c > '@') {			// ein Buchstabe?				stemp = c;			// in einen Großbuchstaben wandeln				if (gScriptMgrVersion >= 0x700)					UpperText((STR)&stemp,1);				else if (gScriptMgrVersion >= 0x200)					UprText((STR)&stemp,1);				*adr = stemp;				while(c = *adr) {					if (c < '@') break;					adr++;				}			}			adr++;		}	}	return(flag);}/*** *	durch eine List-Struktur durchhangeln und die Suchfunktion aufrufen ***/short		GetNextList(REG ListH *l,char *cond,...){REG ListH	n;char		s[512];REG char	*sp = &s[0];char		c;REG short	i;va_list		arg;REG short	flag;	va_start(arg,cond);	while(c = *cond++) {		if (c == '%') {			i = va_arg(arg,short);			if ((i<0)||(i>99)) {	// Typ außerhalb vom Bereich?				DebugStr("\pIQFileTyp bei SearchList");				return;			}			*sp++ = (i / 10) + '0';	// Typ als ASCII übertragen			*sp++ = (i % 10) + '0';		} else			*sp++ = c;	}	*sp = 0;	va_end(arg);	while(*l) {		n = (**l)->next;			// schonmal die Handle auf den nächsten Eintrag holen		flag = CheckListEntry(*l,s);// Suchfunktion ausführen		if (flag) break;			// Fehler beim Suchen bzw. Eintrag gefunden		*l = n;						// zum Folgedatensatz	}	return(flag);					// nix mehr gefunden}/*** *	durch eine List-Struktur durchhangeln und die Suchfunktion aufrufen ***/void		SearchList(REG ListH l,char *cond,...){REG ListH	n;char		s[1024];REG char	*sp = &s[0];char		c;REG short	i;va_list		arg;	va_start(arg,cond);	while(c = *cond++) {		if (c == '%') {			i = va_arg(arg,short);			if ((i<0)||(i>99)) {	// Typ außerhalb vom Bereich?				DebugStr("\pIQFileTyp bei SearchList");				return;			}			*sp++ = (i / 10) + '0';	// Typ als ASCII übertragen			*sp++ = (i % 10) + '0';		} else			*sp++ = c;	}	*sp = 0;	va_end(arg);	while(l) {		n = (*l)->next;				// schonmal die Handle auf den nächsten Eintrag holen		CheckListEntry(l,s);		// Suchfunktion ausführen		l = n;						// zum Folgedatensatz	}}/*** *	durch eine List-Struktur durchhangeln und die Suchfunktion aufrufen ***/void		SearchOList(OrganizerH o,IQFileType index,char *cond,...){REG ListH	l,n;char		s[1024];REG char	*sp = &s[0];char		c;REG short	i;va_list		arg;	va_start(arg,cond);	while(c = *cond++) {		if (c == '%') {			i = va_arg(arg,short);			if ((i<0)||(i>99)) {	// Typ außerhalb vom Bereich?				DebugStr("\pIQFileTyp bei SearchOList");				return;			}			*sp++ = (i / 10) + '0';	// Typ als ASCII übertragen			*sp++ = (i % 10) + '0';		} else			*sp++ = c;	}	*sp = 0;	va_end(arg);	l = GetListH(o,index);			// eine Liste aus der OrganizerStruktur durchsuchen	while(l) {		n = (*l)->next;				// schonmal die Handle auf den nächsten Eintrag holen		if ((*l)->type == index)			CheckListEntry(l,s);	// Suchfunktion ausführen		l = n;						// zum Folgedatensatz	}}/*** *	Entry an eine ListHandle anhängen ***/void		AppendToListH(REG ListH entry,REG ListH *list){REG ListH		h;	(*entry)->next = 0L;			// Verkettung löschen	(*entry)->prev = 0L;	if (*list) {		h = *list;					// Ptr auf den ersten Eintrag		while((*h)->next)			h = (*h)->next;		(*entry)->prev = h;		(*h)->next = entry;	} else {		*list = entry;				// erster Eintrag in der Liste	}}/*** *	Eintrag an eine Liste anhängen ***/void		AppendToList(REG OrganizerH o,IQFileType index,REG ListH entry){UCHAR			hstate;REG ListH		*list;	FixListEntry(entry);			// Länge vom Eintrag fixieren	hstate = HGetState((Handle)o);	HLock((Handle)o);	list = GetListHA(o,index);		// Ptr auf die ListH!	AppendToListH(entry,list);	HSetState((Handle)o,hstate);}/*** *	Eintrag in eine Liste einsortieren ***/short	CompareListStr(ListH entry,ListH h);short	CompareListStr(ListH entry,ListH h){short	len1 = Strlen((*entry)->d);short	len2 = Strlen((*h)->d);char	*s;	// CRs am Stringende nicht mit in den Vergleich einbeziehen	while((*((*entry)->d + len1 - 1) == '\r')&&(len1>0)) len1--;	while((*((*h)->d + len2 - 1) == '\r')&&(len2>0)) len2--;	return(IUMagString((*entry)->d,(*h)->d,len1,len2));}short	CompareListEntry(REG ListH entry,ListH h,IQFileType typ,short (*lproc)(ListH,ListH)){REG ListP	p1 = *entry;REG ListP	p2 = *h;	switch(typ) {	case SCHEDULE:			if (p1->t.schedule.year != p2->t.schedule.year)				return((p1->t.schedule.year < p2->t.schedule.year)?-1:1);			if (p1->t.schedule.month != p2->t.schedule.month)				return((p1->t.schedule.month < p2->t.schedule.month)?-1:1);			if (p1->t.schedule.day != p2->t.schedule.day)				return((p1->t.schedule.day < p2->t.schedule.day)?-1:1);			if (p1->t.schedule.shour != p2->t.schedule.shour)				return((p1->t.schedule.shour < p2->t.schedule.shour)?-1:1);			if (p1->t.schedule.sminute != p2->t.schedule.sminute)				return((p1->t.schedule.sminute < p2->t.schedule.sminute)?-1:1);			break;	case ANN1:			if (p1->t.ann1.month != p2->t.ann1.month)				return((p1->t.ann1.month < p2->t.ann1.month)?-1:1);			if (p1->t.ann1.date != p2->t.ann1.date)				return((p1->t.ann1.date < p2->t.ann1.date)?-1:1);			break;	case ANN2:			if (p1->t.ann2.month != p2->t.ann2.month)				return((p1->t.ann2.month < p2->t.ann2.month)?-1:1);			if (p1->t.ann2.week != p2->t.ann2.week)				return((p1->t.ann2.week < p2->t.ann2.week)?-1:1);			if (p1->t.ann2.day != p2->t.ann2.day)				return((p1->t.ann2.day < p2->t.ann2.day)?-1:1);			break;	case PERIOD:			if (p1->t.psched.syear != p2->t.psched.syear)				return((p1->t.psched.syear < p2->t.psched.syear)?-1:1);			if (p1->t.psched.smonth != p2->t.psched.smonth)				return((p1->t.psched.smonth < p2->t.psched.smonth)?-1:1);			if (p1->t.psched.sday != p2->t.psched.sday)				return((p1->t.psched.sday < p2->t.psched.sday)?-1:1);			break;	case DALARM:			if (p1->t.dalarm.hour != p2->t.dalarm.hour)				return((p1->t.dalarm.hour < p2->t.dalarm.hour)?-1:1);			if (p1->t.dalarm.minute != p2->t.dalarm.minute)				return((p1->t.dalarm.minute < p2->t.dalarm.minute)?-1:1);			break;	case TODO:	case DOLIST:			if (p1->t.todo.year != p2->t.todo.year)				return((p1->t.todo.year < p2->t.todo.year)?-1:1);			if (p1->t.todo.month != p2->t.todo.month)				return((p1->t.todo.month < p2->t.todo.month)?-1:1);			if (p1->t.todo.day != p2->t.todo.day)				return((p1->t.todo.day < p2->t.todo.day)?-1:1);			if (p1->t.todo.prio != p2->t.todo.prio)				return((p1->t.todo.prio < p2->t.todo.prio)?-1:1);			break;	case EXPENSE:			if (p1->t.expense.year != p2->t.expense.year)				return((p1->t.expense.year < p2->t.expense.year)?-1:1);			if (p1->t.expense.month != p2->t.expense.month)				return((p1->t.expense.month < p2->t.expense.month)?-1:1);			if (p1->t.expense.day != p2->t.expense.day)				return((p1->t.expense.day < p2->t.expense.day)?-1:1);			break;	}	return((*lproc)(entry,h));}/*** *	Eintrag in eine Listhandle einsortieren ***/void		SortToListH(IQFileType index,REG ListH entry,REG ListH *list){REG ListH		h,hv;	(*entry)->next = 0L;			// Verkettung löschen	(*entry)->prev = 0L;	HLock((Handle)entry);	if (*list) {		h = *list;					// Ptr auf den ersten Eintrag		while(h) {			HLock((Handle)h);			if (CompareListEntry(entry,h,index,CompareListStr)<0) {				HUnlock((Handle)h);				(*entry)->next = h;	// Nachfolger setzen				hv = (*h)->prev;	// alte Vorgänger holen				(*entry)->prev = hv;// Vorgänger setzen				(*h)->prev = entry;	// als neuen Vorgänger eintragen				if (hv) {			// gab es vorher einen Vorgänger?					(*hv)->next = entry;// dann dort als Nachfolger eintragen				} else {					*list = entry;		// sonst in die Basishandle eintragen				}				break;			}			HUnlock((Handle)h);			hv = h;					// alten Vorgänger merken			h = (*h)->next;		}		if (!h) {					// vorzeitiges Ende erreicht?			(*entry)->prev = hv;	// dann einfach anhängen			(*hv)->next = entry;		}	} else {		*list = entry;				// erster Eintrag in der Liste	}	HUnlock((Handle)entry);}/*** *	Datensatz in einen Filetype einsortieren ***/void		SortToList(REG OrganizerH o,IQFileType index,REG ListH entry){REG ListH		h,hv;UCHAR			hstate;REG ListH		*list;	FixListEntry(entry);			// Länge vom Eintrag fixieren	hstate = HGetState((Handle)o);	HLock((Handle)o);	list = GetListHA(o,index);		// Ptr auf die ListH!	SortToListH(index,entry,list);	// in die ListHandle einsortieren	HSetState((Handle)o,hstate);}/*** *	Abfragecondition aus dem Popup-Menü ermitteln ***/VOID		GetPopupCond(short item,STR s){Str255		s2;	GetIndString(s2,strPopFunc,item);	// String zum Popup-Menü holen	if (s2[0]) {						// String vorhanden?		PtoCstr(s2);		strcat(s,"a(");					// “AND (Condition)”		strcat(s,(STR)s2);		strcat(s,")");	}}/*** *	Eintrag aus einer Listenstruktur entfernen ***/void		RemoveFromList(REG ListH *toplist,REG ListH entry){REG ListH	p = (*entry)->prev;		// Vorgänger vom freizugebenden ElementREG ListH	n = (*entry)->next;		// Nachfolger vom freizugebenden Element	if (p == nil) {			// kein weiterer Vorgänger?		*toplist = n;			// dann liegt der Folgeeintrag ganz vorne in der Liste		if (n)					// gibt es überhaupt noch ein Listenelement?			(*n)->prev = nil;	// Ja, dann muß dort aber der Vorgänger = 0 sein!	} else {		(*p)->next = n;			// neuer Nachfolger vom Vorgänger		if (n)					// gibt es überhaupt einen Nachfolger?			(*n)->prev = p;		// dann dort den Vorgänger setzen	}}/*** *	Eintrag aus einer Listenstruktur entfernen ***/void		DisposeFromList(ListH *toplist,ListH entry){	RemoveFromList(toplist,entry);	// dann das Element freigeben	DisposHandle((Handle)entry);			// aktuelle Handle freigeben	CheckOSError(MemError());		// es sollte NIE ein Fehler auftreten!}/*** *	Alle Objekte vom Typ “index” aus eine Listenkette löschen und freigeben *	Wenn der Typ < 0 ist, werden sämtliche Elemente aus der Listenkette gelöscht. ***/void		DisposeIndexList(REG ListH *l,REG IQFileType index){REG ListH		la = *l;	while (la) {		if (((*la)->type == index)||(index < 0)) {	// passenden Typ gefunden?			DisposeFromList(l,la);		// dann das Element freigeben			la = *l;					// und wieder von vorne suchen		} else {			la = (*la)->next;			// einfach nur zum Folgeelement		}	}}/*** *	eine Listenkette aus der Organizer-Struktur verwerfen und austragen ***/void		SharpIndexClr(REG OrganizerH o,IQFileType index){UCHAR		hstate;	hstate = HGetState((Handle)o);	HLock((Handle)o);					// wegen: GetListHA(…) !!!	DisposeIndexList(GetListHA(o,index),index);	HSetState((Handle)o,hstate);}/*** *	Organizer-Struktur verwerfen (jedoch NICHT die Struktur an sich) ***/void		SharpClrAll(REG OrganizerH o){short		i;	if (!GetHandleSize((Handle)o)) return;	// Struktur ist noch gar nicht da!	DisposHandle((Handle)(*o)->dir);		// Directory freigeben	(*o)->dir = nil;				// und entfernen	CheckOSError(MemError());	for(i=1;i<MaxIQFileType;i++)	// alle anderen Listen		SharpIndexClr(o,i);}/*** *	aktuelle Organizer-Struktur ermitteln ***/OrganizerH	GetOrgH(REG DocHandle d){AktDocH		a;	if (!d) return(nil);			// kein Dokument vorhanden	a = (AktDocStruct**)(*d)->data;	// Handle auf AktDocStruct	return((OrganizerH)a);			// die Organizer-Struktur MUß GANZ am Anfang der Struktur stehen}/*** *	ListHandle zu einem Organizer-Typ ermitteln ***/ListH	GetListH(REG OrganizerH o,IQFileType index){REG UCHAR	hstate;REG ListH	l;REG ListH*	h;	if (!o) return(0L);				// kein Organizer angegeben	hstate = HGetState((Handle)o);	HLock((Handle)o);						// Organizer-Handle locken	h = GetListHA(o,index);	if (!h)							// ungültige Adresse?		l = 0L;						// dann Null zurückgeben	else		l = *h;	HSetState((Handle)o,hstate);			// Lock-Status zurücksetzen	return(l);}/*** *	Ptr auf eine ListHandle zu einem Organizer-Typ ermitteln ***/ListH	*GetListHA(REG OrganizerH o,IQFileType index){	switch(index) {	case SCHEDULE:	return(&(*o)->schedule);	case ANN1:		return(&(*o)->ann1);	case ANN2:		return(&(*o)->ann2);	case PERIOD:	return(&(*o)->period);	case DALARM:	return(&(*o)->dalarm);	case TEL1DATA:	case TEL2DATA:	case TEL3DATA:	return(&(*o)->teldata);	case TEL1FILE:	case TEL2FILE:	case TEL3FILE:	return(&(*o)->telfile);	case TEL1FREE:	case TEL2FREE:	case TEL3FREE:	return(&(*o)->telfree);	case MEMO:		return(&(*o)->memo);	case OUTLINE:	return(&(*o)->outline);	case BUSINESS:	return(&(*o)->business);	case BUSFREE:	return(&(*o)->busfree);	case USERDIC:	return(&(*o)->userdic);	case DOLIST:	return(&(*o)->dolist);	case EXPENSE:	return(&(*o)->expense);	case TIME:		return(&(*o)->time);	case TODO:		return(&(*o)->todo);	case USERFILE1:	case USERFILE2:	case USERFILE3:	return(&(*o)->userfiles);	case USER1FREE:	case USER2FREE:	case USER3FREE:	return(&(*o)->userfree);	}	OwnBeep(shit);	DebugStr("\pillegal IQFileType");}/*** *	Eine Liste sortieren ***/VOID		SortList(REG OrganizerH o,REG IQFileType index){UCHAR		hstate;REG ListH	l,ln;ListH		ls = nil;	// Liste per Default leerListH		*la;	hstate = HGetState((Handle)o);	HLock((Handle)o);						// wegen: GetListHA(…) !!!	l = GetListH(o,index);	while (l) {		ln = (*l)->next;			// einfach nur zum Folgeelement		if (index == MEMO)			AppendToListH(l,&ls);		else			SortToListH(index,l,&ls);		l = ln;	}	la = GetListHA(o,index);	if (la) *la = ls;				// Liste einsetzen	HSetState((Handle)o,hstate);}