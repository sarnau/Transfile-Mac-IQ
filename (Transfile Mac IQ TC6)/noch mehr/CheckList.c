/*** *	Dieser Source ermöglicht das Testen und Anspassen von defekten (z.B. überlangen) *	Datensätzen. ***/#include "CheckList.h"#include "List.h"#include "IQComm.h"#include "MySound.h"#include "Memo.h"#include "Float.h"/*** *	Diese Routine fixiert die Länge einer ListH auf die RICHTIGE Größe. D.h. die ListH *	wird auf die Größe der Struktur zzgl. der Stringlänge gekürzt. *	Returns am Stringende werden automatisch entfernt ***/VOID			FixListEntry(REG ListH l){REG STR		sp = (STR)&(*l)->d;REG WORD	len = Strlen(sp);	switch((*l)->type) {	case SCHEDULE:	case ANN1:	case ANN2:	case PERIOD:	case TEL1DATA:	case TEL2DATA:	case TEL3DATA:	case MEMO:	case BUSINESS:	case DOLIST:	case TODO:	case EXPENSE:				while((len > 0)&&(sp[len-1] == '\r')) len--;	// überflüssige Returns abschneiden				sp[len] = 0;				break;	case DALARM:sp[0] = 0;	// kein Text beim täglichen Alarm				len = 0;				break;	}	SetHandleSize((Handle)l,sizeof(List)+len);}/*** *	sorgt dafür, daß ein Feld eine best. Länge nicht überschreitet ***/VOID		ShortEntry(REG WORD count,REG USTR s,REG WORD size);VOID		ShortEntry(REG WORD count,REG USTR s,REG WORD size){REG UCHAR	c;REG USTR	sp;	for(;count>0;count--)		while(*s++ != '\r');			// Strings überspringen	sp = s;	while(c = *s++) {					// bis zum Stringende		if (c == '\r') break;			// ein Return?		if (size > 0) {					// paßt das Zeichen sonst noch?			*sp++ = c;					// Ja: Übernehmen			size--;		}	}	*sp++ = c;							// CR oder Nullbyte übertragen	if (c) {							// ein CR?		while(*sp++ = *s++);			// dann den Rest auch kopieren	}}/*** *	Diese Routine verändert einen Datensatz so, daß er gültig wird… ***/CheckErrorCode	CorrectEntry(REG ListH l,REG WORD org,REG CheckErrorCode code){REG WORD			maxsize;REG ULONG			len,size;REG CheckErrorCode	ret = CHKNoErr;REG USTR			s;REG USTR			sp;REG UWORD			typ;REG ListP			lp;UCHAR				state;UWORD				temp;	if (code == CHKNil) return(CHKNil);			// Handle war NIL!	if (code == CHKNoErr) return(CHKNoErr);		// ListH war OK…	if (!l) {									// keine Listhandle angegeben?		OwnBeep(shit);		return(CHKNil);							// großes Problem!	}	state = HGetState((Handle)l);	HLock((Handle)l);	lp		= *l;	s		= (USTR)&lp->d;						// Ptr auf den Text	org	   &= ~RAMCARD;							// Ramkarten-Bit ausblenden	maxsize = (NewLinkFormat(gDoc))?2048:512;	// übliche Satzgröße	size	= StrCrLen(s,99);					// Länge vom Textfeld (ohne CRs!)	if (size > maxsize) size = maxsize;			// Anzahl der zu übertragenden Zeichen	len		= Strlen((STR)s);					// Länge vom Datenfeld (mit CRs!)	typ		= lp->type;							// Typ der Listenhandle	switch(code) {	case CHKDataLen:	// Datenfeld zu lang					switch(typ) {					case USERDIC:	ShortEntry(0,s,40);		// Feld ist maximal 40 Bytes lang									break;					case TEL1FILE:					case TEL2FILE:					case TEL3FILE:	ShortEntry(0,s,10);		// Feld ist maximal 10 Bytes lang									break;					case BUSFREE:					case TEL1FREE:					case TEL2FREE:					case TEL3FREE:	for(temp=0;temp<5;temp++)										ShortEntry(temp,s,12);	// Felder maximal 12 Bytes lang									break;					case USER1FREE:					case USER2FREE:					case USER3FREE:	ShortEntry(0,s,10);			// Feld ist maximal 10 Bytes lang									for(temp=1;temp<17;temp++)										ShortEntry(temp,s,12);	// Felder maximal 12 Bytes lang									break;					case BUSINESS:									temp = StrCrLen(s,1);	// Länge des Firmennamens									if (temp > 40)			// Feldname wirklich zu lang?										BlockMove(s+temp,s+40,len-40);									break;					default: {						REG UCHAR	c;						sp = s;						while(c = *s++) {		// bis zum Stringende							if (c == '\r') {	// ein Return?								*sp++ = c;		// wird stets übernommen							} else if (size > 0) { // paßt das Zeichen sonst noch?								*sp++ = c;		// Ja: Übernehmen								size--;							}						}						*sp = 0;						if ((typ >= TEL1DATA)&&		// Telefondaten							(typ <= TEL3DATA)) {							if (org & ~IQ8x00) {	// kein 8000er								REG WORD	i;								REG UCHAR	c;								s = (USTR)&lp->d;								for(i=0;i<3;i++) {	// auf maximal 3 Felder kürzen									while(c = *s++) {										if (c == '\r') break;									}									if (!c) break;								}								*(s-1) = 0;			// Datensatz kürzen							}						}						}					}					break;	case CHKBDataLen1:	// Firmenanschrift bei Visitenkarten zu lang					if (typ == BUSINESS) {		// erstes Feld der Businesscard					REG UCHAR	c; REG WORD count = 4;						size = 512;				// diese Felder dürfen nur 512 Bytes lang sein						sp = s;						while((*sp++ = *s++) != '\r');	// Firmennamen überspringen						while(c = *s++) {		// bis zum Stringende							if (c == '\r') {	// ein Return?								*sp++ = c;		// wird stets übernommen								count--;							} else if ((size > 0)||(count<=0)) { // paßt das Zeichen sonst noch?								*sp++ = c;		// Ja: Übernehmen								size--;							}						}						*sp = 0;					}					break;	case CHKBDataLen2:	// Namen bei Visitenkarten zu lang					if (typ == BUSINESS) {					REG UCHAR	c; REG WORD count;						size = 1536;			// die Felder dürfen nur 1.5KB lang sein						sp = s;						for(count=0;count<5;count++)							while((*sp++ = *s++) != '\r');	// Firmennamen überspringen						while(c = *s++) {		// bis zum Stringende							if (c == '\r') {	// ein Return?								*sp++ = c;		// wird stets übernommen							} else if (size > 0) { // paßt das Zeichen sonst noch?								*sp++ = c;		// Ja: Übernehmen								size--;							}						}						*sp = 0;					}					break;	case CHKEmptyData:	// Datenfeld ist leer (nur bei “Daily Alarm” erlaubt)					ret = CHKKill;					break;	case CHKNoDate:		// es wurde kein Datum angegeben					{DateTimeRec t;					GetTime(&t);					switch(typ) {					case SCHEDULE:						lp->t.schedule.year = t.year;						lp->t.schedule.month = t.month;						lp->t.schedule.day = t.day;						lp->t.schedule.shour = -1;						lp->t.schedule.sminute = -1;						lp->t.schedule.ehour = -1;						lp->t.schedule.eminute = -1;						lp->t.schedule.ahour = -1;						lp->t.schedule.aminute = -1;						break;					case ANN1:						lp->t.ann1.month = t.month;						lp->t.ann1.date = t.day;						break;					case ANN2:						lp->t.ann2.month = t.month;						lp->t.ann2.week = 1;						lp->t.ann2.day = 0;						break;					case PERIOD:						lp->t.psched.syear = t.year;						lp->t.psched.smonth = t.month;						lp->t.psched.sday = t.day;						lp->t.psched.eyear = t.year;						lp->t.psched.emonth = t.month;						lp->t.psched.eday = t.day;						break;					case DALARM:						lp->t.dalarm.hour = t.hour;						lp->t.dalarm.minute = t.minute;						break;					}					ret = CHKDateCorr;					}					break;	case CHKStartYear:	// Startjahr > Endjahr (bei Periodic)					if(lp->t.psched.syear > lp->t.psched.eyear)	{ // Startjahr größer Endjahr?						ret = CHKDeltaCorr;						lp->t.psched.eyear = lp->t.psched.syear;					} else						break;	case CHKStartMonth:	// Startmonat > Endmonat (bei Periodic)					if(lp->t.psched.smonth > lp->t.psched.emonth) {						ret = CHKDeltaCorr;						lp->t.psched.emonth = lp->t.psched.smonth;					} else						break;	case CHKStartDay:	// Starttag > Endtag (bei Periodic)					if(lp->t.psched.sday > lp->t.psched.eday) {						ret = CHKDeltaCorr;						lp->t.psched.eday = lp->t.psched.sday;					}					break;	case CHKAlarmtime:	// Alarm aktiviert, aber die Zeit fehlt (Scheduler)					(*l)->b.alarm = false;			// Alarm einfach ausschalten					ret = CHKAlarmOff;					break;	case CHKAlStartTime:	// Alarm aktiviert, aber Terminzeit fehlt (Scheduler)					(*l)->t.schedule.shour = (*l)->t.schedule.ahour;	// Startzeit = Alarmzeit					(*l)->t.schedule.sminute = (*l)->t.schedule.aminute;					ret = CHKDateCorr;					break;	default:					ret=CHKKill;		// Wenn nicht sinnvoll änderbar, dann muß der					break;				// Datensatz verworfen werden.	}	HSetState((Handle)l,state);	FixListEntry(l);		// Größe des Eintrags anpassen	return(ret);}/*** *	Stringlänge bis zum n-ten CR bzw. abschließenden Nullbyte ermitteln. * *	Die CRs zählen NICHT mit! ***/WORD		StrCrLen(USTR s,WORD cranz){REG WORD	count = 0;	// StringlängeREG WORD	cr = 0;		// Anzahl der bis jetzt gefundenen CRs	while(*s != 0) {				// bis zum Nullbyte		if (*s == '\r') {			cr++;					// CRs zählen		} else {			count++;				// restliche Zeichen zählen		}		if (cr == cranz) break;		// Abbrechen, wenn die entsprechenden Anzahl CRs erreicht ist.		s++;	}	return(count);}/*** *	Stringlänge eines Eintrags in einem Datensatzs bis zum CR bzw. abschließenden Nullbyte ermitteln. * *	Die CRs zählen NICHT mit! ***/WORD		StrCrFLen(USTR s,WORD count);WORD		StrCrFLen(USTR s,WORD count){REG WORD	cnt = 0;	// StringlängeREG UCHAR	c;	for(;count>0;count--)		while(*s++ != '\r');			// Strings überspringen	while(c = *s++) {					// bis zum Stringende		if (c == '\r') break;			// ein Return?		cnt++;	}	return(cnt);}/*** *	einen Eintrag abtesten ***/CheckErrorCode	CheckData(REG ListH l,REG WORD org){REG WORD			maxsize;REG ULONG			len;REG CheckErrorCode	ret = CHKNoErr;REG USTR			s;REG UWORD			temp;REG UWORD			typ;REG ListP			lp;UCHAR				state;UWORD				temp2;	if (!l) {									// keine Listhandle angegeben?		OwnBeep(shit);		return(CHKNil);							// großes Problem!	}	state = HGetState((Handle)l);	HLock((Handle)l);	lp		= *l;	s		= (USTR)&lp->d;						// Ptr auf den Text	typ		= lp->type;							// Typ der Listenhandle	org	   &= ~RAMCARD;							// Ramkarten-Bit ausblenden	maxsize = (NewLinkFormat(gDoc))?2048:512;	// übliche Satzgröße	len		= StrCrLen(s,99);					// Länge vom Textfeld	switch(typ) {	case TEL1DATA:	case TEL2DATA:	case TEL3DATA:	if (maxsize < len) ret = CHKDataLen;// Satz zu lang?					{ REG WORD	i = 0; REG UCHAR	c;						REG USTR	sp = s;						while(c = *sp++) {							if (c == '\r') i++;						}						if (org & ~IQ8x00)				// kein 8000er							if (i > 2) ret = CHKDataLen;// zu viele Felder!					}					break;	case MEMO:	case SCHEDULE:	case ANN1:	case ANN2:	case PERIOD:	if (maxsize < len) ret = CHKDataLen;// Satz zu lang?					break;	case DALARM:	break;								// Daily Alarm ist stets i.O.	case TEL1FILE:	case TEL2FILE:	case TEL3FILE:	if (10 != len) ret = CHKDataLen;	// Satzlänge fix = 10 Bytes					break;	case TEL1FREE:	case TEL2FREE:	case TEL3FREE:	if (60 != len) ret = CHKDataLen;	// 5 Freifelder a 12 Bytes					break;	case BUSINESS:	// Firmenname zu lang?					if ((temp = StrCrLen(s,1)) > 40) ret = CHKDataLen;					// Firmenanschrift zu lang?					if ((StrCrLen(s,5) - temp) > 512) ret = CHKBDataLen1;					// Name, etc. zu lang?					if ((StrCrLen(s,99) - StrCrLen(s,5)) > 1536) ret = CHKBDataLen2;					break;	case BUSFREE:	if (60 != len) ret = CHKDataLen;	// 5 Freifelder a 12 Bytes					break;	case USERDIC:	if (40 < len) ret = CHKDataLen;		// Satz zu lang?					break;	case USERFILE1:	case USERFILE2:	case USERFILE3:	if ((maxsize + 16) < len) ret = CHKDataLen; // Satz zu lang?					break;	case USER1FREE:	case USER2FREE:	case USER3FREE:	if(StrCrFLen(s,0) > 10) ret = CHKDataLen;	// Satz zu lang!					for(temp=1;temp<17;temp++)						if(StrCrFLen(s,temp) > 12) ret = CHKDataLen;	// Satz zu lang!					break;	case DOLIST:	if ((temp = StrCrLen(s,1)) > 512) ret = CHKDataLen;	// Description zu lang?					temp2 = StrCrLen(s,2) - temp; temp += temp2;					if (temp2 > 30) ret = CHKBDataLen1;	// Manager-Name zu lange					temp2 = StrCrLen(s,3) - temp;					if (temp2 > 30) ret = CHKBDataLen2;	// Projekt-Name zu lange					break;	case EXPENSE:	if ((temp = StrCrLen(s,1)) > 30) ret = CHKDataLen;	// Expense type zu lang?					temp2 = StrCrLen(s,2) - temp; temp += temp2;					if (temp2 > 8) ret = CHKBDataLen1;	// Amount zu lang					temp2 = StrCrLen(s,3) - temp; temp += temp2;					if (temp2 > 30) ret = CHKBDataLen2;	// Payment type zu lang					temp2 = StrCrLen(s,4) - temp;					if (temp2 > 512) ret = CHKBDataLen3;// Description type zu lang					if (ret) break;					{ REG USTR	sp = s; REG LONG num = 0;						while((*sp) && (*sp++ != '\r'));// erstes Feld überspringen						while(*sp == ' ') sp++;			// Leerzeichen am Anfang überspringen						if(!*sp) break;					// Schon Datensatzende						while((*sp)&&(*sp != '\r')&&(*sp != '.')) {							if ((*sp < '0')||(*sp > '9')) {								ret = CHKExpIllChar;	// illegales Zeichen								break;							}							num *= 10; num += *sp - '0';// Ziffer einfügen							sp++;						}						num *= 100;						// Vorkommastellen						if (*sp == '.') {				// Nachkommastellen?							REG WORD num2 = 0;							sp++;							while((*sp)&&(*sp != '\r')) {								if ((*sp < '0')||(*sp > '9')) {									ret = CHKExpIllChar;// illegales Zeichen									break;								}								num2 *= 10; num2 += *sp - '0';// Ziffer einfügen								sp++;							}							num += num2;				// Nachkommastellen dazu						}						if (num > 9999999) ret = CHKExpValue;					}					break;	case OUTLINE:		case TIME:			case TODO:		break;	}	if (ret) {		HSetState((Handle)l,state);		return(ret);								// Feldlänge ist bereits falsch!	}	// alle Felder (bis auf “Daily Alarm” und "Expense") müssen irgendwas beinhalten	if ((typ != EXPENSE)&&(typ != DALARM)&&(!*s || (*s == '\r'))) {		HSetState((Handle)l,state);		return(CHKEmptyData);					// Feld ist leer!	}	// nun testen wir den Inhalt ab:	switch(typ) {	case SCHEDULE:		if( (lp->t.schedule.year < 0) ||		// Kein Datum?			(lp->t.schedule.month < 0) ||			(lp->t.schedule.day < 0))				ret = CHKNoDate;				// Nix gut			else				if(lp->b.alarm)					// Alarm ein				{					if(lp->t.schedule.shour<0)	// …aber keine Terminzeit?						ret = CHKAlStartTime;					if(lp->t.schedule.ahour<0)	// …aber keine Alarmzeit?						ret = CHKAlarmtime;				}		break;	case ANN1:		if( (lp->t.ann1.month < 0) ||			// Kein Datum?			(lp->t.ann1.date < 0))				ret = CHKNoDate;				// Nix gut		break;	case ANN2:		if( (lp->t.ann2.month < 0) ||			// Kein Datum?			(lp->t.ann2.week < 0) ||			(lp->t.ann2.day < 0))				ret = CHKNoDate;				// Nix gut		break;	case PERIOD:		if( (lp->t.psched.syear < 0) ||			// Kein Datum?			(lp->t.psched.smonth < 0) ||			(lp->t.psched.sday < 0) ||			(lp->t.psched.eyear < 0) ||			(lp->t.psched.emonth < 0) ||			(lp->t.psched.eday < 0))				ret = CHKNoDate;				// Nix gut		if(lp->t.psched.syear > lp->t.psched.eyear)	// Startjahr größer Endjahr?				ret = CHKStartYear;		if(lp->t.psched.syear < lp->t.psched.eyear) break;		if(lp->t.psched.smonth > lp->t.psched.emonth)				ret = CHKStartMonth;		if(lp->t.psched.smonth < lp->t.psched.emonth) break;		if(lp->t.psched.sday > lp->t.psched.eday)				ret = CHKStartDay;					break;	case DALARM:		if( (lp->t.dalarm.hour < 0) ||			// Kein Datum?			(lp->t.dalarm.minute < 0))				ret = CHKNoDate;		break;	}	HSetState((Handle)l,state);	return(ret);}/*** *	eine Listenkette aus der Organizer-Struktur abtesten ***/VOID		CheckListData(REG ListH *la,WORD org){REG WORD	code;REG ListH	l,lnext,lprev=nil;	l = *la;	while (l) {		lnext = (*l)->next;				// Folgeelement merken		if(lprev!=(*l)->prev)	{			OwnBeep(shit);			(*l)->prev=lprev;		}		lprev=l;		FixListEntry(l);		if (code = CheckData(l,org)) {	// Fehler?			code = CorrectEntry(l,org,code);			if (code == CHKKill) {		// Datensatz löschen?				DisposeFromList(la,l);	// Datensatz wegwerfen			}		}		l = lnext;							// zum Folgeelement	}}/*** *	Alle Strukturen des übergebenen Dokumentes testen ***/VOID	CheckDoc(DocHandle d){REG WORD		i;REG OrganizerH	o = GetOrgH(d);REG WORD		typ = (*o)->type;REG Boolean		flag = false;ULONG			redrawTypeMask = 0;	for(i=1;i<MaxIQFileType;i++) {		// alle anderen Listen		if (!IQIsAvailable(o,i)) {			SharpIndexClr(o,i);			// Liste komplett verwerfen!			redrawTypeMask |= 1L<<(i-1);			flag = true;		} else			CheckListData(GetListHA(o,i),typ);	}	DoBitFieldRedraw(redrawTypeMask);	if ((flag)&&(gTheFloatWind))		UpdateFloat(gTopWindow);		// Float neu zeichnen}