#include "MoreOptions.h"#include "xRsrcDefines.h"#include "GeosMore.h"#include "Document.h"#include "IQStruct.h"#include "IQComm.h"#include "List.h"#include "Geos.h"#include "DialogLib.h"#include "Memo.h"#include "Float.h"#include "GlobalLib.h"#include "CheckList.h"#include "AktDocStruct.h"#include <String.h>Boolean		DoClear(ListH *la,IQFileType typ);Boolean		DoCut(ListH *la,IQFileType typ);Boolean		DoCopy(ListH *la,IQFileType typ);Boolean		DoPaste(ListH *la,IQFileType typ);ListH		gClipboardList = nil;/*** *	Diese Funktion gibt  ***/IQFileType	GetWindowType(REG WindPtr w){REG Handle			xWindow;	if (!w) return(UNKNOWNFILE);	// Windowhandle = nil => raus	if (!(xWindow = w->MoreMem)) return(UNKNOWNFILE);	return(XWIN->windowType);}/*** *	Zeichen a im Datensatz durch Zeichen b ersetzen ***/VOID		ChangeChar(ListH l,UCHAR a,UCHAR b);VOID		ChangeChar(ListH l,UCHAR a,UCHAR b){REG USTR		s;REG UCHAR		c;	s = (USTR)&(*l)->d;	while(c = *s) {		if (c == a) *s = b;		s++;	}}/*** *	Ptr auf den n-ten String z.B. aus der Telefonliste holen *	Zu beachten ist, daß item = 0 für das erste Item steht! *	ggf. sollte die ListHandle gelockt sein. ***/STR			GetStringPtr(REG ListH l,REG WORD item,REG UCHAR trenner);STR			GetStringPtr(REG ListH l,REG WORD item,REG UCHAR trenner){REG STR		s = (STR)&(*l)->d;REG CHAR	c;	while((c = *s++)&&(item>0)) {		if (c == trenner) item--;	}	return(--s);}/*** *	String bis zum nächsten Trenner bzw. Nullbyte kopieren ***/STR			StrCat(REG STR s,REG STR d,REG UCHAR trenner);STR			StrCat(REG STR s,REG STR d,REG UCHAR trenner){REG UCHAR	c;	while(*d++); d--;		// Ptr auf das Stringende	while(c = *s++) {		if (c == trenner) break;		*d++ = c;	}	*d = '\0';				// String mit Nullbyte abschließen}/*** *	Diese Routine fügt ein Item in eine Liste ein. Dabei wird beachtet, ob einsortiert *	werden muß! Das Item wird VERÄNDERT! Man sollte UNBEDINGT mit einer Kopie arbeiten! ***/VOID		ItemToList(REG ListH *la,ListH l,IQFileType dindex);VOID		ItemToList(REG ListH *la,REG ListH l,IQFileType dindex){REG IQFileType	index = (*l)->type;		// Typ vom DatensatzREG Boolean		copyflag = false;		// Datensatz nicht zu kopierenCHAR			s[2500];				// Buffer für einen gewandelten DatensatzREG STR			sp;	switch(index) {	case SCHEDULE:						// ins gleiche Window?	case ANN1:	case ANN2:	case PERIOD:	case DALARM:				dindex = index;				break;	}	if (index != dindex) {				// Typ ungleich, muß gewandelt werden		s[0] = 0;						// Bufferstring löschen		(*l)->type = dindex;			// Datensatztyp auf den Typ vom Zielbereich setzen		switch(dindex) {		case MEMO:	switch (index) {					case TEL1DATA:					case TEL2DATA:					case TEL3DATA:					case BUSINESS:	ChangeChar(l,'\r','\t');	// CRs durch Tab ersetzen									break;					}					copyflag = true;	// Datensatz ist kopierbar					break;		case TEL1DATA:		case TEL2DATA:		case TEL3DATA:					switch(index) {					case BUSINESS:	sp = GetStringPtr(l,5,'\r');		// Name									if ((!*sp)||(*sp == '\r'))			// leer?										sp = GetStringPtr(l,0,'\r');	// Firma									StrCat(sp,s,'\r');					// Namesfeld									Strcat(s,"\r");									sp = GetStringPtr(l,7,'\r');		// Privatnummer									if ((!*sp)||(*sp == '\r'))			// leer?										sp = GetStringPtr(l,2,'\r');	// dann die Geschäftsnummer									StrCat(sp,s,'\r');					// Telefonnummernfeld									Strcat(s,"\r");									StrCat(GetStringPtr(l,4,'\r'),s,'\r');	// Firmenanschrift									BlockMove(s,&(*l)->d,Strlen(s)+1);	// Datensatz wird eh									// kürzer, Länge wird beim Aufräumen und Test gesetzt					case TEL1DATA:					case TEL2DATA:					case TEL3DATA:	copyflag = true;					// Datensatz ist kopierbar									break;					}					break;		case BUSINESS:					switch(index) {					case TEL1DATA:					case TEL2DATA:					case TEL3DATA:  StrCat(GetStringPtr(l,0,'\r'),s,'\r');	// Firma									Strcat(s,"\r\r");									StrCat(GetStringPtr(l,1,'\r'),s,'\r');	// Nummer									Strcat(s,"\r\r");									StrCat(GetStringPtr(l,2,'\r'),s,'\r');	// Anschrift									{ REG state = HGetState((Handle)l);									HUnlock((Handle)l);									SetHandleSize((Handle)l,sizeof(List)+Strlen(s));									HSetState((Handle)l,state);									}									BlockMove(s,&(*l)->d,Strlen(s)+1);					case BUSINESS:	copyflag = true;					// Datensatz ist kopierbar									break;					}					break;		}	} else {		copyflag = true;					// Type gleich => kein Problem	}	if (copyflag) {							// Datensatz übertragen?		if (dindex == MEMO)					// Memos werden angehängt			AppendToListH(l,GetListHA(GetOrgH(gDoc),(*l)->type));		else								// andere werden einsortiert			SortToListH(index,l,GetListHA(GetOrgH(gDoc),(*l)->type));	}}/*** *	ListH in den Scrap-Buffer übertragen ***/VOID		EntryToScrap(ListH l);VOID		EntryToScrap(ListH l){	ZeroScrap();						// Scrap löschen	if (!l) return;						// kein Eintrag?	if (HandToHand((Handle*)&l)) return;// Datensatz verdoppeln, da er verändert wird!	ChangeChar(l,'\t','\r');			// Tabs durch Return ersetzen	PutScrap(Strlen((STR)&(*l)->d),'TEXT',(Ptr)&(*l)->d); // Datensatz in den Scrap-Buffer	DisposHandle((Handle)l);			// Datensatz wieder verwerfen}/*** *	eine Listenkette aus der Organizer-Struktur verwerfen und austragen ***/Boolean		DoClear(REG ListH *la,IQFileType typ){REG ListH		l,ln;	ZeroScrap();						// Scrap löschen	l = *la;	while(l) {		ln = NextListH(l,getTheNextOne);// Folgeeintrag schonmal holen (weil evtl. gelöscht wird)		if (CheckListEntry(l,"Sav")) {	// Eintrag löschen?			RemoveFromList(GetListHA(GetOrgH(gDoc),(*l)->type),l);	// dann austragen			DisposHandle((Handle)l);			// und freigeben		}		l = ln;							// weiter beim Folgeeintrag	}	return(true);						// Redraw nötig}/*** *	eine Listenkette aus der Organizer-Struktur verwerfen und austragen ***/Boolean		DoCut(REG ListH *la,IQFileType typ){REG ListH		l,ln;REG ListH		first = nil;	l = *la;	DisposeIndexList(&gClipboardList,-1);	// Clipboard löschen	while(l) {		ln = NextListH(l,getTheNextOne);// Folgeeintrag schonmal holen (weil evtl. gelöscht wird)		if (CheckListEntry(l,"Sav")) {	// Eintrag löschen?			RemoveFromList(GetListHA(GetOrgH(gDoc),(*l)->type),l);	// dann austragen			if (!first) first = l;		// ersten Eintrag merken			AppendToListH(l,&gClipboardList);	// und ans Clipboard anhängen		}		l = ln;							// weiter beim Folgeeintrag	}	EntryToScrap(first);				// evtl. ersten Eintrag in den Scrap-Buffer	return(true);						// Redraw nötig}/*** *	eine Listenkette aus der Organizer-Struktur verwerfen und austragen ***/Boolean		DoCopy(REG ListH *la,IQFileType typ){REG ListH		l,ln;ListH			temp;REG OSErr		err = noErr;REG ListH		first = nil;	l = *la;	biene();	DisposeIndexList(&gClipboardList,-1);	// Clipboard löschen	while(l) {		ln = NextListH(l,getTheNextOne);// Folgeeintrag schonmal holen (weil evtl. gelöscht wird)		if (CheckListEntry(l,"Sav")) {	// Eintrag löschen?			temp = l;			if (!CheckMem(30000)) {		// min. 30k müssen frei bleiben				err = memFullErr;				break;					// kein Speicher mehr? => raus			}			err = HandToHand((Handle*)&temp);	// Datensatz kopieren			if (err) break;			l = temp;			if (!first) first = l;		// ersten Eintrag merken			AppendToListH(l,&gClipboardList);	// und ans Clipboard anhängen		}		l = ln;							// weiter beim Folgeeintrag	}	EntryToScrap(first);				// evtl. ersten Eintrag in den Scrap-Buffer	pfeil();	CheckOSError(err);	return(false);						// Redraw unnötig}/*** *	eine Listenkette aus der Organizer-Struktur verwerfen und austragen ***/Boolean		DoPaste(REG ListH *la,IQFileType typ){REG ListH		l,ln;ListH			temp;REG OSErr		err = noErr;	biene();	switch((**la)->type) {	case SCHEDULE:						// ins gleiche Window?	case ANN1:	case ANN2:	case PERIOD:	case DALARM:				SearchList(GetListH(GetOrgH(gDoc),SCHEDULE),"c04=0");	// alle Datensätze deselektieren				SearchList(GetListH(GetOrgH(gDoc),ANN1),"c04=0");				SearchList(GetListH(GetOrgH(gDoc),ANN2),"c04=0");				SearchList(GetListH(GetOrgH(gDoc),PERIOD),"c04=0");				SearchList(GetListH(GetOrgH(gDoc),DALARM),"c04=0");				break;	default:				SearchList(*la,"c04=0");// alle Datensätze deselektieren	}	l = gClipboardList;	while(l) {		ln = (*l)->next;				// Folgeeintrag schonmal holen (weil evtl. gelöscht wird)		if (!CheckMem(30000)) {			// min. 30k müssen frei bleiben			err = memFullErr;			break;						// kein Speicher mehr? => raus		}		temp = l;		err = HandToHand((Handle*)&temp);		// Datensatz kopieren		if (err) break;		ItemToList(la,temp,typ);		l = ln;							// weiter beim Folgeeintrag	}	pfeil();	CheckOSError(err);	return(true);						// Redraw nötig}/*** *	Cut/Copy/Paste angewählt ***/void		DoCutCopy(WORD entry){REG OrganizerH	o;REG IQFileType	typ;REG ListH		*la;REG Boolean		ret;	if (!gDoc) return;					// kein Dokument offen?	o = GetOrgH(gDoc);					// OrganizerHandle ermitteln	if (!o) return;						// nicht gefunden??? (sollte nie auftreten)	HLock((Handle)o);	typ = GetWindowType(gTopWindow);	// Windowtyp vom obersten Window ermitteln	if (typ == UNKNOWNFILE) return;		// Window nicht offen, unbekannter Typ…	la = GetListHA(o,typ);				// Adresse der Liste ermitteln	switch(entry) {	case mEditUndo:	DebugStr("\pNoch nicht implementiert");					break;	case mEditCut:	ret = DoCut(la,typ);					break;	case mEditCopy:	ret = DoCopy(la,typ);					break;	case mEditPaste:ret = DoPaste(la,typ);					if (ret) CheckListData(la,(*o)->type);					break;	case mEditClear:ret = DoClear(la,typ);					break;	}	HUnlock((Handle)o);	if (ret) {		DoMultiRedraw(typ,redrawAndRecalc,nil);		AppDocumentDirty(gDoc,true);	// Dokument ist dirty	}}/*** *	enablen/disablen einiger kleinerer Optionen aus diesem Source ***/void	DoMoreEnable(MenuHandle mh){REG WORD	i = 0;					// wenn kein Dokument offen	if (gDoc) {		REG OrganizerH	o = GetOrgH(gDoc);	// Handle auf den Organizer ermitteln		if (o)			i = (*o)->type;					// Typ vom aktuellen Dokument	}	DisableItem(mh,optUserDic);	if (i & IQGetOrgMask(USERDIC))		EnableItem(mh,optUserDic);	DisableItem(mh,optFreifeldNamen);//	if (i & (IQGetOrgMask(TEL1FREE)|IQGetOrgMask(BUSFREE)|IQGetOrgMask(USERFILE1))//		&& NewLinkFormat(gDoc))	if (((i & (IQGetOrgMask(TEL1FREE)|IQGetOrgMask(BUSFREE))) && NewLinkFormat(gDoc))		||(i & IQGetOrgMask(USERFILE1)))		EnableItem(mh,optFreifeldNamen);	DisableItem(mh,optBereichNamen);		// Dateinamen gefragt?	if (i & (IQGetOrgMask(TEL1FREE)|IQGetOrgMask(USERFILE1)))		EnableItem(mh,optBereichNamen);	// Bei Telefondaten und Andwenderdateien möglich	DisableItem(mh,optExpense);	if (i & IQGetOrgMask(EXPENSE))		EnableItem(mh,optExpense);}/*** *	weitere Optionen ***/void	DoMoreOptions(short entry){	switch(entry) {	case optUserDic:			DoUserDic();			break;	case optFreifeldNamen:			DoFreifeld();			break;	case optBereichNamen:			DoTelfname();			break;	}}/*** *	User-Dictionary verwalten ***/void	DoUserDic(void){DialogPtr	d;						// Ptr auf diverse Dialogeshort		button;					// Exit-ButtonListHandle	l;						// für die AuswahllistenListH		dList;short		item;					// selektiertes Item (> MaxItem, wenn nix selektiert)Cell		c;						// aktuell selektierte Zelleshort		type; Handle h; Rect r;	// Daten vom TextEdit-Feld (mit GetDItem ermittelt)Str255		s;	if (!gDoc) return;					// kein Dokument offen 	if (!NewLinkFormat(gDoc)) return;	// kein IQ-8000? => raus	dList = GetListH(GetOrgH(gDoc),USERDIC); 	d = GetCenteredDialog(dUserDic,nil);	if (!d) return;						// Dialog nicht zu öffnen	l=NewList(d,6,false,true,0);	if (dList) {		CLFList = l;		SearchList(dList,"c02=13");		// vorhandene Einträge in die Liste einsortieren		CLFList = nil;					// wieder sichern!	}	LDoDraw(true,l);	OutlineDialogItem(d,1);				// Default-Button zeichnen	gTEMaxLen = 32;						// maximale Länge für TextEdit	while (d) {		HiliteButton(d,5,(FindSelCell(l)<0)?kCntlInactive:kCntlActive);	// Löschen disablen		ModalDialog((ModalFilterProcPtr)OwnTELenFilter,&button);		if (button == 3) break;			// Abbruch		if (button == 4) break;			// Ok		item = FindSelCell(l);			// eine selektierte Zelle finden		c.h = 0; c.v = item;		GetDItem(d,7,&type,&h,&r);					// Parameter vom TextEdit-Feld holen		switch(button) {		case 1:	GetIText(h,s);						// Text der Eingabezeile holen				if(item >= 0)						// was selektiert?					LDelRow(1,c.v,l);				// Dann Zelle wegwerfen				if(s[0]) {							// Eingabestring auch vorhanden?					SortToListMgr(PtoCstr(s),l);	// und einsortieren					SelIText(d,7,0,32767);			// gesamten Text selektieren				}				break;		case 5:	if(item < 0) break; 				// nix selektiert				while((item = FindSelCell(l))>= 0)					LDelRow(1,item,l);				// alle sel. Zellen wegwerfen				break;		case 6:	if(item < 0) break; 				// nix selektiert				type = 255;							// maximal 255 Bytes holen				LGetCell(&s[1],&type,c,l);			// Text aus der Zelle holen				s[0] = type;						// echte Länge setzen				SetIText(h,s);						// in TextEdit-Feld eintragen				SelIText(d,7,0,32767);				// gesamten Text selektieren				break;		}	}	if (button == 0x04) {							// “Ok” angewählt		SharpIndexClr(GetOrgH(gDoc),USERDIC);		// Listenkette freigeben		for(item=0;item<(*l)->dataBounds.bottom;item++) {	// alle Zellen durchsuchen			c.h = 0; c.v = item;			type = 255;			LGetCell(s,&type,c,l);					// Text aus der Zelle holen			dList = (ListH)NewHandleClear(sizeof(List)+type);			if (!dList) {				CheckOSError(MemError());			// Fehler melden				break;								// und raus!			} else {				(*dList)->type = USERDIC;			// Typ: UserDic				BlockMove(s,(*dList)->d,type);		// String übertragen			}			AppendToList(GetOrgH(gDoc),USERDIC,dList); // an die Liste anhängen		}		AppDocumentDirty(gDoc,true);				// Document ist jetzt dirty		CheckDoc(gDoc);	}	DisposeObjects(d);	DisposDialog(d);}/*** *	Freifelder definieren ***/void	GetFFText(DialogPtr d,IQFileType index);void	GetFFText(DialogPtr d,IQFileType index){short	i,j,k;ListH	l;Str255	s;short	type; Handle h; Rect r;	// Daten vom TextEdit-Feld (mit GetDItem ermittelt)short	last=11;Str63	s2; 	l = GetListH(GetOrgH(gDoc),index);	// Handle der Liste ermitteln	while(l) {		if ((*l)->type == index) break;	// Liste nach der Gruppe durchsuchen		l = (*l)->next;	}	if (!l) {							// Liste nicht vorhanden?		s[0] = 0;		for(i=strFree1;i<=strFree5;i++) {	// Kann nicht bei Anwenderdateien auftreten			GetIndString(s2,strTelefon,i);			PtoCstr(s2);			strcat((STR)s,(STR)s2);			strcat((STR)s,(STR)"\r");		}	} else {		vStrcpy((char*)s,(*l)->d);	}		k = 0;	if((index>=USERFILE1) && (index<=USER3FREE)) { // Anwenderdateien haben noch ein Feld Dateinamen davor,		while(s[k++] != RETURN)			// und das wird überlesen		last=16+6;	}	for(i=6;i<last;i++) {				// 5 oder 16 Felder durchgehen		GetDItem(d,i,&type,&h,&r);		// Parameter vom TextEdit-Feld holen		j = 0; s2[j++] = 0;				// Stringlänge = 0		while(s[k++] != RETURN)			// Text bis zum CR übertragen			s2[j++] = s[k-1];		while(s2[j-1] == ' ')			// Leerzeichen am Ende entfernen			j--;		s2[0] = j-1;					// Stringlänge in den Pascal-String		SetIText(h,s2);					// und den Text setzen	}}void	SetFFText(DialogPtr d,IQFileType index);void	SetFFText(DialogPtr d,IQFileType index){short	i,k,len;Str255	s,sTemp;short	type; Handle h; Rect r;	// Daten vom TextEdit-Feld (mit GetDItem ermittelt)short	last=11;ListH	l;USTR	sp;	sp = &s[0];	if((index>=USERFILE1) && (index<=USER3FREE)) { // Anwenderdateien haben noch ein Feld Dateinamen davor,		l=GetListH(GetOrgH(gDoc),index);		while(l && (*l)->type!=index)		// also Anwenderfreifelder nach altem durchsuchen			l=(*l)->next;		if(l) {								// Muß eigentlich immer erfüllt sein!			HLock((Handle)l);				// und in den neuen rüberkopieren			BlockMove(&((*l)->d),sp,11);	// 10 Zeichen konst. Länge + Return als Endekennung			sp+=11;			HUnlock((Handle)l);		}		last=16+6;	}	SharpIndexClr(GetOrgH(gDoc),index);	// Listenkette freigeben	for(i=6;i<last;i++) {				// alle Felder durchgehen		GetDItem(d,i,&type,&h,&r);		// Parameter vom TextEdit-Feld holen		GetIText(h,sTemp);		k = sTemp[0];		BlockMove(&sTemp[1],sp,k);		// String umkopieren		sp += k;		while(k++<12)					// String wieder mit Leerzeichen auffüllen			*sp++ = ' ';		*sp++ = RETURN;					// Return anhängen		*sp = 0;	}	len = Strlen((char*)s);				// Länge vom Gesamteintrag	l = (ListH)NewHandleClear(sizeof(List)+len);	if (!l) {		CheckOSError(MemError());		// Fehler melden		return;							// und raus!	} else {		(*l)->type = index;				// Typ: UserDic		BlockMove(s,(*l)->d,len);		// String übertragen	}	AppendToList(GetOrgH(gDoc),index,l); // an die Liste anhängen}/*** *	Editor für Freifelder ***/void	DoFreifeld(void){DialogPtr			d;						// Ptr auf diverse Dialogeshort				button;					// Exit-Buttonstatic short		LastPopup = 1;			// letzter Wert vom Popup-Menüstatic IQFileType	convtab[2][5] =	{{ 0,TEL1FREE,TEL2FREE,TEL3FREE,BUSFREE },	// Für Neues Linkformat									{ 0,USER1FREE,USER2FREE,USER3FREE }};		// Für altes LinkformatBoolean		userfile=NewLinkFormat(gDoc)?false:true; // Bei neuem Link-Format sind Telefondaten möglich, sonst Anwenderdateien	if (!gDoc) return;					// kein Dokument offen	if(userfile && !ORG.userfree) return;	// Userfiles angewählt, aber nicht vorhanden	d = GetCenteredDialog(userfile?dFreifeldAnw:dFreifeld,nil);	if (!d) return;						// Dialog nicht zu öffnen	OutlineDialogItem(d,1);				// Default-Button zeichnen	gTEMaxLen = 12;						// maximale Länge für TextEdit	GetFFText(d,convtab[userfile][LastPopup]);	// Texte übertragen	NewPopup(d,4,userfile?164:160,5,LastPopup);	// zu suchende Gruppe	while (d) {		ModalDialog((ModalFilterProcPtr)OwnTELenFilter,&button);		if ((button==1)||(button==3)) break;		if (button == 4) {				// Popup-Menü?			TESetSelect(0,0,((DialogPeek)d)->textH);	// evtl. Selektierung aufheben			button = GetPopupValue(d,4);			// selektiertes Item			if (button != LastPopup) {				// anderer Button selektiert?				SetFFText(d,convtab[userfile][LastPopup]);// dann die aktuellen wegschreiben				GetFFText(d,convtab[userfile][button]);	// und neue holen				LastPopup = button;			}			CheckDoc(gDoc);		}	}	if (button == 1) {		AppDocumentDirty(gDoc,true);				// Document ist jetzt dirty		SetFFText(d,convtab[userfile][LastPopup]);	// aktuelle Einträge wegschreiben		if(userfile)			DoMultiRedraw(USERFILE1,redrawAndRecalc,nil);		else {			DoMultiRedraw(TEL1DATA,redrawAndRecalc,nil);			DoMultiRedraw(BUSINESS,redrawAndRecalc,nil);		}		CheckDoc(gDoc);	}	DisposeObjects(d);	DisposDialog(d);}void	GetTFname(DialogPtr d,short item,IQFileType index);void	GetTFname(DialogPtr d,short item,IQFileType index){ListH		l;Str255		s;REG WORD	i;	l = GetListH(GetOrgH(gDoc),index);	// Handle auf die Liste holen	GetNextList(&l,"t%",index);			// Element suchen	if (l) {							// Eintrag auf vorhanden?		vStrcpy((char*)s,(*l)->d);		// dann übertragen		CtoPstr((STR)s);	} else {		GetIndString(s,strTelefon,strTel1 + index - TEL1FILE);	}	i = s[0];	if(i>10)		i=s[0]=10;	while(i-->1) {		if (s[i+1] != ' ') break;		s[0]--;	}	SetIText((Handle)GetCH(d,item),s);			// Itemtext setzen}void	SetTFname(DialogPtr d,short item,IQFileType index);void	SetTFname(DialogPtr d,short item,IQFileType index){ListH		l;Str255		s;	GetIText((Handle)GetCH(d,item),s);			// Itemtext holen	while(s[0]<10) {		s[1+s[0]] = ' ';				// auf 10 Zeichen auffüllen		s[0]++;	}	s[0] = 10;							// Länge ist maximal 10!	PtoCstr(s);							// Text in einen C-String wandeln	if((index>=TEL1FILE) && (index<=TEL3FILE))	// Telefonnamen sind eine einzelne Datei	{		SharpIndexClr(GetOrgH(gDoc),index);	// Einträge aus der Liste löschen			l = (ListH)NewHandleClear(sizeof(List)+10);	// und einen neuen Eintrag erzeugen		if (!l) {			CheckOSError(MemError());		// Fehler melden			return;							// und raus!		} else {			(*l)->type = index;				// Typ: UserDic			BlockMove(s,(*l)->d,10);		// String übertragen		}		AppendToList(GetOrgH(gDoc),index,l);// an die Liste anhängen	}else									// Sonst sind es UserFree-Fields, da hängt der	{										// Name vor jedem Datensatz von ORG.userfree		l=ORG.userfree;		while(l && ((*l)->type!=index))		// Richtige Datei suchen			l=(*l)->next;					if(!l)								// Fehler: Passende UserFree nicht gefunden!		{			SysBeep(BEEPTIME);			return;		}		BlockMove(s,(*l)->d,10);			// Die ersten 10 Bytes rüberkopieren	}}/*** *	Editor für Telefonfilenamen und UserFree-Felder ***/void	DoTelfname(void){DialogPtr	d;							// Ptr auf diverse Dialogeshort		button;						// Exit-ButtonBoolean		userfile=NewLinkFormat(gDoc)?false:true; // Bei neuem Link-Format sind Telefondaten möglich	if (!gDoc) return;					// kein Dokument offen	if ((!NewLinkFormat(gDoc)) && (!userfile)) return;	// kein IQ-8000 und keine Userfiles? => raus	if (!gTopWindow) return;			// Kein Fenster offen	d = GetCenteredDialog(dTelefonfname,nil);	if (!d) return;						// Dialog nicht zu öffnen	if(userfile)	{		GetTFname(d,4,USER1FREE);		GetTFname(d,5,USER2FREE);		GetTFname(d,6,USER3FREE);	}else	{		GetTFname(d,4,TEL1FILE);		GetTFname(d,5,TEL2FILE);		GetTFname(d,6,TEL3FILE);	}	OutlineDialogItem(d,1);				// Default-Button zeichnen	gTEMaxLen = 10;						// maximale Länge für TextEdit	while (d) {		ModalDialog((ModalFilterProcPtr)OwnTELenFilter,&button);		if ((button == 1)||(button == 3)) break;	}	if (button == 1) {					// “OK“?		if(userfile)		{			SetTFname(d,4,USER1FREE);			SetTFname(d,5,USER2FREE);			SetTFname(d,6,USER3FREE);		}else		{			SetTFname(d,4,TEL1FILE);			SetTFname(d,5,TEL2FILE);			SetTFname(d,6,TEL3FILE);		}		AppDocumentDirty(gDoc,true);	// Document ist jetzt dirty		if (gTopWindow && gTheFloatWind)	// ein Window und das Float vorhanden?			UpdateFloat(gTopWindow);	// dann das Float ggf. updaten		CheckDoc(gDoc);	}	DisposDialog(d);}