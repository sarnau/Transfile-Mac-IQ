/*** *	Empfangsroutinen für den Sharp ***/#include "IQSharpEmpfang.h"#include "IQComm.h"#include "SerialComm.h"#include "List.h"#include "CheckList.h"/*** *	Leerfunktion für nicht implementierte Download-Funktionen ***/OSErr	IQDlNull(OrganizerH o,IQFileType index){REG OSErr	err;UCHAR		s;	SDSetBrk(0x1A);					// ab jetzt bis zum CTRL-Z lesen	do {		err = SDRead(&s,1);			// Daten komplett ignorieren		if (err<0) return(err);	} while(s != 0x1A);				// bis zum CTRL-Z (= Ende) lesen	return(noErr);}/*** *	Download-Funktion für Tel ***/OSErr	IQDlTelData(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[2048+256];			// maximale Tel-GrößeREG UBYTE	attr;REG ListH	l;					// List-HandleREG ListH	h;REG UWORD	offset,i,anz;	do {		err = SDRead((USTR)&s[0],1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;		// alle Daten eingelesen		offset = 1;		anz=(IQGetHeader(o)==(LINKFORM1<<8))?3:3+5;	// Anzahl der Einträge		for(i=0;i<anz;i++) {			err = SDRead(&s[offset],2100);	// Name einlesen			if (err<0) return(err);			offset += err-1;			// LF wieder überschreiben		} 		s[offset-1]=0;					// String abschließen 		// Tel-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s[2]));		err = MemError();		if (err<0) return(err);		attr = IQGetHexB(&s[0]);		// Attribut merken		(*l)->type = index;				// Typ		(*l)->b.marked = (attr & 0x80) == 0x80;		(*l)->b.displaymode = (attr & 0x20) == 0x20;		HLock((Handle)l);		IQGetStringNull((USTR)&((*l)->d),&s[2]);		HUnlock((Handle)l);//		AppendToList(o,index,l);		// Tel-Struktur anhängen:		SortToList(o,index,l);			// in Tel-Liste einsortieren	} while(1==1);	return(noErr);}/*** *	Download-Funktion für MEMO ***/OSErr	IQDlMemo(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[2200];				// maximale Memo-GrößeREG UBYTE	attr;REG ListH	l;						// List-HandleREG ListH	h;	do {		err = SDRead((USTR)&s,1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;	// alle Daten eingelesen		err = SDRead(&s[1],2200);	// Bytes einlesen		if (err<0) return(err);		attr = IQGetHexB(&s[0]);	// Attribut merken		s[err-1] = 0;				// CR/LF am Stringende abscheinden 		// Memo-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s));		err = MemError();		if (err<0) return(err);		HLock((Handle)l);		(*l)->type = index;			// Typ		(*l)->b.marked = (attr & 0x80) == 0x80;		(*l)->b.displaymode = (attr & 0x20) == 0x20;		IQGetStringCr((USTR)&((*l)->d),&s[2]);		HUnlock((Handle)l);		AppendToList(o,index,l);		// Memo-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für Outliner ***/OSErr	IQDlOutline(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[2048+5];				// maximale Outliner-GrößeREG UBYTE	attr;REG ListH	l;						// List-HandleREG ListH	h;REG short	i;REG long	oldlen;REG USTR	tempS;	do {		err = SDRead(&s[0],1);			// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;		// alle Daten eingelesen		err = SDRead(&s[1],1+6+4);		// Attribut, Länge und Anzahl einlesen		i = IQGetHexB(&s[8])+(IQGetHexB(&s[10])<<8);	// Anzahl der Datensätze		attr = IQGetHexB(&s[0]);		// Attribut merken		// Outliner-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+10);	// noch ohne Strings		err = MemError();		if (err<0) return(err);		(*l)->type = index;				// Typ		(*l)->b.marked = (attr & 0x80) == 0x80;		(*l)->b.displaymode = (attr & 0x20) == 0x20;		BlockMove(&s[2],(*l)->d,10);		while(i>0) {			err = SDRead(&s[0],2052);	// eine Description einlesen			if (err<0) {				DisposHandle((Handle)l);// Speicherblock wieder freigeben				return(err);			}			s[err-1] = 0;				// String mit Nullbyte abschließen			oldlen = GetHandleSize((Handle)l);	// Alte Länge merken			SetHandleSize((Handle)l,oldlen+Strlen((STR)s)); // neue Länge			err = MemError();			if (err<0) {				DisposHandle((Handle)l);// Speicherblock wieder freigeben				return(err);			}			HLock((Handle)l);			tempS = (USTR)(*l)+oldlen-2;			*tempS++ = s[0]; *tempS++ = s[1];			IQGetStringNull(tempS,&s[2]);			HUnlock((Handle)l);			i--;		}		AppendToList(o,index,l);		// Outliner-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für Business Card ***/OSErr	IQDlBusiness(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[3000];				// maximale Business Card-GrößeREG UBYTE	attr;REG ListH	l;						// List-HandleREG ListH	h;REG UWORD	offset;REG short	i;	do {		err = SDRead((USTR)&s[0],1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;		// alle Daten eingelesen		offset = 1;		for(i=0;i<13;i++) {			err = SDRead(&s[offset],2048);	// alle Felder einlesen			if (err<0) return(err);			offset += err-1;			// LF wieder überschreiben		} 		s[offset-1]=0;					// String abschließen		attr = IQGetHexB(&s[0]);		// Attribut merken 		// Memo-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s));		err = MemError();		if (err<0) return(err);		HLock((Handle)l);		(*l)->type = index;				// Typ		(*l)->b.marked = (attr & 0x80)==0x80;		(*l)->b.displaymode = (attr & 0x20)==0x20;		IQGetStringNull((USTR)&((*l)->d),&s[2]);		HUnlock((Handle)l);		AppendToList(o,index,l);		// Business Card-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für Schedule ***/OSErr	IQDlSchedule(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[2048+256];			// maximale Schedule-GrößeREG UBYTE	attr;REG ListH	l;						// List-HandleREG ListH	h;	do {		err = SDRead((USTR)&s,1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;	// alle Daten eingelesen		err = SDRead(&s[1],24);		// Bytes einlesen		if (err<0) return(err);		err = SDRead(&s[24],2048+2);// Bytes einlesen		if (err<0) return(err); 		s[24+err-2]=0;				// String abschließen		// Schedule-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s[24]));		err = MemError();		if (err<0) return(err);		attr = IQGetHexB(&s[0]);	// Attribut merken		HLock((Handle)l);		(*l)->type = index;			// Typ		(*l)->b.marked = (attr & 0x80)==0x80;		(*l)->b.alarm = (attr & 0x40)==0x40;		(*l)->b.displaymode = (attr & 0x20)==0x20;		IQGetStringCr((USTR)&((*l)->d),&s[24]);		(*l)->t.schedule.year	= IQGetDez(&s[2],4);		(*l)->t.schedule.month	= IQGetDez(&s[6],2);		(*l)->t.schedule.day	= IQGetDez(&s[8],2);		(*l)->t.schedule.shour	= IQGetDez(&s[10],2);		(*l)->t.schedule.sminute= IQGetDez(&s[12],2);		(*l)->t.schedule.ehour	= IQGetDez(&s[14],2);		(*l)->t.schedule.eminute= IQGetDez(&s[16],2);		(*l)->t.schedule.ahour	= IQGetDez(&s[18],2);		(*l)->t.schedule.aminute= IQGetDez(&s[20],2);		HUnlock((Handle)l);		AppendToList(o,index,l);		// Schedule-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für Ann1 ***/OSErr	IQDlAnn1(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[2048+256];			// maximale Schedule-GrößeREG UBYTE	attr;REG ListH	l;						// List-HandleREG ListH	h;	do {		err = SDRead((USTR)&s,1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;	// alle Daten eingelesen		err = SDRead(&s[1],7);		// Bytes einlesen		if (err<0) return(err);		err = SDRead(&s[8],2048+2);// Bytes einlesen		if (err<0) return(err); 		s[8+err-2]=0;				// String abschließen 		// Ann1-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s[8]));		err = MemError();		if (err<0) return(err);		attr = IQGetHexB(&s[0]);	// Attribut merken		HLock((Handle)l);		(*l)->type = index;			// Typ		(*l)->b.displaymode = (attr & 0x20)==0x20;		IQGetStringCr((USTR)&((*l)->d),&s[8]);		(*l)->t.ann1.month	= IQGetDez(&s[2],2);		(*l)->t.ann1.date	= IQGetDez(&s[4],2);		HUnlock((Handle)l);		AppendToList(o,index,l);		// Ann1-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für Ann2 ***/OSErr	IQDlAnn2(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[2048+256];			// maximale Schedule-GrößeREG UBYTE	attr;REG ListH	l;						// List-HandleREG ListH	h;	do {		err = SDRead((USTR)&s,1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;	// alle Daten eingelesen		err = SDRead(&s[1],7);		// Bytes einlesen		if (err<0) return(err);		err = SDRead(&s[8],2048+2);// Bytes einlesen		if (err<0) return(err); 		s[8+err-2]=0;				// String abschließen 		// Ann1-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s[8]));		err = MemError();		if (err<0) return(err);		attr = IQGetHexB(&s[0]);	// Attribut merken		HLock((Handle)l);		(*l)->type = index;			// Typ		(*l)->b.displaymode = (attr & 0x20)==0x20;		IQGetStringCr((USTR)&((*l)->d),&s[8]);		(*l)->t.ann2.month	= IQGetDez(&s[2],2);		(*l)->t.ann2.week	= s[4]-'0';		(*l)->t.ann2.day	= s[5]-'0';		HUnlock((Handle)l);		AppendToList(o,index,l);		// Ann2-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für DoList ***//*** *	Dezimalzahl holen ***/UWORD	IQGetDezSpez(REG USTR p);UWORD	IQGetDezSpez(REG USTR p){REG UWORD	a = 0;REG Boolean	flag = false;	while(*p == ' ') p++;			// Leerzeichen überspringen	while((*p >= '0')&&(*p <= '9')) {		a *= 10;		a += (*p++ - '0');		flag = true;	}	if (flag)		return(a);	else		return(-1);}OSErr	IQDlDoList(OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[2048+2];				// maximale DoList-GrößeREG ListH	l;						// List-HandleREG USTR	sp;REG USTR	sp2;REG USTR	sp3;REG Boolean	flag;	do {		err = SDRead((USTR)&s,1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;	// alle Daten eingelesen		err = SDRead(&s[1],2048+2);	// Bytes einlesen		if (err<0) return(err);		s[err-1] = 0;				// CR/LF am Stringende abscheinden		sp3 = s+err-1;		// DoList-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s));		err = MemError();		if (err<0) return(err);		HLock((Handle)l);		(*l)->type = index;				// Typ		(*l)->b.marked = (s[0]=='1');		sp = &s[3];		sp2 = (USTR)&(*l)->d;		IQGetStringNull(sp,sp);			// Zeichensatz umrechnen		while(*--sp3 != '\t');		while(*--sp3 != '\t');			// 3 Tabs überlesen		while(*--sp3 != '\t');		sp3 -= 3;		while(sp != sp3-1) *sp2++ = *sp++;// Description kopieren		*sp2++ = '\r';		(*l)->t.todo.prio	= (sp3[1]<<8)|sp3[2];		// Priorität		flag = (sp3[6] == '.');			// True, wenn dd.mm.yyyy, sonst mm/dd/yyyy		(*l)->t.todo.year	= IQGetDezSpez(&sp3[10]);		(*l)->t.todo.month	= IQGetDezSpez(&sp3[flag?7:4]);		(*l)->t.todo.day	= IQGetDezSpez(&sp3[flag?4:7]);		sp3 += 16;		while(*sp3 != '\t') *sp2++ = *sp3++;	// Managername kopieren		*sp2++ = '\r'; sp3 += 2;		while((*sp3 != '\r')&&(*sp3 != 0)) *sp2++ = *sp3++;	// Managername kopieren		*sp2 = 0;		HUnlock((Handle)l);		FixListEntry(l);				// Länge fixieren (da garantiert zu lang…)		SortToList(o,index,l);			// DoList-Struktur eintragen	} while(1==1);	return(noErr);}/*** *	Download-Funktion für Expense ***/OSErr	IQDlExpense(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[2048+2];				// maximale Expense-GrößeREG ListH	l;						// List-HandleREG ListH	h;REG USTR	sp;REG USTR	sp2;REG Boolean	flag;	do {		err = SDRead((USTR)&s,1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;	// alle Daten eingelesen		err = SDRead(&s[1],2048+2);	// Bytes einlesen		if (err<0) return(err);		s[err-1] = 0;				// CR/LF am Stringende abscheinden 		// Expense-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s));		err = MemError();		if (err<0) return(err);		HLock((Handle)l);		(*l)->type = index;			// Typ		(*l)->b.marked = (s[0]=='1');		sp = &s[3];		sp2 = (USTR)&(*l)->d;		IQGetStringNull(sp,sp);			// Zeichensatz umrechnen		flag = (sp[2] == '.');			// True, wenn dd.mm.yyyy, sonst mm/dd/yyyy		(*l)->t.expense.year	= IQGetDezSpez(&sp[6]);		(*l)->t.expense.month	= IQGetDezSpez(&sp[flag?3:0]);		(*l)->t.expense.day		= IQGetDezSpez(&sp[flag?0:3]);		sp += 12;		while(*sp != '\t') *sp2++ = *sp++;	// Expense type kopieren		*sp2++ = '\r'; sp++;		while(*sp != '\t') *sp2++ = *sp++;	// Amount kopieren		*sp2++ = '\r'; sp += 2;		while(*sp != '\t') *sp2++ = *sp++;	// Payment type kopieren		*sp2++ = '\r';		(*l)->b.alarm = false;		if (sp[1] != 'N') (*l)->b.alarm = true;		sp += 3;		while((*sp != '\r')&&(*sp != 0)) *sp2++ = *sp++;	// Managername kopieren		*sp = 0;						// String abschließen		HUnlock((Handle)l);		FixListEntry(l);				// Länge fixieren (da garantiert zu lang…)		AppendToList(o,index,l);		// Expense-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für Time Accouting ***/OSErr	IQDlTimeAcc(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[2048+2];				// maximale TimeAcc-GrößeREG ListH	l;						// List-HandleREG ListH	h;	do {		err = SDRead((USTR)&s,1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;	// alle Daten eingelesen		err = SDRead(&s[1],2048+2);	// Bytes einlesen		if (err<0) return(err);		s[err-1] = 0;				// CR/LF am Stringende abscheinden 		// TimeAcc-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s));		err = MemError();		if (err<0) return(err);		HLock((Handle)l);		(*l)->type = index;			// Typ		(*l)->b.marked = (s[0]=='1');		IQGetStringCr((USTR)&((*l)->d),&s[3]);		HUnlock((Handle)l);		AppendToList(o,index,l);		// TimeAcc-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für Daily alarm ***/OSErr	IQDlDAlarm(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[8];					// maximale DAlarm-GrößeREG ListH	l;						// List-HandleREG ListH	h;REG UBYTE	attr;	do {		err = SDRead((USTR)&s,1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;	// alle Daten eingelesen		err = SDRead(&s[1],7);		// Bytes einlesen		if (err<0) return(err); 		// DAlarm-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List));		err = MemError();		if (err<0) return(err);		(*l)->type = index;			// Typ		attr = IQGetHexB(&s[0]);	// Attribut merken		(*l)->b.alarm = (attr & 0x40)==0x40;		(*l)->t.dalarm.hour		= IQGetDez(&s[2],2);		(*l)->t.dalarm.minute	= IQGetDez(&s[4],2);		AppendToList(o,index,l);		// DAlarm-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für Period Schedule ***/OSErr	IQDlPSchedule(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[2048+256];			// maximale Period Schedule-GrößeREG UBYTE	attr;REG ListH	l;						// List-HandleREG ListH	h;REG UWORD	offset;	do {		err = SDRead((USTR)&s,1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;	// alle Daten eingelesen		offset = 1;		err = SDRead(&s[offset],24);	// Bytes einlesen		if (err<0) return(err);		offset += err-1; 		err = SDRead(&s[offset],2048);	// Bytes einlesen		if (err<0) return(err);		offset += err-1;		s[offset-1]=0;					// String abschließen 		// Period Schedule-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s[19]));		err = MemError();		if (err<0) return(err);		attr = IQGetHexB(&s[0]);	// Attribut merken		HLock((Handle)l);		(*l)->type = index;			// Typ		(*l)->b.marked = (attr & 0x80)==0x80;		(*l)->b.displaymode = (attr & 0x20)==0x20;		IQGetStringCr((USTR)&((*l)->d),&s[19]);		(*l)->t.psched.syear	= IQGetDez(&s[2],4);		(*l)->t.psched.smonth	= IQGetDez(&s[6],2);		(*l)->t.psched.sday		= IQGetDez(&s[8],2);		(*l)->t.psched.eyear	= IQGetDez(&s[10],4);		(*l)->t.psched.emonth	= IQGetDez(&s[14],2);		(*l)->t.psched.eday		= IQGetDez(&s[16],2);		HUnlock((Handle)l);		AppendToList(o,index,l);		// Period Schedule-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für Tel File Name ***/OSErr	IQDlTelFile(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[14];					// maximale Tel File Name-GrößeREG ListH	l;						// List-HandleREG ListH	h;	do {		err = SDRead((USTR)&s,1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;	// alle Daten eingelesen		err = SDRead(&s[1],13);		// Bytes einlesen		if (err<0) return(err); 		s[err]=0;					// String abschließen 		// Tel File Name-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s[2]));		err = MemError();		if (err<0) return(err);		HLock((Handle)l);		(*l)->type = index;			// Typ		IQGetStringCr((USTR)&((*l)->d),&s[2]);		HUnlock((Handle)l);		AppendToList(o,index,l);		// Tel File Name-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für Tel Free ***/OSErr	IQDlTelFree(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[80];					// maximale Tel-FreeREG ListH	l;						// List-HandleREG ListH	h;REG UWORD	offset,i;	do {		err = SDRead((USTR)&s[0],1);// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;		// alle Daten eingelesen		offset = 1;		for(i=0;i<5;i++) {			err = SDRead(&s[offset],15);// Name einlesen			if (err<0) return(err);			offset += err-1;			// LF wieder überschreiben		} 		s[offset]=0;					// String abschließen 		// Tel-Free-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s[2]));		err = MemError();		if (err<0) return(err);		(*l)->type = index;				// Typ		IQGetStringNull((USTR)&((*l)->d),&s[2]);		AppendToList(o,index,l);		// Tel-Free-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für Business Free Field ***/OSErr	IQDlBusFree(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[80];					// maximale Business Free FieldREG ListH	l;						// List-HandleREG ListH	h;REG UWORD	offset,i;	do {		err = SDRead((USTR)&s[0],1);// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;		// alle Daten eingelesen		offset = 1;		for(i=0;i<5;i++) {			err = SDRead(&s[offset],15);// Name einlesen			if (err<0) return(err);			offset += err-1;			// LF wieder überschreiben		} 		s[offset]=0;					// String abschließen 		// Business Free Field-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s[2]));		err = MemError();		if (err<0) return(err);		(*l)->type = index;				// Typ		IQGetStringNull((USTR)&((*l)->d),&s[2]);		AppendToList(o,index,l);		// Business Free Field-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für das UserDic ***/OSErr	IQDlUserDic(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[44];					// maximale UserDic-GrößeREG ListH	l;						// List-HandleREG ListH	h;	do {		err = SDRead((USTR)&s,1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;	// alle Daten eingelesen		err = SDRead(&s[1],43);		// Bytes einlesen		if (err<0) return(err); 		s[err]=0;					// String abschließen 		// UserDic-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s[2]));		err = MemError();		if (err<0) return(err);		HLock((Handle)l);		(*l)->type = index;			// Typ		IQGetStringCr((USTR)&((*l)->d),&s[2]);		HUnlock((Handle)l);		AppendToList(o,index,l);		// UserDic-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für USERFILEs ***/OSErr	IQDlUserfile(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[2048+2];				// maximale Memo-GrößeREG UBYTE	attr;REG ListH	l;						// List-HandleREG ListH	h;	do {		err = SDRead((USTR)&s,1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;	// alle Daten eingelesen		err = SDRead(&s[1],2048+2);	// Bytes einlesen		if (err<0) return(err);		attr = IQGetHexB(&s[0]);	// Attribut merken		s[err-1] = 0;				// CR/LF am Stringende abscheinden 		// Userfile-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s));		err = MemError();		if (err<0) return(err);		HLock((Handle)l);		(*l)->type = index;			// Typ		(*l)->b.marked = (attr & 0x80)==0x80;		IQGetStringCr((USTR)&((*l)->d),&s[2]);		{			REG STR	p = (STR)&((*l)->d);			while(*p) {				if (*p == '\t')					*p = '\r';				if (*p == '•')		// CHR$(7) wird in CHR$(0x65) gewandelt, das ist ein Bullet					*p = '\t';				p++;			}		}		HUnlock((Handle)l);		SortToList(o,index,l);		// Userfile-Struktur einsortieren		if ((index>=USER1FREE)&&(index<=USER3FREE)) break;	// Freifelder sind nur der erste String	} while(1==1);	return(noErr);}/*** *	Download-Funktion für Time… ***/OSErr	IQDlTime(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[2048+2];				// maximale Memo-GrößeREG UBYTE	attr;REG ListH	l;						// List-HandleREG ListH	h;	do {		err = SDRead((USTR)&s,1);	// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;	// alle Daten eingelesen		err = SDRead(&s[1],2048+2);	// Bytes einlesen		if (err<0) return(err);		attr = IQGetHexB(&s[0]);	// Attribut merken		s[err-1] = 0;				// CR/LF am Stringende abscheinden 		// Time-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s));		err = MemError();		if (err<0) return(err);		HLock((Handle)l);		(*l)->type = index;			// Typ		(*l)->b.marked = (attr & 0x80)==0x80;		IQGetStringCr((USTR)&((*l)->d),&s[2]);		HUnlock((Handle)l);		SortToList(o,index,l);		// Time-Struktur anhängen:	} while(1==1);	return(noErr);}/*** *	Download-Funktion für Aufgaben ***/OSErr	IQDlTodo(REG OrganizerH o,REG IQFileType index){REG OSErr	err;UCHAR		s[2500];				// maximale Business Free FieldREG ListH	l;						// List-HandleREG ListH	h;REG UWORD	offset,i;REG UBYTE	attr;REG USTR	sp;REG CHAR	TempChar;USTR		st;USTR		sf;CHAR		c;	do {		err = SDRead((USTR)&s[0],1);// ein Byte einlesen		if (err<0) return(err);		if (s[0] == 0x1A) break;		// alle Daten eingelesen		offset = 1;		for(i=0;i<6;i++) {			err = SDRead(&s[offset],2070);// Feld einlesen			if (err<0) return(err);			offset += err-1;			// LF wieder überschreiben		} 		s[offset]=0;					// String abschließen 		// Aufgaben-Struktur anlegen:		l = (ListH)NewHandleClear(sizeof(List)+Strlen((STR)&s[16]));		err = MemError();		if (err<0) return(err);		(*l)->type = index;				// Typ		attr = IQGetHexB(&s[0]);		// Attribut merken		(*l)->b.marked = (attr & 0x80)==0x80;		(*l)->b.displaymode = (attr & 0x20)==0x20;		(*l)->t.todo.year	= IQGetDez(&s[2],4);		(*l)->t.todo.month	= IQGetDez(&s[6],2);		(*l)->t.todo.day	= IQGetDez(&s[8],2);		TempChar = s[10];		if (TempChar == '≈') TempChar = '√';		(*l)->t.todo.prio	= (UCHAR)TempChar;	// Priorität		st = (USTR)&(*l)->d;		sp = IQGetStringNull(st,&s[16]);		*--sp = 0;						// letztes CR entfernen		sp = st; sf = st;		while(c = *st++) {			*sp = c;					// Zeichen kopieren			if (c == '\r') {			// Feldende erreicht?				while ((sf < sp)&&(sp[-1] == ' '))					sp--;				// angehängte Leerzeichen entfernen				*sp = '\r';				// neues Return			}			sp++;		}		*sp = 0;						// String wieder mit Nullbyte abschließen		SortToList(o,index,l);			// Aufgaben-Struktur anhängen	} while(1==1);	return(noErr);}