/*** *	Kleinkram-Routinen ***/#pragma once	// include this header				// only once per source filechar		HLockH(REG Handle theHandle);void		ConcatPString(REG Str255 d,REG Str255 s);void		CopyPString(REG Str255 d,REG Str255 s);Boolean		ComparePString(REG Str255 s1,REG Str255 s2);char		hex(REG UWORD i);short		GetHexByte(REG char *cptr);void		usetmouse(short x,short y);void		resetsuper(void);void		uonsuper(void);void		uoffsuper(void);#define JUMPBUFFER_A1	5		/* Index of A1 in JumpBuffer */typedef long	JumpBuffer[11];extern	JumpBuffer		gJumpBuffer;	/* LongJump to Event-Loop */short	f_SetJump(JumpBuffer theJumpBuffer);void	f_LongJump(JumpBuffer theJumpBuffer, short returnVal);/*** *	Handy Macros/inlines ***//* define our own abs() so we don't need StdLib */#define ABS(val) (((val) < 0) ? (-(val)) : (val))/* Pascal string copy */#define PStrCopy(dest, src)	(BlockMove (src, dest, (*(char *)(src))+1))#define TopLeft(r)		(* (Point *) &(r).top)#define BotRight(r)		(* (Point *) &(r).bottom)#define HiWrd(aLong)	(((short *) &(aLong))[0])#define LoWrd(aLong)	(((short *) &(aLong))[1])#define MIN(a, b) ((a) < (b) ? (a) : (b) )#define MAX(a, b) ((a) > (b) ? (a) : (b) )#define SETPT(pt, x, y)	(*(pt)).h = (x); (*(pt)).v = (y)#define SETRECT(r, left, top, right, bottom)	\						SETPT(&TopLeft(*(r)), (left), (top)); \						SETPT(&BotRight(*(r)), (right), (bottom))/*** *	What RGB value does the system use for dimmed buttons, menus and *	window titles? * *	The gray color does not have a fixed RGB value. It is a weighted average *	of the foreground and background colors. To obtain the appropriate "gray" *	color for a given foreground and background color, the Palette Manager *	routine GetGray can be used: ***///pascal Boolean GetGray(GDHandle device,const RGBColor *backGround,RGBColor *foreGround) = {0x303C,0x1219,0xAAA2};/*** *	If at least one gray or intermediate color is available, GetGray stores *	the color in foreGround and returns true. If no gray is available, or, if *	you supplied two colors, no third distinguishable color is available, the *	foreGround parameter is unchanged and the function returns false. ***//*  *	Useful macros for testing gestalt attribute responses * *	BTstBool returns a true boolean value (0 or 1), but is slower than: *	BTstQ which simply returns a non-zero value if the bit is set which *	means the result could get lost if assigned to a short, for example. * *	arg is any integer value, bitnbr is the number of the bit to be tested. *	bitnbr = 0 is the least significant bit. */#define BTstBool(arg, bitnbr)	(((arg) >> (bitnbr)) & 1)#define BTstQ(arg, bitnbr)		((arg) & (1L << (bitnbr)))#define chBackspace				'\b'		/* ASCII code for Backspace character */#define chClear					'\033'		/* ASCII code for Clear key (aka ESC) */#define chDown					'\037'		/* ASCII code for down arrow */#define chEnd					'\004'		/* ASCII code for the End key */#define chEnter					'\003'		/* ASCII code for Enter character */#define chEscape				'\033'		/* ASCII code for Escape (aka Clear) key */#define chFunction				'\020'		/* ASCII code for any function key */#define chFwdDelete				'\177'		/* ASCII code for forward delete */#define chHelp					'\005'		/* ASCII code for Help key */#define chHome					'\001'		/* ASCII code for the Home key */#define chLeft					'\034'		/* ASCII code for left arrow */#define chPageDown				'\f'		/* ASCII code for Page Down key */#define chPageUp				'\013'		/* ASCII code for Page Up key */#define chReturn				'\n'		/* ASCII code for Return character */#define chRight					'\035'		/* ASCII code for right arrow */#define chSpace					' '			/* ASCII code for Space character */#define chTab					'\t'		/* ASCII code for Tab character */#define chUp					'\036'		/* ASCII code for up arrow */