/*** *	Dieser Source ersetzt _sŠmtliche_ Control Manager Aufrufe durch eigene! *	Die eigenen unterscheiden sich lediglich durch ein "o" als ersten Buchstaben *	von den Originalaufrufen. * *	Ausnahme von der Regel: GetNewControl() (da der Resource-Template eh auf Wortbreite *											 ausgelegt istÉ) * *	Sinn der Sache: Slider haben nun einen Langwort-Bereich! * *	©1992 ·-Soft, Markus Fritze ***/#include "LongControl.h"// Diese Struktur wird in refCon vom Control eingeklinkt:typedef struct	OwnControlStruct {	LONG	refCon;					// refCon vom ÒAnwenderÓ	LONG	value;					// Langwort-Wert vom aktuellen Slider	LONG	min;					// Langwort-Wert vom minimalen Sliderwert	LONG	max;					// Langwort-Wert vom maximalen Sliderwert} OwnControlStruct,*OwnControlPtr,**OwnControlHndl;// Folgende Funktion sind _nur_ innerhalt der Library erlaubt:// Handle auf die eigene Struktur aus der ControlHandle ermittelnOwnControlHndl	ooGetOwnCtrl(ControlHandle c);// Control-Funktion aufrufenlong			ooCallControl(ControlHandle c,WORD funk,LONG param);// Control neu ausgeben (param = 0), bzw. Slider updaten (param = InThumb)VOID			ooUpdateControl(ControlHandle c,WORD param);// Value vom Control Manager-Slider gemŠ§ des Langwort-Values setzen (im VerhŠltnis)// und Slider updaten (wenn nštig)VOID			ooUpdateControlValue(ControlHandle c);/*** *	Control anmelden ***/ControlHandle	oNewControl(WindowPtr w,Rect *r,Str255 title,Boolean visible,LONG value,LONG min,LONG max,WORD ctrlType,LONG refCon){REG ControlHandle	c;REG OwnControlHndl	o;	o = (OwnControlHndl)NewHandle(sizeof(OwnControlStruct));	// eigene Handle allozieren	if (MemError()) return(0);				// Fehler => raus	c = NewControl(w,r,title,visible,0,0,32767,ctrlType,(long)o);	// Control anmelden	if (!c) {		DisposHandle((Handle)o);			// eigene Struktur wieder freigeben		return(0);							// Fehler => raus	}	(*o)->min	= min;						// Sliderwerte merken	(*o)->max	= max;	(*o)->value	= value;	oSetCRefCon(c,refCon);	ooUpdateControlValue(c);				// Slider updaten	return(c);}/*** *	Control abmelden ***/VOID			oDisposeControl(REG ControlHandle c){REG OwnControlHndl	o;	if (!c) return;							// Control angegeben? Nein => raus	o = (OwnControlHndl)GetCRefCon(c);		// Handle auf eigene Struktur holen	if (!o) DisposHandle((Handle)o);		// freigeben, wenn vorhanden	DisposeControl(c);						// und das Control auch freigeben}/*** *	alle Controls des Windows abmelden ***/VOID			oKillControls(WindowPtr w){REG ControlHandle	c = ((WindowPeek)w)->controlList;REG ControlHandle	last;	while(c) {								// keine weiteren Controls?		last = (*c)->nextControl;			// Handle auf den Folgecontrol merken		oDisposeControl(c);					// Control freigeben		c = last;							// und Pointer wieder setzen	}}/*** *	Control-Funktion aufrufen * *	(interne Funktion) ***/long			ooCallControl(REG ControlHandle c,WORD funk,LONG param){GrafPtr		oldPort;REG Handle	p;REG LONG	ret;	GetPort(&oldPort);	SetPort((*c)->contrlOwner);				// Grafport auf das Control	p = (Handle)StripAddress((*c)->contrlDefProc);	// Handle auf die CDEF-Funktion	if (!*p) {		LMSetROMMapInsert(0xFF);			// Resource aus dem ROM holen		LoadResource(p);					// und laden		if (!*p) SysError(88);				// Resource nicht (im ROMÉ) gefunden	}	HLock(p);	ret = ((pascal long (*)(WORD,ControlHandle,WORD,long))*p)(GetCVariant(c),c,funk,param);	HUnlock(p);	SetPort(oldPort);						// alten Grafport wieder setzen	return(ret);							// RŸckgabewert der Control-Funktion}/*** *	Control-Element neu zeichnen * *	(interne Funktion) ***/VOID			ooUpdateControl(REG ControlHandle c,WORD param){	if (!(*c)->contrlVis) return;			// Control unsichtbar? dann raus =>	ooCallControl(c,drawCntl,param);}/*** *	Handle auf interne Control-Struktur zurŸckgeben * *	(interne Funktion) ***/OwnControlHndl	ooGetOwnCtrl(REG ControlHandle c){REG OwnControlHndl	o;	if (!c) return(0);	o = (OwnControlHndl)GetCRefCon(c);		// Handle auf eigene Struktur holen	return(o);}/*** *	ÒechtenÓ Sliderwert gemŠ§ des Langwort-Wertes setzen * *	(interne Funktion) ***/VOID			ooUpdateControlValue(REG ControlHandle c){REG OwnControlHndl	o = ooGetOwnCtrl(c);REG LONG			valL,minL,maxL,valS;REG WORD			minS,maxS;	if (!o) return;	minL = (*o)->min; maxL = (*o)->max; valL = (*o)->value;	if (valL < minL) valL = minL;			// Value zu klein?	if (valL > maxL) valL = maxL;			// Value zu gro§?	(*o)->value = valL;						// aktuellen (evtl. korrigierten) Wert setzen	minS = GetCtlMin(c); maxS = GetCtlMax(c);	if (valL == minL)						// Slider genau auf Minimum?		valS = minS;						// dann gar nicht erst rechnenÉ	else {		if (valL == maxL)					// Slider genau auf Maximum?			valS = maxS;					// dann gar nicht erst rechnenÉ		else {			valS = ((float)(valL - minL) * (float)(maxS - minS + 1L)) / (float)(maxL - minL + 1) + minS;		}	}	SetCtlValue(c,valS);	ooUpdateControl(c,inThumb);				// Control bei Bedarf neu zeichnen}/*** *	Minimalen Control-Wert zurŸckgeben ***/long			oGetCtlMin(ControlHandle c){REG OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return(0);	return((*o)->min);}/*** *	Minimalen Control-Wert setzen ***/VOID			oSetCtlMin(REG ControlHandle c,LONG value){REG OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return;	(*o)->min = value;	ooUpdateControlValue(c);}/*** *	Maximalen Control-Wert zurŸckgeben ***/long			oGetCtlMax(ControlHandle c){REG OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return(0);	return((*o)->max);}/*** *	Maximalen Control-Wert setzen ***/VOID			oSetCtlMax(REG ControlHandle c,LONG value){REG OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return;	(*o)->max = value;	if (value)	SetCtlMax(c,32767);	else		SetCtlMax(c,0);	ooUpdateControlValue(c);}/*** *	Aktuellen Control-Wert zurŸckgeben ***/long			oGetCtlValue(ControlHandle c){REG OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return(0);	return((*o)->value);}/*** *	Aktuellen Control-Wert setzen ***/VOID			oSetCtlValue(ControlHandle c,LONG value){REG OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return;	(*o)->value = value;	ooUpdateControlValue(c);}/*** *	refCon-Wert setzen ***/long			oGetCRefCon(ControlHandle c){REG OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return(0);	return((*o)->refCon);}/*** *	Aktuellen refCon-Wert setzen ***/VOID			oSetCRefCon(ControlHandle c,LONG value){REG OwnControlHndl	o = ooGetOwnCtrl(c);	if (!o) return;	(*o)->refCon = value;}/*** *	angeklicktes Control-Element finden * *	Besonderheit zum Original: auch ein nicht ÒhilitedÓ Control wird erkannt! ***/WORD			oTestControl(REG ControlHandle c,Point localPt){REG WORD		ret = 0;	if ((*c)->contrlVis) {			// Control sichtbar?		ret = ooCallControl(c,testCntl,*(long*)&localPt);	}	return(ret);}/*** *	angeklicktes Control in einem Window finden * *	Besonderheit zum Original: auch ein nicht ÒhilitedÓ Control wird erkannt! *	(Vorteil: inaktive Controls im Window erzeugen keine Mausklick-Messages) ***/WORD			oFindControl(Point localPt,REG WindowPtr w,REG ControlHandle *c){REG WORD			ret = 0;			// nix gefundenREG WORD			temp;GrafPtr				savePort;REG ControlHandle	cl;					// Control-Liste	*c = 0;							// kein Control	if (!((WindowPeek)w)->visible) return(0);	// Window sichtbar? Nein => nichts gefunden	GetPort(&savePort);	SetPort(w);									// Windowport aktivieren	if (PtInRect(localPt,&(w->portRect))) {		// Punkt im Window-Rechteck?		cl = ((WindowPeek)w)->controlList;		// erstes Control holen		while(cl) {			if (PtInRect(localPt,&(*cl)->contrlRect))	// Punkt im Control?				*c = cl;			temp = oTestControl(cl,localPt);	// Punkt im Control?			if (temp) {							// Control angeklickt?				ret = temp;						// angeklicktes Item				*c = cl;						// gefunden? Control merken			}			cl = (*cl)->nextControl;			// sonst zum nŠchsten Control		}	}	SetPort(savePort);	return(ret);}/*** *	Errechnet aus dem "kleinene" echten Sliderwert den richtigen "gro§en" Wert ***/LONG			ThumbPosCalc(REG ControlHandle c,WORD val){REG LONG	offset	= (float)((val - GetCtlMin(c)) * (float)(oGetCtlMax(c) - oGetCtlMin(c) + 1)) /					(float)(GetCtlMax(c) - GetCtlMin(c) + 1L) + oGetCtlMin(c);	if (GetCtlValue(c) >= GetCtlMax(c))		offset = oGetCtlMax(c);	if (GetCtlValue(c) <= GetCtlMin(c))		offset = oGetCtlMin(c);	return(offset);}/*** *	Thumb wurde angeklickt. Nun wird er bewegtÉ ***/LONG			TrackThumb(Point thePoint,REG ControlHandle c,ControlActionUPP proc){REG LONG	offset = 0;REG WORD	old = GetCtlValue(c);	// alten (kleinen) Sliderwert merken	if (oTrackControl(c,thePoint,proc)) {	// Slider verschieben		REG WORD	val = GetCtlValue(c);	// neuen (kleinen) Sliderwert holen		if (val != old)			offset = ThumbPosCalc(c,val) - oGetCtlValue(c);	}	return(offset);}