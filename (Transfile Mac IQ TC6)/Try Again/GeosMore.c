#include "GlobalDefines.h"#include "GeosMore.h"#include "GlobalLib.h"#include "Utilities.h"#include "rsrcDefines.h"#include "GlobalStruct.h"#include "DialogLib.h"#include "MySound.h"int			gMausx,gMausy;	// Mauspositionint			mx,my;			// Gerd´s Mauspositionint			button;			// Maustasten-Statusint			checkbutton;	// Maustasten-Status mit “längerem Maus-Down”int			keystate;		// Kbshift-Statusint			keyscan,keyascii; // Scancode & ASCII-Code der aktuellen Tastevoid	SetKeys(REG long key);#if !GERD/*** *	globale Variablen für Gerhard setzen ***/void	SetupGVars(REG EventRecord *event){	gMausx = event->where.h;	gMausy = event->where.v;			// aktuelle (globale) Mausposition	button = 0;							// Button nicht gedrückt	keyascii = 0;						// keine gedrückte ASCII-Taste	{	REG	short	k = 0;						// zusammengesetztes keystate	REG short	i = event->modifiers;		// Shift-Flags	if (i & shiftKey)		k |= 1;			// Shift	if (i & cmdKey)		k |= 4;			// Command (ST:Control)	if (i & optionKey)		k |= 8;			// Option (ST:Alternate)	if (i & alphaLock)		k |= 16;		// Alpha (ST:CapsLock)	if (i & controlKey)		k |= 32;		// Control (ST:n.a.)	keystate = k;	}	switch(event->what) {	case	mouseDown:			button = 1;			// als linke Maustaste nehmen			if (keystate & 4)	// Command (rechte Taste) gedrückt?				button = 2;		// dann nur die rechte Taste			break;	case	keyDown:	case	autoKey:			SetKeys(event->message);			break;	}}#endif/*** *	Tastencodes setzen * *	erkannte Scancodes: *		- ESC *		- Cursortasten *		- Help ***/void	SetKeys(REG long key){REG short	k = ((key & keyCodeMask)>>8)&0x7F;	// Tastencode isolieren	keyascii = key & charCodeMask;	// ASCII-Code setzen	keyscan = 0;					// kein gültiger Scancode	switch(keyascii) {	case chHome:					// Home				keyscan = 0x47;				break;	case chEnter:					// Enter				keyscan = 0x72;				break;	case chEnd:						// End				break;	case chHelp:					// Help				keyscan = 0x62;				break;	case chBackspace:				// Delete (Backspace)				keyscan = 0x0E;				break;	case chPageUp:					// Page Up				keyscan = 0x48;				keystate |= 1;		// Shift-Up				break;	case chPageDown:				// Page Down				keyscan = 0x50;				keystate |= 1;		// Shift-Down				break;	case 0x0D:			// Return				keyscan = 0x1C;				break;	case 0x10:			// F1…F15				if ((k >= 0x60)&&(k <= 0x7a)) {					static char c[] = { 5,6,7,3,8,9,0,11,0,13,0,14,0,10,0,12,0,15,0,0,0,0,4,0,2,0,1 };					if (k == 13) {			// Druck						keyscan = 0x62; keystate |= 8;	// Alternate-Help…					} else {						keyscan = c[k - 0x60] + 0x3A;	// Atari-Scancode						if ((keyscan < 0x3B)||(keyscan > 0x44))							keyscan = 0;				// Scancode zu groß!					}				}				break;	case chClear:		// Clear AND Esc				if (k == 0x35) keyscan = 0x01;	// Esc				if (k == 0x47) keyscan = 0x47; keystate |= 1;	// Shift+Clear/Home				break;	case chLeft:		// Left arrow	case 0x7B:				keyscan = 0x4B;				break;	case chRight:		// Right arrow	case 0x7C:				keyscan = 0x4D;				break;	case chUp:			// Up arrow	case 0x7D:				keyscan = 0x48;				break;	case chDown:		// Down arrow	case 0x7E:				keyscan = 0x50;				break;	case chFwdDelete:	// Forward delete				keyscan = 0x53;				break;	}	if (keystate & 1) {		// Shift?		if(keyscan == 0x4B) keyscan = 0x73;	// Shift-Links		if(keyscan == 0x4D) keyscan = 0x74;	// Shift-Rechts		if((keyscan >= 0x3B)&&(keyscan <= 0x44)) keyscan += 0x54 - 0x3B; // Shift-Funktionstaste	}	keyscan <<= 8;}#if !GERD/*** *	Shift-Status abfragen ***/short		vqkey(void){KeyMap		theKeys;		// 8 Byte TastaturmatrixREG short	kbshift=0;		// kbshift erstmal löschen	GetKeys(theKeys);		// aktuelle Tastaturmatrik holen	if (CheckKey(0x38))		kbshift |= 1;		// linke/rechte Shift-Taste	if (CheckKey(0x37))		kbshift |= 4;		// Control (Command)	if (CheckKey(0x3A))		kbshift |= 8;		// Alternate (Option)	if (CheckKey(0x39))		kbshift |= 16;		// CapsLock	if (CheckKey(0x3B))		kbshift |= 32;		// Control	keystate = kbshift;	return(kbshift);}#endif#if !GERD/*** *	Maus abfragen ***/short		vqmouse(void){Point		mloc;			// x,y-Record (wird als Long übergeben!)EventRecord	ev;	mloc = GetGlobalMouse();	gMausx = mloc.h;		// globale Mausposition	gMausy = mloc.v;	GlobalToLocal(&mloc);	mx = mloc.h;	my = mloc.v;	button = Button();		// Maustastenstatus	vqkey();				// Kbshift()-Status ermitteln	if (button)				// Button gedrückt?		if (keystate & 4)	// Command für die rechte Maustaste?			button = 2;		// dann die rechte Maustaste gedrückt	checkbutton = button;	if (EventAvail(mouseUp,&ev))	// Maustaste losgelassen?		checkbutton = 0;	return(button);}#endif/*** *	Alert darstellen. Parameter wie beim ST ***/pascal Boolean	FProc(DialogPtr theDialog,EventRecord *theEvent,short *itemHit);#define	BUTTON1	1	// die fünf Items im Alert#define	BUTTON2	2#define BUTTON3	3#define	STRING	4#define	ICON	5	// beim ST: 1=!, 2=?, 3=Stopshort		aktDefaultButton;	// aktueller Default-ButtonUCHAR		AlertButtons[3];	// Shortcuts für die 3 Buttonsshort	alert(short defbut,		// Default-Button			  char *str)		// der Alert-String{char			s[256];			// Kopie, da der String verändert wirdREG DialogPtr	d;				// Ptr auf den Dialogshort			itemHit;		// angeklicktes Itemshort			itemType;Handle			item;			// von GetDItem()Rect			box;Handle			icon;			// Handle des Icons im DialogREG short		i,j,k;			// allg. VariablenREG short		lines;			// Anzahl der TextzeilenREG Boolean		flag;			// true, wenn letzter Buttonshort			top,bottom;		// oberste Button-ZeileGrafPtr			oldPort;		// geretteter GrafPortFontInfo		finf;short			fHeight;		// Höhe des Fonts in der DialogboxWORD			saveCursor = gCurrentCursor;	GetPort(&oldPort);			// alten GrafPort retten	vStrcpy(s,str);				// String erstmal kopieren	str	= s;					// Ptr auf die Kopie	PositionDialog('DLOG',ALERT_DLG);	// Dialog zentrieren	d = GetNewDialog(ALERT_DLG,0L,(WindowPtr)-1L);	// Dialog lesen	if(!d) {					// Dialog nicht geladen?		SysBeep(10);			// dann "Beeeep"		return(defbut);			// den Default-Button zurückgeben	}	SetPort(d);					// GrafPort auf den Dialog	GetFontInfo(&finf);	fHeight = finf.ascent + finf.descent + finf.leading;	HideControl(GetCH(d,BUTTON1));	HideControl(GetCH(d,BUTTON2));	HideControl(GetCH(d,BUTTON3));	if (str[1] == '0') {			// kein Icon?		HideDItem(d,ICON);			// Icon verstecken		icon = nil;					// kein Icon		GetDItem(d,STRING,&itemType,&item,&box);		box.left = 13;				// Text nach links		SetDItem(d,STRING,itemType,item,&box);	} else {		switch (str[1]) {		case	'1':			// !				itemType = cautionIcon;				break;		case	'2':			// ?				itemType = noteIcon;				break;		case	'3':			// Stop		default:					itemType = stopIcon;				break;		}		icon = GetIcon(itemType);		CheckResource(icon);		GetDItem(d,ICON,&itemType,&item,&box);		if(!icon)			HideControl((ControlHandle)item);		else {			item = icon;			// Icon einsetzen			itemType = iconItem + itemDisable;			SetDItem(d,ICON,itemType,item,&box);		}	}	i = 4;					// Ptr hinter auf den String	lines = 1;				// Anzahl der Zeilen	while(str[i]!=']') {	// Stringende?		if (str[i]=='|') {	// Zeilentrenner?			str[i] = 13;	// durch ein CR ersetzen			lines++;		// eine Zeile mehr		}		i++;	}	str[i] = 0;				// String beenden	GetDItem(d,STRING,&itemType,&item,&box);	box.bottom = box.top + fHeight*lines;	SetIText(item,(StringPtr)CtoPstr(&str[4]));	SetDItem(d,STRING,itemType,item,&box);#define	BUTTONWIDTH		70		// Breite eines Buttons#define MINHEIGHT		13+32+13 // Minimale Höhe von Text und Abstand	top = box.bottom+13;	// hier fangen die Buttons an	if (top<60) top = 60;	// minimale Buttonposition	if (fHeight<20) fHeight = 20;	// minimale Buttonhöhe	i += 2;					// Ptr auf den ersten Button	j = i;	AlertButtons[0] = -1;	AlertButtons[1] = -1;	AlertButtons[2] = -1;	k = BUTTON1;							// Nummer des ersten Buttons	flag = false;							// es gibt noch Buttons	do {									// Stringende?		if ((str[i]=='|')||(str[i]==']')) {	// Zeilentrenner?			if (str[i]==']') {				flag = true;				// letzter Button			}			str[i] = 0;						// Stringende eines Buttons			GetDItem(d,k,&itemType,&item,&box);			box.top = top;					// vertikale Position			box.bottom = top+fHeight;		// unterer Rand			bottom = box.bottom;			// unteren Rand merken			{ UCHAR	keyCode;				keyCode = str[j];			// Default-Buttonvorgabe				UppercaseText(&keyCode,1,smSystemScript);	// Taste in Großbuchstaben wandeln				AlertButtons[k-BUTTON1] = keyCode;			}			SetCTitle((ControlHandle)item,(StringPtr)CtoPstr(&str[j]));			MoveControl((ControlHandle)item,box.left,top);			SizeControl((ControlHandle)item,BUTTONWIDTH,fHeight);			ShowControl((ControlHandle)item);			SetDItem(d,k++,itemType,item,&box);			j = i+1;						// Ptr auf den nächsten String		}		i++;	} while(flag == false);					// alle Buttons durch?	if (str[i]) {							// Tastaturshortcuts vorhanden?		AlertButtons[0] = str[i+1];		AlertButtons[1] = str[i+2];			// Shortcuts übertragen		AlertButtons[2] = str[i+3];	}	k -= BUTTON1;							// Anzahl der Buttons	for(i=0;i<k;i++) {		GetDItem(d,i+BUTTON1,&itemType,&item,&box);		box.left = d->portRect.right-(13+BUTTONWIDTH)*(k-i);		box.right = box.left+BUTTONWIDTH;		MoveControl((ControlHandle)item,box.left,box.top);		SetDItem(d,i+BUTTON1,itemType,item,&box);	}	if (defbut)		aktDefaultButton = (defbut<=i)?defbut-1+BUTTON1:1;	d->portRect.bottom = bottom+13;	pfeil();								// Mauspfeil an	ShowWindow(d);							// Dialog darstellen	SelectWindow(d);						// Dialog darstellen	ModalDialog((ProcPtr)FProc,&itemHit);	// Dialog ausführen	SetPort(oldPort);						// alten GrafPort zurücksetzen	if (!icon)		ReleaseResource(icon);				// Icon wieder freigeben	DisposDialog(d);						// Dialog entfernen	DoSetCursor(saveCursor);				// alten Cursor zurücksetzen	return(itemHit-BUTTON1+1);}// Dialog-Zusatzsprozedurpascal Boolean	FProc(REG DialogPtr theDialog,EventRecord *theEvent,short *itemHit){REG WORD	defbut = aktDefaultButton;	// Default-Button in ein RegisterUCHAR		key;REG WORD	button = 0;	key = theEvent->message & charCodeMask;	UppercaseText(&key,1,smSystemScript);	// Taste in Großbuchstaben wandeln	switch(theEvent->what) {	case	updateEvt:	if (defbut)		// Default-Button zeichnen							OutlineDialogItem(theDialog,defbut);						break;	case	keyDown:	if (defbut)		// Default-Button vorhanden?							if ((key == 13)||(key == 3)) {	// RETURN, ENTER								button = defbut;								break;							}						if (key == AlertButtons[0]) { button = BUTTON1; break; }						if (key == AlertButtons[1]) { button = BUTTON2; break; }						if (key == AlertButtons[2]) { button = BUTTON3; break; }						break;	}	if (button > 0) {	// Buttons auslösen?		SelectControl(GetCH(theDialog,button));		*itemHit = button;		return(true);	}	return(false);}/*** *	CheckResource *	Testet, ob eine Resource gefunden wurde, sonst => schwerer Fehler ***/short		CheckResource(Handle r)			// Any kind of resource handle{	if(!r)		return(SevereMacError(resNotFound));}/*** *	CheckAllocation *	Testet, ob der Speicher alloziert wurde, sonst => schwerer Fehler ***/short		CheckAllocation(void *p)		// Any kind of pointer{	if(!p)		return(SevereMacError(MemError()));}/*** * ***/void	GetErrorString(REG UCHAR *errMsg,REG OSErr macErr);void	GetErrorString(REG UCHAR *errMsg,REG OSErr macErr){REG WORD		id = 0;		// Resource-ID der Fehlermeldung	if (macErr < 0) {	 	macErr = ABS(macErr);	// damit ich nicht ständig das “-” tippen muß…		if (macErr<=128) id = 500;		if ((macErr>=147)&&(macErr<=156)) { id = 501; macErr -= 146; }		if ((macErr>=192)&&(macErr<=232)) { id = 502; macErr -= 191; }		if ((macErr>=250)&&(macErr<=261)) { id = 511; macErr -= 249; }		if ((macErr>=290)&&(macErr<=360)) { id = 503; macErr -= 289; }		if ((macErr>=1024)&&(macErr<=1029)) { id = 504; macErr -= 1023; }		if ((macErr>=1066)&&(macErr<=1105)) { id = 505; macErr -= 1065; }		if ((macErr>=3101)&&(macErr<=3109)) { id = 506; macErr -= 3100; }		if ((macErr>=4096)&&(macErr<=4101)) { id = 507; macErr -= 4095; }		if ((macErr>=5000)&&(macErr<=5030)) { id = 508; macErr -= 4999; }		if ((macErr>=5500)&&(macErr<=5502)) { id = 509; macErr -= 5499; }		if ((macErr>=8132)&&(macErr<=8160)) { id = 510; macErr -= 8131; }	} else {		if ((macErr>=0xFE)&&(macErr<=0xFF)) { id = 1003; macErr -= 253; }		if ((macErr>=0x41)&&(macErr<=0x4B)) { id = 1003; macErr -= 62; }	}	CopyPString(errMsg,(USTR)"\pUnknown system error.");	if(id)	GetIndString(errMsg,id,macErr);	// Fehler-Message lesen}/*** *	SevereMacError *	Schweren Systemfehler melden. Der User darf auf eigenes Risiko fortfahren ***/short		SevereMacError(REG OSErr macErr){Str255		errMsg;		// Text of error messageStr255		errNum;		// Error number as a stringREG short	id = ALRTsevereErr;	if (macErr != noErr) {					// überhaupt ein Fehler?		GetErrorString(errMsg,macErr);		// Fehlermessage holen		NumToString((long)macErr,errNum);	// Convert error number to a string	*/		ParamText(errMsg,(StringPtr)errNum,(StringPtr)"",(StringPtr)"");		pfeil();							// Mauspfeil einschalten		if (!gJumpBuffer[JUMPBUFFER_A1])	// Jump-Buffer ungültig?			id++;							// dann nur den “Quit”-Button		PositionDialog('ALRT',id);			// Alert zentrieren		OwnBeep(shit);		if (StopAlert(id,nil) == 1) {		// QUIT?			{ G(Exit)(); }			ExitToShell();					// Sicher ist Sicher…		} else {			HiliteMenu(0);					// Menutitel normal darstellen			JumpToEventLoop();				// zurück zur Event-Schleife		}	}	return(macErr);							// Fehler zurückgeben}/*** *	Recover von einem SystemError() ***/void	SysErrRecover(void){	pfeil();						// Mauspfeil einschalten	HiliteMenu(0);					// Menutitel normal darstellen	JumpToEventLoop();				// zurück zur Event-Schleife}/*** *	Test, ob noch n Bytes vorhanden sind ***/Boolean		CheckMem(REG LONG bytes){	if(MaxBlock() < bytes) {			// Speicher vorhanden?		if(CompactMem(bytes) < bytes) {	// erstmal packen (OHNE Purge!)			PurgeMem(bytes);			// wenn's nicht reichte: purgen			if(CompactMem(bytes) < bytes) {	// reicht es jetzt?				return(false);			// Fehler, wenn nicht			}		}	}	return(true);}/*** *	CheckOSError *	irgendein Fehler aufgetreten? true, wenn nicht. Sonst wird ein Alert *	dargestellt und false zurückgegeben ***/Boolean	CheckOSError(REG OSErr macErr){Str255			errMsg;		// Text of error messageStr255			errNum;		// Error number as a string	if(macErr == portInUse) {		OwnBeep(negative);		DoDialog(175,0);		return(false);	}	if((macErr == noErr)||(macErr == userCanceledErr)||(macErr == iPrAbort))			return(true);					// kein Fehler!	NumToString((long)macErr,errNum);		// Fehlernummer in einen String	GetErrorString(errMsg,macErr);			// Fehlermessage holen	ParamText(errMsg,(StringPtr)errNum,(StringPtr)"",(StringPtr)"");	PositionDialog('ALRT',ALRTosError);	pfeil();	OwnBeep(negative);	StopAlert(ALRTosError,nil);	return(false);							// Fehler ist aufgetreten}/*** *	Longjump zur Eventschleife, z.B. nach einem Fehler ***/void	Exit(void);void	JumpToEventLoop(void){	if (gJumpBuffer[JUMPBUFFER_A1])	// Jump-Buffer gültig?		f_LongJump(gJumpBuffer,1);	// Ja => zurück zum Event-Loop	else		Exit();						// Nein => Programmende}