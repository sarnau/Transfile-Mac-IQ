/*** *	einige kleiner Routinen ***/#include "GlobalDefines.h"#include "Utilities.h"/*** *	Handle sperren, aber vorher ans Heap-Ende verschieben ***/char	HLockH(REG Handle theHandle){REG UCHAR	hstate;	hstate = HGetState(theHandle);	// aktuellen Status der Handle holen	if (!BTstQ(hstate,7))			// Block noch nicht gelockt?		HLockHi(theHandle);			// dann nach oben schieben und locken	return(hstate);					// Status der Handle zurŸckgeben}/*** *	zwei Pascal-Strings verketten ***/#if 0void	ConcatPString(REG Str255 d,REG Str255 s){REG short		l;	if ((d[0]+s[0])>255)			// maximale StringlŠnge!		l = 255-d[0];				// nur bis maximal 255 Zeichen auffŸllen	else		l = s[0];					// gesamten String anhŠngen	if (l > 0) {					// Ÿberhaupt was zu kopieren?		BlockMove(s+1,d+d[0]+1,l);	// String dranhŠngen		d[0] += l;					// StringlŠnge hochsetzen	}}#elsevoid	ConcatPString(Str255 d,Str255 s){	Strpcat(d,s);}#endif/*** *	Pascal-String auf einen anderen kopieren ***/#if 0void	CopyPString(REG Str255 d,REG Str255 s){	BlockMove(s,d,1+(long)s[0]);}#elsevoid	CopyPString(Str255 d,Str255 s){	Strpcpy(d,s);}#endif/*** *	zwei Pascal-Strings auf Gleichheit testen ***/#if 0Boolean	ComparePString(REG Str255 s1,REG Str255 s2){REG	short		i;	if (s1[0] == s2[0]) {			// ist die LŠnge gleich?		i = s1[0];					// LŠnge der Strings		while(i) {			if (s1[i] != s2[i])				return(false);		// String sind ungleich			--i;		}		return(true);				// String sind gleich	} else		return(false);				// ungleiche LŠnge => ungleiche Strings}#elseBoolean	ComparePString(REG Str255 s1,REG Str255 s2){	return(Strpcmp(s1,s2));}#endif/*** *	Byte in ASCII-Hexzeichen wandeln ***/char	hex(REG UWORD i){	i &= 0xF;	i += '0';	if (i>'9') i+= 'A'-'9'-1;	return((char)i);}short		GetHexByte(REG STR cptr){REG	UCHAR	val,chr;REG UWORD	i;	for (val=0,i=0;i<2;i++) {		chr = cptr[i];		if (chr == '=') return(cptr[++i]);		if (chr>'F') chr -= 0x20;		if (chr>'9') chr -= ('A'-'9'-1);		val = (val<<4)+chr-'0';	}	return(val & 0xFF);}#if GERD/*** *	Mausposition setzen ***/void	usetmouse(short x,short y) {}/*** *	Der Mac ist stŠndig im SupervisormodeÉ ***/void	resetsuper(void) {}void	uonsuper(void) {}void	uoffsuper(void) {}#endif/*** *	f_SetJump * *	Save the current stack environment and return zero. ***/JumpBuffer		gJumpBuffer;	// LongJump to Event-Loopvoid	LongJumpSub(void);void	LongJumpSub(void){	asm {extern	f_SetJump:		moveq	#0,d0					// Set return value of zero		movea.l	(sp)+,a1				// Save return address		movea.l	(sp),a0					// Get pointer to buffer		movem.l	d3-d7/a1-a4/a6-a7,(a0)	// Save registers in buffer		jmp		(a1)					// Resume at return addressextern	f_LongJump:		addq.l	#4,sp					// Discard return address		movea.l	(sp)+,a0				// Get pointer to buffer		move.w	(sp),d0					// Get return value			bne.s	@1						// If return value is zeroÉ		moveq	#1,d0					// Make it a one@1		movem.l	(a0),d3-d7/a1-a4/a6-a7	// Restore registers from buffer		jmp		(a1)					// Resume at f_SetJump return addr	}}