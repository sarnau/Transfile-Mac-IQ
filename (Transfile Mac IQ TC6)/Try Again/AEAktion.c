#include "AEAktion.h"#include <AppleEvents.h>#include "GlobalLib.h"#include "GeosMore.h"#include "DoEvent.h"#include "rsrcDefines.h"#include "MenuCmd.h"#include "DialogLib.h"#include "Print.h"#include "File.h"#include "GlobalStruct.h"#if !GERD#include "Sharp.h"#endif/*** *	Liste der eigenen AppleEvents ***/pascal OSErr	DoAEOpenApplication(AppleEvent *message,AppleEvent *reply,LONG refcon);pascal OSErr	DoAEOpenDocuments(AppleEvent *message,AppleEvent *reply,LONG refcon);pascal OSErr	DoAEPrintDocuments(AppleEvent *message,AppleEvent *reply,LONG refcon);pascal OSErr	DoAEQuitApplication(AppleEvent *message,AppleEvent *reply,LONG refcon);OSErr			OpenDocEventHandler(AppleEvent *message,AppleEvent *reply,WORD mode);static AEEventStruct aeMain[] = {	{ kCoreEventClass, kAEOpenApplication, (ProcPtr)DoAEOpenApplication },	{ kCoreEventClass, kAEOpenDocuments, (ProcPtr)DoAEOpenDocuments },	{ kCoreEventClass, kAEPrintDocuments, (ProcPtr)DoAEPrintDocuments },	{ kCoreEventClass, kAEQuitApplication, (ProcPtr)DoAEQuitApplication }};#define kTimeOutInTicks (60 * 30)	// 30 Sekunden Timeout/*** *	AppleEvents anmelden ***/VOID	InitAppleEvents(VOID){REG WORD	i;REG OSErr	err;	if (!gHasAppleEvents) return;	// Apple Events vorhanden? Nein => raus	for(i=0;i<(sizeof(aeMain)/sizeof(AEEventStruct));i++) {		err = AEInstallEventHandler(aeMain[i].theEventClass,// Klasse							  aeMain[i].theEventID,		// Schlüsselwort							  aeMain[i].theHandler,		// Event-Handler							  0L,						// kein RefCon							  false);					// nur unser Programm		if (!CheckOSError(err)) break;	}}/*** *	Sind irgendwelche unnötigen Parameter vorhanden? ***/Boolean	MissedAnyParameters(AppleEvent *message);Boolean	MissedAnyParameters(AppleEvent *message){REG OSErr	err;DescType	ignoredActualType;AEKeyword	missedKeyword;Size		ignoredActualSize;EventRecord	event;	err = AEGetAttributePtr(message,keyMissedKeywordAttr,typeKeyword,&ignoredActualType,							(Ptr)&missedKeyword,sizeof(missedKeyword),&ignoredActualSize);	if (err == noErr) {		event.message = *(LONG*)&ignoredActualType;		event.where = *(Point*)&missedKeyword;		err = errAEEventNotHandled;	}	return(err != errAEDescNotFound);}/*** *	MyIdleProc für AppleEvent * *	Diese Routine wertet Update-Events, Activate-Events und Null-Events aus. *	Beim ersten Aufruf, wird ein Null-Event empfangen. Hier kann man den Sleep- *	Wert und eine Maus-Region setzen (für WaitNextEvent()) ***/pascal Boolean	MyIdleProc(REG EventRecord *event,LONG *sleep,RgnHandle *mouseRgn);pascal Boolean	MyIdleProc(REG EventRecord *event,LONG *sleep,RgnHandle *mouseRgn){	switch (event->what) {		case updateEvt:		case activateEvt:		case kOSEvent:			gTheEvent = *event;			SetupGVars(&gTheEvent);		// globale Variablen für Gerhard setzen			/* These events are passed by the AppleEvent manager to avoid			   dropping while waiting for a reply or notification.  Every			   procedure should handle these events in their idle procedure.			   In this code, we simply dispatch these events back to the			   main event loop handling code. */			DoEvent();			break;		case nullEvent:			/* The idle procedure is called once with the null event before			   the loop begins.  This allows the application to alter sleep			   time and mouseRgn to meet its own needs.  Since we're doing			   nothing, set the cursor to a watch. */			*sleep = 60;		/* This is just like the WaitNextEvent								   sleeptime, so use the correct value for								   your application.  It's better to use a								   non-zero value here rather than zero,								   as using zero really slows you down. */			DoIdleTasks();			// sonst nur Idle…			break;	}	return(false);}/*** *	Applikation wird gestartet, d.h. neues leere Dokument erzeugen ***/pascal OSErr	DoAEOpenApplication(AppleEvent *message,AppleEvent *reply,LONG refcon){OSErr			err;			// evtl. OS-FehlercodesFSSpec			fileSpec;		// Dateiparameter für “Open…”DocHandle		d;				// Handle auf das aktuelle Dokumentstatic Boolean	firstcall = false;	// bereits einmal aufgerufen worden?	if (firstcall) return;		// weitere Aufrufe ignorieren! =>	if(gDocList) return;		// es sind bereits Dokumente offen =>	CopyPString(fileSpec.name,(USTR)"\pAutoload");	fileSpec.vRefNum = 0; fileSpec.parID = 0;	err = AppOpenDocument(&d,&fileSpec,fsRdWrPerm);	// neues Dokument anlegen	if (!err)		err = AppInitDocument(d,iOpen,err);	if (err) {		KeyMap		theKeys;	// 8 Byte Tastaturmatrix				GetKeys(theKeys);		// aktuelle Tastaturmatrik holen		if (CheckKey(0x3A))		// Option gedrückt?			MOpen();		else			MNew();				// kein Dokument übergeben => leeres Dokument	}	AEPutParamPtr(reply,keyErrorNumber,typeShortInteger,(Ptr)&err,sizeof(WORD));	firstcall = true;			// gegen weitere Aufrufe sperren!!!	return(err);}/*** *	Übergebene Dokumente öffnen ***/pascal OSErr	DoAEOpenDocuments(AppleEvent *message,AppleEvent *reply,LONG refcon){OSErr	err;	err = OpenDocEventHandler(message,reply,0);	AEPutParamPtr(reply,keyErrorNumber,typeShortInteger,(Ptr)&err,sizeof(WORD));	return(err);}/*** *	Übergebene Dokumente drucken ***/pascal OSErr	DoAEPrintDocuments(AppleEvent *message,AppleEvent *reply,LONG refcon){OSErr		err;REG WORD	openMode;	openMode = 1;	if (!AEInteractWithUser(kTimeOutInTicks,nil,MyIdleProc))		openMode++;	err = OpenDocEventHandler(message,reply,openMode);	AEPutParamPtr(reply,keyErrorNumber,typeShortInteger,(Ptr)&err,sizeof(WORD));	return(err);}/*** *	Quit-Event, Programm beenden ***/pascal OSErr	DoAEQuitApplication(AppleEvent *message,AppleEvent *reply,LONG refcon){OSErr	err;	MQuit();							// Programm beenden	err = (gQuitApplication)? noErr : userCanceledErr;	AEPutParamPtr(reply,keyErrorNumber,typeShortInteger,(Ptr)&err,sizeof(WORD));	return(err);}/*** *	OpenDocEventHandler * *	gemeinsame Routine für Dokument drucken und Dokument öffnen * *	mode = 0 : normal öffnen *	mode = 1 : zum Drucken öffnen *		 = 2 ***/OSErr	OpenDocEventHandler(AppleEvent *message,AppleEvent *reply,REG WORD mode){REG OSErr		err;REG OSErr		err2;AEDesc			theDesc;FSSpec			theFSS;REG WORD		loop,j;LONG			numFilesToOpen;AEKeyword		iKeyWord;DescType		iType;Size			iSize;FInfo			f;				// Creator und Type-Info	theDesc.dataHandle = nil;		// Für System ≤ 7.0b3	if (err = AEGetParamDesc(message,keyDirectObject,typeAEList,&theDesc))		return(err);	if (!MissedAnyParameters(message)) {	// Parameter ok?		err = AECountItems(&theDesc,&numFilesToOpen);	// Anzahl der Dateien		if (!err) {			for(loop=1;((loop<=numFilesToOpen) && (!err)); loop++) {				err = AEGetNthPtr(&theDesc,loop,typeFSS,&iKeyWord,&iType,(Ptr)&theFSS,									sizeof(theFSS),&iSize);		// Dateiparameter holen				if (err) break;				// ein Fehler?				err = FGetFInfo(&theFSS,&f);				if (err) break;				// ein Fehler?				for(j=0;j < gG.AutoLoadCount;j++) {	// Dateityp suchen					if (f.fdType == gG.AutoLoad[j].Filetype) {	// gefunden?						err = (gG.AutoLoad[j].DoLoad)(&theFSS,loop,mode);						break;					}				}				if (err) break;				// ein Fehler?				if (j >= gG.AutoLoadCount)	// Dateityp nicht gefunden?					DoDialog(DLOGillFType,1);			}		}	}	err2 = AEDisposeDesc(&theDesc);	return(err ? err : err2);}