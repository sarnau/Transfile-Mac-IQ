/*** *	eine globale Sammlung von neuen Routinen * *	©1991 ·-Soft, Markus Fritze ***/#include "GlobalLib.h"#include "GlobalDefines.h"#include "Utilities.h"#include "rsrcDefines.h"#include "GeosMore.h"#include "Windows.h"#include "DialogLib.h"#include "GlobalStruct.h"#include <Traps.h>#include <GestaltEqu.h>#include <Script.h>#if !GERD#include <CommResources.h>#include <CTBUtilities.h>#endifRgnHandle	gUtilRgn;				// Dummy-RegionRect		gDesktopRect;			// Rechteck des DesktopsRect		gScreenRect;			// Rechteck des aktuellen Hauptbildschirms (MenŸleiste)short		gMachineType;			// welcher Rechnershort		gSystemVersion;			// Versionsnummer vom Systemshort		gQDVersion;				// Haupt-Quickdraw-Version:									//	0: originales QD									//	1: Color QD									//	2: 32-bit QDBoolean		gStandardFileFlag;		// StandardFile-Aufrufe vorhanden?Boolean		gFSSpecFlag;			// File Manager Routinen von System 7Boolean		gHasAppleEvents;		// AppleEvents vorhandenBoolean		gHasWaitNextEvent;		// true, wenn WaitNextEvent() vorhandenBoolean		gHasAlias;				// true, wenn Alias vorhandenBoolean		gHasFindFolder;			// true, wenn FindFolder vorhandenBoolean		gHasHelpMgr;			// true, wenn Help Manager vorhandenBoolean		gCTB;					// true, wenn Communication Toolbox vorhandenBoolean		gVirtMem;				// true, wenn virtueller Speicher vorhanden istshort		gScriptMgrVersion;		// Versionsnummer des aktiven Script-Managersshort		gAppResRef;				// refNum der eigenen Resource-DateiBoolean		gAppTrue;				// true, wenn ECHTE Stand-Alone-ApplikationBoolean		gInBackground = false;	// true, wenn Applikation im HintergrundStr255		gAppName;				// Name der ApplikationOSType		gSignature;				// Signatur der ApplikationWORD		gCurrentCursor;			// aktueller CursoracurHandle	gCurrentCursorH;		// aktuelle acur-HandleWORD		gCurrentCursorIndex;	// Index auf die acur-HandleLONG		gCurrentCursorTime;		// acur-Timershort		gTEMaxLen;				// maximale LŠnge fŸr den TextEdit-Filter/*** *	Trap-Abfragefunktionen ***/short		NumToolboxTraps(void){	return((NGetTrapAddress(_InitGraf,ToolTrap) == NGetTrapAddress(0xAA6E,ToolTrap))?			0x200:0x400);}TrapType	GetTrapType(short theTrap){	return((theTrap & 0x800)?ToolTrap:OSTrap);}Boolean		TrapAvailable(REG short theTrap){REG TrapType	fType;	fType = GetTrapType(theTrap);	if (fType == ToolTrap) {		theTrap &= 0x7FF;		if (theTrap >= NumToolboxTraps())	// Trap-Nummer zu gro§?			return(false);					// dann Fehler!	}	return(NGetTrapAddress(theTrap,fType) != NGetTrapAddress(_Unimplemented,ToolTrap));}/*** *	GetGestaltResult() ermittelt den RŸckgabewert der Gestalt Funktion. Falls ein *	Fehler auftritt, so wird 0 zurŸckgegeben. Somit ist diese Funktion nur dann *	brauchbar, wenn kein Fehler auftreten kann (Gegenbeispiel: AUX-Version erfragen) ***/long	GetGestaltResult(OSType gestaltSelector){long	gestaltResult;		if (Gestalt(gestaltSelector,&gestaltResult) == noErr)		return(gestaltResult);	else		return(0);}/*** *	Resource aus der eigenen Datei lesen ***/Handle	GetAppIndResource(ResType theType,short index,OSErr *err){REG short	savedResFile;REG Handle	returnHandle;		savedResFile = CurResFile();	UseResFile(gAppResRef);	returnHandle = Get1IndResource(theType,index);	UseResFile(savedResFile);	return(returnHandle);}/*** *	Resource aus der eigenen Datei lesen ***/Handle	GetAppResource(ResType theType,short index,OSErr *err){REG short	savedResFile;REG Handle	returnHandle;		savedResFile = CurResFile();	UseResFile(gAppResRef);	returnHandle = Get1Resource(theType,index);	*err = ResError();	UseResFile(savedResFile);	return(returnHandle);}/*** *	Neuen Cursor setzen ***/#define	Arrow		0VOID		DoSetCursor(REG WORD id){OSErr			err;REG acurHandle	h = (acurHandle)GetAppResource('acur',id,&err);	if ((err)||(!h)) {			// 'acur' nicht gefunden?#if 0		if (gCurrentCursorH) {			ReleaseResource(gCurrentCursorH);			gCurrentCursorH = nil;		}#endif		FetchCursor(id);		return;	}	HLock((Handle)h);	gCurrentCursorTime = TickCount() + 20;	gCurrentCursorIndex = 0;	gCurrentCursorH = h;	FetchCursor(HIWord((*h)->data[0]));	// ersten Cursor setzen}VOID		NextCursor(VOID);VOID		NextCursor(VOID){REG acurHandle	h = gCurrentCursorH;REG WORD		id;	return;	if (!h) return;					// keine acur-Resource	if (TickCount() < gCurrentCursorTime) return;	// Zeit noch nicht abgelaufen? raus	gCurrentCursorTime = TickCount() + 20;	id = gCurrentCursorIndex;	id++;	if (id > (*h)->count) id = 0;	FetchCursor(HIWord((*h)->data[id]));	// nŠchsten Cursor setzen	gCurrentCursorIndex = id;}VOID		FetchCursor(REG WORD id){REG CursHandle		swCur = nil;REG CCrsrHandle		colCur = nil;	gCurrentCursor = id;	if (gQDVersion)		colCur = GetCCursor(id);	if (colCur) {		SetCCursor(colCur);		DisposCCursor(colCur);	} else {		if (id != Arrow)			swCur = GetCursor(id);		if (swCur)			SetCursor(*swCur);		else			InitCursor();	}}/*** *	verschiendene Cursorformen setzen ***/void	pfeil(void)		{ DoSetCursor(Arrow); }void	hand(void)		{ DoSetCursor(200); }void	fourpfeil(void)	{ DoSetCursor(201); }void	finger(void)	{ DoSetCursor(203); }void	fkreuz(void)	{ DoSetCursor(crossCursor); }void	biene(void)		{ DoSetCursor(6500/*watchCursor*/); }void	textmaus(void)	{ DoSetCursor(iBeamCursor); }void	floppy(void)	{ DoSetCursor(202); }/*** *	Mausposition abfragen. Vorteil von OSEventAvail() : die Koordinaten sind bereits *	global! Bei GetMouse() mŸ§ten sie erst umgerechnet werden. ***/Point	GetGlobalMouse(void){#if 0Point	mloc;	GetMouse(&mloc);	LocalToGlobal(&mloc);#elseEventRecord	event;	OSEventAvail(kNoEvents,&event);		// keine Events abholen	return(event.where);				// Maus-Position aus dem Event-Record holen#endif}/*** *	Globales Rechteck in lokale Koordinaten umrechnen ***/void	GlobalToLocalRect(REG Rect *aRect){	GlobalToLocal(&TopLeft(*aRect));	GlobalToLocal(&BotRight(*aRect));}/*** *	Lokales Rechteck in globale Koordinaten umrechnen ***/void	LocalToGlobalRect(REG Rect *aRect){	LocalToGlobal(&TopLeft(*aRect));	LocalToGlobal(&BotRight(*aRect));}/*** *	Taste ummappen, auf das der oberste Tastencode entsteht * *	Parameter: 2 Byte.	Oberes Byte:	virtual Keycode (Scancode) *						unteres Byte:	ASCII-Code der Taste * *	RŸckgabe: ASCII-Code der Taste, wenn Option/Shift/etc. _nicht_ gedrŸckt wŠre ***/UCHAR		MapKey(REG UWORD keyInfo){		#define kMaskVirtualKey	0x0000FF00	//	get virtual key from event message for KeyTrans#define kShiftWord		8			//	we shift the virtual key to mask it into the keyCode for KeyTrans#define kMaskASCII2		0x000000FF	//	get the key out of the ASCII2 byteLONG		state;Handle 		hKCHR;	hKCHR  = GetResource('KCHR',GetScript(GetEnvirons(smKeyScript),smScriptKeys));	if(hKCHR) {		state = 0;		keyInfo = KeyTrans(*hKCHR,(keyInfo & kMaskVirtualKey) >> kShiftWord,&state);		ReleaseResource(hKCHR);	}	return(keyInfo);}/*** *	Testet auf Abbruch mit Command-. (unabhŠngig von der Tastatur!) ***/Boolean UserAbort(VOID){		#define kMaskModifiers	0xFE00		// 	we need the modifiers without the command key for KeyTrans#define kMaskVirtualKey	0x0000FF00	//	get virtual key from event message for KeyTrans#define kUpKeyMask		0x0080#define kShiftWord		8			//	we shift the virtual key to mask it into the keyCode for KeyTrans#define kMaskASCII1		0x00FF0000	//	get the key out of the ASCII1 byte#define kMaskASCII2		0x000000FF	//	get the key out of the ASCII2 byte#define kPeriod			'.'			//	ascii for a periodshort			keyCode;long			virtualKey,				keyInfo,				lowChar,				highChar,				state,				keyCId;Handle 			hKCHR;EventRecord		CancelEvent;	// is there an event	if (!GetNextEvent(keyDown + autoKey,&CancelEvent))		return(false);			// no user cancel		//	see if the command key is down.  If it is, find out the ASCII  		//	equivalent for the accompanying key.#if 0	if (CancelEvent.what = updateEvt) {		if ((DialogPtr)CancelEvent.message == topWind)			DrawDialog(topWind);		else			WUpdate((WindPtr)CancelEvent.message);		return(false);	}#endif	if (CancelEvent.modifiers & cmdKey ) {		virtualKey	= (CancelEvent.message & kMaskVirtualKey) >> kShiftWord;		// And out the command key and Or in the virtualKey		keyCode		= (CancelEvent.modifiers & kMaskModifiers)|virtualKey;		state		= 0;		keyCId = GetScript(GetEnvirons(smKeyScript),smScriptKeys);		hKCHR  = GetResource('KCHR',keyCId);		if (hKCHR != nil) {			// Don't bother locking since KeyTrans will never move memory			keyInfo = KeyTrans(*hKCHR,keyCode,&state);			ReleaseResource(hKCHR);		} else			keyInfo = CancelEvent.message;		lowChar =  keyInfo & kMaskASCII2;		highChar = (keyInfo & kMaskASCII1)>>16;		if (lowChar == kPeriod || highChar == kPeriod)			return(true);	}	return(false);}/*** *	Diese Funktion tut GAR NICHTS ***/OSErr		Return(...){	return(noErr);}/*** *	??? ***/void	PullApplicationToFront(void);void	PullApplicationToFront(void){#define kBroughtToFront 3EventRecord event;REG	short	count;	for (count=1;count<=kBroughtToFront;count++)		EventAvail(everyEvent,&event);}/*** *	Kleinkram initialisieren ***/void	InitUtilities(void);void	InitUtilities(void){Handle		apParam;Handle		bndlResource,h;OSErr		err;short		count;	// Gestalt Variablen initialisieren	gMachineType = GetGestaltResult(gestaltMachineType);	gSystemVersion = GetGestaltResult(gestaltSystemVersion);	gQDVersion = (GetGestaltResult(gestaltQuickdrawVersion) >> 8) & 0xFF;	gStandardFileFlag = BTstQ(GetGestaltResult(gestaltStandardFileAttr),gestaltStandardFile58);	gFSSpecFlag = BTstQ(GetGestaltResult(gestaltFSAttr),gestaltHasFSSpecCalls);	gHasAppleEvents = GetGestaltResult(gestaltAppleEventsAttr);	gHasAlias = GetGestaltResult(gestaltAliasMgrAttr);	gHasFindFolder = BTstBool(GetGestaltResult(gestaltFindFolderAttr),gestaltFindFolderPresent);	gScriptMgrVersion = GetGestaltResult(gestaltScriptMgrVersion);	gHasHelpMgr = BTstBool(GetGestaltResult(gestaltHelpMgrAttr),gestaltHelpMgrPresent);	gCTB = BTstBool(GetGestaltResult(gestaltCRMAttr),gestaltCRMPresent);	gVirtMem = BTstQ(GetGestaltResult(gestaltVMAttr),gestaltVMPresent);	gHasWaitNextEvent = TrapAvailable(_WaitNextEvent);	// Programmnamen und gAppResRef ermitteln	GetAppParms(gAppName,&gAppResRef,&apParam);	gAppResRef = CurResFile();			// refNum der Resource-Datei (wegen Think C!)	count = Count1Resources('CODE');	// Anzahl der CODE-Resourcen zŠhlen	err = ResError();	gAppTrue = true;					// Default: echte Applikation	if ((!err)&&(!count))		gAppTrue = false;				// keine Code-Resource => Start aus THINK C heraus	// Signatur ermitteln	bndlResource = GetAppResource('BNDL',128,&err);	gSignature = (bndlResource)?		*(OSType*)(*bndlResource):		'SIGM';	ReleaseResource(bndlResource);#if !GERD	if (gCTB) {							// CTB vorhanden?		InitCRM();		InitCTBUtilities();	}#endif}/*** *	Toolboxen initialisieren ***/void	InitToolbox(void);void	InitToolbox(void){	InitGraf(&thePort);			// QuickDraw init	InitFonts();				// Font Manager init	InitWindows();				// Window Manager init	InitMenus();				// Menu Manager init	TEInit();					// Text Edit init	InitDialogs(nil);			// Dialog Manager Init	InitCursor();				// Cursor auf Pfeil schalten}/*** *	SetMinimumStack * *	Setzt die Stackgrš§e auf minSize. Nur EINMAL aufrufen und die als ALLERERSTEN *	Befehl im Programm! ***/void	SetMinimumStack(long minSize){register long	defaultStack = LMGetDefltStack();	if (minSize > defaultStack)		SetApplLimit(GetApplLimit() - (minSize - defaultStack));}////	Rechnerkonfiguration ungenŸgend => Programm verlassen//void	AbortPrgDialog(short id);void	AbortPrgDialog(short id){	DoDialog(id,-1);	{ G(Exit)(); }	ExitToShell();					// Sicher ist SicherÉ}/*** *	Speichermangel-Funktion ***/#if 0Handle	GrowZoneMem;pascal LONG MyGrowZone(Size needed);pascal LONG MyGrowZone(Size needed){	if (GrowZoneMem) {		DisposHandle(GrowZoneMem);		GrowZoneMem = nil;	}}#endif/*** *	allgemeines Init ***/void	InitAll(void){#define NULLVAL		0x50FF8001//#define NULLVAL		'NIL!'#if __option(long_macsbug_names)	*(long*)0=NULLVAL;					// Busfehler bei Nullhandle#else#if __option(macsbug_names)	*(long*)0=NULLVAL;					// Busfehler bei Nullhandle#endif#endif	MaxApplZone();	MoreMasters();MoreMasters();MoreMasters();	// Platz fŸr ein paar Master-Pointer mehr	InitToolbox();							// Toolbox anmelden	PullApplicationToFront();	InitUtilities();						// Kleinkram initialisieren	// Funktion bei Speichermangel#if 0	GrowZoneMem = NewHandle(30000L);		// 30KB Buffer brauchen wir	if (GrowZoneMem)		SetGrowZone(MyGrowZone);#endif	// 	Software: min. System 6.0.4	if (gSystemVersion < 0x604)		AbortPrgDialog(10400);				// Software zu altÉ	// 	reicht der Speicher?	if ((long)GetApplLimit() - (long)ApplicZone() < kMinHeap)		AbortPrgDialog(10403);				// Speicher reicht nicht	{	long	total,contig;	PurgeSpace(&total,&contig);	if (total < kMinSpace)		AbortPrgDialog(10403);				// Speicher reicht nicht	}	randSeed = TickCount();					// Zufallsbasis setzen	pfeil();								// Pfeil einschalten	gUtilRgn = NewRgn();					// eine Leer-Region	gDesktopRect = (**GetGrayRgn()).rgnBBox; // Rechteck des Desktops	gScreenRect = screenBits.bounds;		// Rechteck vom Screen	gScreenRect.top = GetMBarHeight()+1;	// MenŸleiste schlie§t den Bildschirm oben ab}