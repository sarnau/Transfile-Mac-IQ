/*** *	MDEF-Resource für Tear-Off-Menüs ***/#define REG		registertypedef	struct TearOffGlobals {	void		(*drawMenuProc)();	int			(*findItemProc)();	void		(*hiliteItemProc)();	SysEnvRec	*env;	WindowPtr	w;	Point		pos;	int			curItem;	Boolean		itemHilited;} TearOffGlobals,*TearOffPtr,**TearOffHdl;#define	TearOffRsrc		'TOMG'	/* Resource für den Datenaustausch */#define TearOffMargin	15#define	MovePaletteItem	-1/*** Parameter für das Float ***/#define	FloatTitleHeight	10#define	FloatShadow			3#define	FloatOffset			5void	ChooseItem(REG TearOffPtr wP,Rect *r,Point hit,int *which);void	DragMenu(REG TearOffPtr wP,Point hit,int *which,RgnHandle menuRgn,RgnHandle saveRgn);pascal void		main(REG int message,REG MenuHandle m,REG Rect *r,Point hit,int *which){REG TearOffHdl	wH;REG TearOffPtr	wP;	SetUpA5();			/* A5 richtig setzen */	wH = (TearOffHdl)GetResource(TearOffRsrc,(*m)->menuID);	if ((ResErr == noErr) && (!wH)) {		HLock((Handle)wH);		wP = *wH;		/* Kein switch, das spart ne Menge Code! */		if(message == mDrawMsg) {			CallPascal(r,wP->drawMenuProc);			CallPascal(r,wP->curItem,TRUE,wP->hiliteItemProc);			wP->itemHilited = TRUE;		} else if(message == mChooseMsg) {			ChooseItem(wP,r,hit,which);		} else if(message == mSizeMsg) {			(*m)->menuWidth = (wP->w)->portRect.right-(wP->w)->portRect.left;			(*m)->menuHeight = (wP->w)->portRect.bottom-(wP->w)->portRect.top;		}		HUnlock((Handle)wH);	}	RestoreA5();		/* A5 zurücksetzen */}/*** *	Item, d.h. Menüpunkt auswählen ***/void	ChooseItem(REG TearOffPtr wP,Rect *r,Point hit,REG int *which){REG int			saveItem;REG int			hiliteItem;Point			mousePt;Rect			marginRect;REG RgnHandle	menuRgn;REG RgnHandle	tempRgn;	saveItem = *which;	hiliteItem = *which = 0;	if((!hit.h)&&(!hit.v)) {	/* kein Point? D.h. MenuManager läßt Item blinken */		if(PtInRect(hit,r)) {	/* Punkt in der Menüleiste? */			mousePt.v = hit.v - r->left;			mousePt.h = hit.h - r->right;			hiliteItem = *which = CallPascalW(mousePt,wP->findItemProc);			if(wP->itemHilited) {				saveItem = wP->curItem;				wP->itemHilited = FALSE;			}		} else {			if (!wP->itemHilited) {				hiliteItem = wP->curItem;				wP->itemHilited = TRUE;			}		}	}	if (saveItem != hiliteItem) {		CallPascal(r,saveItem,FALSE,wP->hiliteItemProc);		CallPascal(r,hiliteItem,TRUE,wP->hiliteItemProc);	}	marginRect = *r;	marginRect.top -= TearOffMargin;	marginRect.bottom += TearOffMargin;	marginRect.right += TearOffMargin;	RectRgn(menuRgn = NewRgn(),&marginRect);	RectRgn(tempRgn = NewRgn(),&screenBits.bounds);	(*tempRgn)->rgnBBox.bottom = GetMBarHeight();	UnionRgn(menuRgn,tempRgn,menuRgn);	if(!PtInRgn(hit,menuRgn))		DragMenu(wP,hit,which,menuRgn,tempRgn);	DisposeRgn(tempRgn);	DisposeRgn(menuRgn);}/*** *	Palette auf dem Desktop positionieren ***/void		DragMenu(REG TearOffPtr wP,Point hit,int *which,						REG RgnHandle menuRgn,REG RgnHandle saveRgn){PenState		savePen;	/* gerettete Pen-Parameter */long			ticks;		/* Dummy für Delay */Rect			windowRect;REG RgnHandle	strucRgn;	/* Region des Windows */REG int			hOffset;Point			oldMouse;Point			newMouse;REG RgnHandle	dragRgn;	/* Region beim Draggen */	GetPenState(&savePen);	PenSize(1,1); PenMode(notPatXor); PenPat(gray);	windowRect = (wP->w)->portRect;			/* Windowrahmen berechnen */	OffsetRect(&windowRect,-windowRect.left,-windowRect.top);	windowRect.right += 3;	windowRect.bottom += FloatTitleHeight + 3;	RectRgn(strucRgn = NewRgn(),&windowRect);	hOffset = windowRect.right/2;	windowRect.top += FloatShadow;			/* Schatten berechnen */	windowRect.left += FloatShadow;	windowRect.bottom += 1;	windowRect.right += 1;	RectRgn(saveRgn,&windowRect);	UnionRgn(strucRgn,saveRgn,strucRgn);	/* GesamtRegion des Windows */	SetClip(saveRgn);	SetClip(GetGrayRgn());					/* Clipping richtig setzen */	oldMouse = newMouse = hit;	CopyRgn(strucRgn,dragRgn = NewRgn());	OffsetRgn(dragRgn,newMouse.h-hOffset,newMouse.v-FloatOffset);	FrameRgn(dragRgn);						/* Outline zeichnen */	do {		if(!EqualPt(newMouse,oldMouse)) {			FrameRgn(dragRgn);				/* alten Rahmen löschen */			CopyRgn(strucRgn,dragRgn);			OffsetRgn(dragRgn,newMouse.h-hOffset,newMouse.v-FloatOffset);			FrameRgn(dragRgn);				/* neuen Rahmen zeichnen */		}		Delay(2,&ticks);		oldMouse = newMouse;		GetMouse(&newMouse);	} while(WaitMouseUp() && !PtInRgn(newMouse,menuRgn));	FrameRgn(dragRgn);						/* Rahmen am Ende wieder löschen */	if(!PtInRgn(newMouse,menuRgn)) {		/* nicht in der Menüzeile losgelassen? */		wP->pos.h = (*dragRgn)->rgnBBox.left + 1;		wP->pos.v = (*dragRgn)->rgnBBox.top + 11;		*which = MovePaletteItem;			/* Palette wurde bewegt */	}	DisposeRgn(strucRgn);	DisposeRgn(dragRgn);					/* und alle zurück */	SetClip(saveRgn);	SetPenState(&savePen);}