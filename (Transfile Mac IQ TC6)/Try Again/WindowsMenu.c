#include "WindowsMenu.h"#include "Windows.h"#include "WindowsGlobal.h"#include "GlobalLib.h"#include "Utilities.h"#include "GeosMore.h"#include "DoEvent.h"#include "Menus.h"pascal VOID GetIStyle(MenuHandle theMenu,WORD item,WORD *chStyle) = 0xA941;WORD		gClassAttribut;		// Stil der WindowklassenClassPtr	gC;					// Klassen-Array[Menü-Offset]MenuHandle	gWindowMenu = nil;	// Handle vom Window-MenüWORD		gWMenuOffset;		// maximale Anzahl der Windowtypen + 1/*** *	Klassen-ID gemäß des Menü-Offsets finden ***/WORD		GetClass(WORD moffset){REG WORD		i;	for(i=0;i<MAXCLASSES;i++)		if(gC[i].moffset == moffset) // Menü-Offset gefunden?			return(i);				// Klassen-ID zurückgeben	return(false);					// Klasse 0, d.h. nicht gefunden}/*** *	echte Menü-ID gemäß einer Klasse ermitteln ***/WORD		MenuId(REG WORD class,WindPtr w){REG WORD	i;WORD		t;		// temp.StyleREG WORD	id = 0;Str255		s;Str255		title;	if (w)			// ein WindowPtr übergeben?		GetWTitle((WindowPtr)w,(StringPtr)&title); // dann den Titel ermitteln	for(i=1;i<gWMenuOffset;i++) {		// alle Windowtitel durch?		GetIStyle(gWindowMenu,i,&t);		if (t == gClassAttribut) {		// “Create Window”			id++;						// Windowklasse erhöhen			if (gC[class].moffset == id) // passende Klasse gefunden?				if ((!w)||(w && (gC[class].type)))	// kein Window oder noParent?					return(i);			// dann die ID zurückgeben		} else 			if (w) {				GetItem(gWindowMenu,i,s);				BlockMove(&s[3],&s[1],s[0]);				s[0] -= 2;				// 2 Spaces am Anfang entfernen				if (ComparePString(s,title))	// Windowtitel gefunden?					return(i);			// dann raus			}	}	return(0);						// keine passende ID gefunden!}/*** *	Testen, ob der title als Window im Menü angemeldet ist. ***/WORD		IsPNameInMenu(Str255 title){REG WORD	i;Str255		s;	for(i=1;i<gWMenuOffset;i++) {		GetItem(gWindowMenu,i,s);		BlockMove(&s[3],&s[1],s[0]);		s[0] -= 2;							// 2 Spaces am Anfang entfernen		if (ComparePString(s,title)) return(true);		if (s[1] == '-') return(false);		// ab erste Trennlinie abbrechen	}	return(false);}/*** *	Windows-Menü erzeugen ***/VOID	AppendWindowMenu(WORD id){	gWindowMenu = GetMHandle(id);	CheckResource((Handle)gWindowMenu);		// Handle des Windows-Menüs	{										// Anzahl der Windowtypen ermitteln		REG WORD	i = 1;		Str255		s;		LONG		id;		GetIStyle(gWindowMenu,i,(WORD*)&gClassAttribut);		for(i=1;;i++) {			REG WORD	j;			GetItem(gWindowMenu,i,(StringPtr)&s);			if(s[1] == '-') break;			// 1.Linie => Ende			j = s[0];			while ((s[j] >= '0')&&(s[j] <= '9'))	// Ziffern am Ende überlesen					j--;			if(s[j] == '#') {				s[j] = s[0] - j;				StringToNum(&s[j],&id);		// Klassen-ID holen				gC[id].moffset = i;			// Menü-Offset der Klasse merken				gC[id].type = false;				if (s[j-1] == '|') {		// nur ein Window in dieser Klasse?					gC[id].type = true;		// genau!					j--;				}				s[0] = j-1;					// Menüeintrag kürzen				SetItem(gWindowMenu,i,(StringPtr)&s);				CopyPString(gC[id].name,s);	// Namen der Klasse merken			}		}		gWMenuOffset = i;		// Anzahl der Einträge vor der 1. Linie	}}/*** *	Windows-Menü enablen/disablen ***/VOID	WMenuUpdate(Boolean *redrawMenuBar){REG WindPtr		w = gTopWindow;			// das Front-WindowREG MenuHandle	wm = gWindowMenu;		// in eine Register-VariableREG WORD		i;						// SchleifenvariableStr255			s;Str255			title;WORD			t;	if (!wm) return;					// kein Window-Menü vorhanden!	if (IsDAWindow(FrontWindow()) || !gDoc) {		if(GetMenuAble(wm,0)) {			// Windows-Menü aktiv?			DisableItem(wm,0);			// Window-Menü disablen			*redrawMenuBar = true;		// Menüzeile neu zeichnen		}		return;	}	if(!GetMenuAble(wm,0)) {			// Windows-Menü inaktiv?		EnableItem(wm,0);				// Window-Menü enablen		*redrawMenuBar = true;			// Menüzeile neu zeichnen	}	for(i=gWMenuOffset-1;i>0;i--)		// alle Windowtitel durch?		CheckItem(wm,i,false);			// Hacken entfernen	if (w) {							// Window offen		GetWTitle((WindowPtr)w,(StringPtr)&title);		for(i=gWMenuOffset-1;i>0;i--) { // alle Windowtitel durch?			GetItem(wm,i,(StringPtr)&s);			GetIStyle(wm,i,&t);			if (t != gClassAttribut) {				BlockMove(&s[3],&s[1],s[0]);				s[0] -= 2;				// 2 Spaces am Anfang entfernen			}			if (ComparePString(s,title))				CheckItem(wm,i,true);	// Hacken setzen		}		EnableItem(wm,gWMenuOffset+1);	// Window offen => Menüpunkte enablen		EnableItem(wm,gWMenuOffset+3);		EnableItem(wm,gWMenuOffset+4);		EnableItem(wm,gWMenuOffset+5);		if (w->Typ & 8)			EnableItem(wm,gWMenuOffset+2);	// Zoom nur möglich, wenn Fuller		else								// vorhanden			DisableItem(wm,gWMenuOffset+2);	} else {		DisableItem(wm,gWMenuOffset+1);	// kein Window offen?		DisableItem(wm,gWMenuOffset+2);	// dann die Menüpunkte disablen		DisableItem(wm,gWMenuOffset+3);		DisableItem(wm,gWMenuOffset+4);		DisableItem(wm,gWMenuOffset+5);	}	{	REG DocHandle i = gDocList;	while (i) {							// Ende der Dokumentenliste?		CheckItem(wm,(*i)->id+gWMenuOffset+WINDEXTRA,false);		i = (*i)->next;					// Nein: ein Dokument weiter	}	}	if (gDoc)		CheckItem(wm,(*gDoc)->id+gWMenuOffset+WINDEXTRA,true);	// neuen Haken setzen}/*** *	Windows aufräumen ***/VOID	TileWindows(VOID){REG WindowPeek	wind = LMGetWindowList();	// Handle des ersten WindowsREG WORD		count = 0;			// Windowanzahl = 0REG WORD		j;REG WORD		OffsetH,OffsetV;WORD			x,y,w,h;REG WORD		k;GrafPtr			savePort;	while (wind) {						// Ende der Windowliste?		if (IsAppWindow((WindowPtr)wind)&&!IsFloating((WindPtr)wind)) // passendes Window?			count++;					// Windowanzahl		wind = wind->nextWindow;		// Nein: ein Window weiter	}	if (!count) return;		// kein passenden Windows => raus	k = count;	j = -1;	do {					// eine nette Wurzelroutine für kleine Zahlen		j += 2;		count -= j;	} while(count>=0);	j >>= 1;				// j = √count	if (j*j != k) j++;		// aufrunden, wenn nötig	OffsetH = (gScreenRect.right - gScreenRect.left - 2*ROFFSET) / j ;	asm {		move.w	k,-(SP)		move	#0,OffsetV		moveq	#0,D0@loop2:	addq.w	#1,OffsetV		addq.w	#2,D0		sub.w	D0,k		bgt.s	@loop2		move.w	(SP)+,k	}	y = GetMBarHeight(); x = ROFFSET; k = 0;	OffsetV = (gScreenRect.bottom - gScreenRect.top) / OffsetV;	wind = LMGetWindowList();					// Handle des ersten Windows	while (wind) {						// Ende der Windowliste?		if (IsAppWindow((WindowPtr)wind)&&!IsFloating((WindPtr)wind)) { // passendes Window?			GetPort(&savePort);			// GrafPort retten			SetPort((WindowPtr)wind);	// GrafPort vom Window-Manager wählen			ShowHide((WindowPtr)wind,false);		// Window ausschalten			if (!BTstQ(((WindPtr)wind)->Typ,noSizer))	// auch ein Sizer zum Window?				SizeWind((WindPtr)wind,OffsetH-ROFFSET,OffsetV-SBarWidth-ROFFSET*2,false);			MoveWindow((WindowPtr)wind,x,y+SBarWidth+ROFFSET,false);			ShowHide((WindowPtr)wind,true);		// Window wieder anschalten			SetPort(savePort);			// GrafPort zurücksetzen			x += OffsetH; k++;			if (k == j) {				x = ROFFSET;				y += OffsetV;				k = 0;			}		}		wind = wind->nextWindow;		// Nein: ein Window weiter	}}/*** *	andere Art Windows zu ordnen ***/VOID	CleanUpWindows(VOID){REG WindowPeek	wind;REG WORD		i;REG WORD		x,y,w,h;REG WORD		windanz;REG WindowPeek	*wp;	windanz = 0;	for(wind = LMGetWindowList();wind;wind = wind->nextWindow) {		if (IsAppWindow((WindowPtr)wind))			if (!IsFloating((WindPtr)wind))	// ein Floating-Window?				windanz++;				// Windowanzahl	}	if (!windanz) return;				// keine passende Windows#define	WXOFFSET	5	wp = (WindowPeek*)NewPtr(windanz * sizeof(Ptr));	if (!wp) return;	i = 0;	for(wind = LMGetWindowList();wind;wind = wind->nextWindow) {		if (IsAppWindow((WindowPtr)wind))			if (!IsFloating((WindPtr)wind))	{ // ein Floating-Window?				wp[i++] = wind;			// Window in der Liste merken			}	}	x = ROFFSET; y = GetMBarHeight();	w = gScreenRect.right - gScreenRect.left - (windanz-1)*WXOFFSET - ROFFSET*2;	h = gScreenRect.bottom - gScreenRect.top;	for(i=windanz-1;i>=0;i--) {		wind = wp[i];		ShowHide((WindowPtr)wind,false);			// Window ausschalten		MoveWindow((WindowPtr)wind,x,y+SBarWidth+ROFFSET,false);		if (!BTstQ(((WindPtr)wind)->Typ,noSizer))	// auch ein Sizer zum Window?			SizeWind((WindPtr)wind,w,h-y,false);//		SelectWind((WindPtr)wind);		// Window toppen		ShowHide((WindowPtr)wind,true);			// Window wieder anschalten		x += WXOFFSET; y += WindowTHeight((WindowPtr)wind);	}	DisposPtr((Ptr)wp);}static Str255	gStr;Boolean	SelectIt(VOID){Str255	s;	GetWTitle((WindowPtr)gMacWind,(StringPtr)&s);	// Windowtitel holen	if (ComparePString(gStr,s)) {		// Titel gefunden		SelectWind(gMacWind);			// dann das Window selecten		return(true);					// gefunden	}	return(false);						// noch nicht gefunden}WindPtr	gWindClose;Boolean	CloseIt(VOID);Boolean	CloseIt(VOID){Str255	s;	GetWTitle((WindowPtr)gMacWind,(StringPtr)&s);	// Windowtitel holen	if (ComparePString(gStr,s)) {		// Titel gefunden		gWindClose = gMacWind;			// dann das Window merken		return(true);					// gefunden	}	return(false);						// noch nicht gefunden}WindPtr	SelectAllWind;Boolean	SelectAll(VOID){WindPtr	w = gMacWind;	if (!SelectAllWind) {				// erstes Window?		SelectWind(w);					// dann das Window selecten	} else {		BringBehind((WindowPtr)w,(WindowPtr)SelectAllWind); // Window hinter die Floats, bzw. nach vorne	}	SelectAllWind = w;					// als letztes Window merken	return(false);						// weitermachen}/*** *	das Windows-Menü ***/VOID	DoWindow(REG WindPtr wind,REG WORD item){REG RgnHandle	r;WORD			t;	if (!gWindowMenu) return;			// kein Windowmenü => raus	if (item < gWMenuOffset) {			// Window toppen		GetIStyle(gWindowMenu,item,&t);		GetItem(gWindowMenu,item,(StringPtr)&gStr);	// Namen des Windows holen		if (t != gClassAttribut) {		// normalen Windownamen gefunden			BlockMove(&gStr[3],&gStr[1],gStr[0]);			gStr[0] -= 2;				// 2 Spaces am Anfang entfernen			ForAllWindows((ProcPtr)SelectIt,nil,false);			SetDoc(gTopWindow->Doc);			SetDocFloats(gDoc);			// Floats dazu einschalten		} else {		REG WORD		i;					// Schleifenvariable		REG WORD		id = 1;				// id (1…n) des Windowtyps		for(i=1;i<gWMenuOffset;i++) {	// alle Windowtitel durch?			GetIStyle(gWindowMenu,i,&t);			if (t == gClassAttribut) {	// “Create Window”				if (i == item) {		// Titel gefunden?					if (!ComparePString(gStr,gC[GetClass(id)].name)) {	// Window pro Klasse?						ForAllWindows((ProcPtr)CloseIt,nil,false);						CloseWind(gWindClose);					} else						DOC(window,GetClass(id));	// Window öffnen ans Dokument					break;				}				id++;					// Windowtyp++			}		}		}	} else {		switch(item-gWMenuOffset) {		case	1:					SendBehind((WindowPtr)wind,nil);// Window nach hinten					WActivate(wind,false);			// Window deaktivieren					SelectTop();					// neues oberstes Window selecten					break; 		case	2:	WZoomClick(wind,(EqualRect(		// Rechtecke für Zoom vergleichen 					&(**(*(WindowPeek)wind).contRgn).rgnBBox,		// Rechteck der Content-Region					&(*(Rect**)(*(WindowPeek)wind).dataHandle)[1])	// Rechteck der Maximalgröße					)?inZoomIn:inZoomOut); 					break; 		case	3:	WCloseClick(wind); 					break; 		case	4:	TileWindows();					// Tile Window 					break; 		case	5:	CleanUpWindows();				// Clean Up 					break; 		default:	{								// neues Dokument nach oben					REG DocHandle d = gDocList;					while (d) {						// Ende der Dokumentenliste?						if ((*d)->id == item-gWMenuOffset-WINDEXTRA) {							if (d == gDoc) break;	// Dokument schon getoppet?							SetDoc(d);#if GERD							SetTopDoc(d);#endif							SelectAllWind = 0;							ForAllWindows((ProcPtr)SelectAll,gDoc,false);							SetDocFloats(gDoc);		// Floats dazu einschalten							break;						}						d = (*d)->next; // Nein: ein Dokument weiter					}					}					break; 		}	}}