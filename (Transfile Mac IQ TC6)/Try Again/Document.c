/*** *	Document.c ***/#include "Document.h"#include "GlobalLib.h"#include "GeosMore.h"#include "Utilities.h"#include "Menus.h"#include "Windows.h"#include "rsrcDefines.h"#include "WindowsMenu.h"#include "GlobalStruct.h"#include "File.h"#include "DialogLib.h"#include <Script.h>#include <String.h>DocHandle		gDoc;			// das aktive DokumentDocHandle		gDocList;		// Handle auf das erste DokumentDocHandle		gLastDoc = nil;	// das letzte Dokumentshort			gDocNummer = 1;	// Dokumentennummer, wenn ein neues Dokument erzeugt wirdProcPtr			gGetFileFilter = nil;	// Filefilter für SFGetFile()/*** *	Dokumenten-Struktur initialisieren ***/void	InitDocument(void){	gDocList = nil;					// kein Dokument vorhanden	gDoc = nil;						// kein aktives Dokument}/*** *	Routine, welche eine Dokument-Routine ausführt. false, wenn eine Routine *	vorhanden ist und ausgeführt wurde. ***/OSErr	DocAktion(short offset,long param){REG OSErr	ret;				// Rückgabewert	asm {		move.l	gDoc,D0				// Dokument-Handle		beq.s	@exit				// kein Dokument gefunden =>		move.l	D0,A0		addq.l	#1,D0				// Dokument-Handle = -1L?		beq.s	@exit				// dann raus =>		move.l	(A0),A0				// Handle auflösen		move.w	offset,D0			// Offset der Routine		move.l	(A0,D0),D0			// Adresse der Routine holen		beq.s	@exit				// keine Routine =>		move.l	D0,A0		move.l	param,-(SP)			// zusätzlicher Parameter		jsr		(A0)				// Routine anspringen (Rückgabewert!)		addq.l	#4,SP		move.w	D0,ret		bra.s	@exit2@exit:	move	#noErr,ret			// noErr: keine Routine => kein Fehler@exit2:	}	return(ret);}/*** *	aktives Dokument setzen ***/void	SetDoc(REG DocHandle d){	if ((d == (DocHandle)-1L)||		// illegales Dokument => raus		(d == gDoc)) return;		// Dokument ist bereits aktiv => raus	DOC(deactivate,nil);			// altes Dokument wird inaktiv	gDoc = d;						// neues Dokument setzen	if (gDoc)		DOC(activate,nil);			// und aktivieren}/*** *	Verwaltungsroutinen für das “Window”-Menü ***/WORD		DocMenu(REG WORD id,REG USTR docname){	if (!gWindowMenu) return(0);	// kein Window-Menü vorhanden!	if (id) {		SetItem(gWindowMenu,id+gWMenuOffset+WINDEXTRA,docname);	// Dokument-Namen ändern		return(id);					// alte id zurückgeben, da unverändert	} else {		AppendMenu(gWindowMenu,docname);			// hinten ans Menü anhängen		return(CountMItems(gWindowMenu)-gWMenuOffset-WINDEXTRA);	// Menü-ID zurückgeben	}}/*** *	neuen Dokumentennamen ins Menü übertragen ***/void	DocMenuName(REG DocHandle d){	(*d)->id = DocMenu((*d)->id,(*d)->f.fss.name);	// Eintrag ins “Window”-Menü}/*** *	Dokument hat evtl. einen neuen Namen erhalten => alle Windownamen anpassen ***/void	WindRename(void){Str255		s;			// Buffer für den WindownamenREG USTR	sp = s;Str255		d;	GetWTitle((WindowPtr)gMacWind,sp);				// aktuellen Windownamen holen	PtoCstr(sp);						// in einen C-String wandeln	while((*sp) && (*sp != ':')) sp++;	// und Ptr HINTER den Dokumentennamen	if (!*sp) return;					// Namenstrenner fehlte => nicht umbenennen	CtoPstr((STR)sp);						// und wieder in einen Pascal-String wandeln	CopyPString(d,(*gDoc)->f.fss.name);	// neuer Dokumentennamen	ConcatPString(d,sp);				// plus alter Windowname	SetWindowTitle(gMacWind,d);			// neuen Titel setzen}Boolean	RenameWindow(void);Boolean	RenameWindow(void){	WINDOW(gMacWind,rename,nil);	return(false);}void	SetDocMenuName(REG DocHandle d);void	SetDocMenuName(REG DocHandle d){	DocMenuName(d);	ForAllWindows((ProcPtr)RenameWindow,d,false);	// Windows umbenennen}/*** *	Dokumentenliste unter dem “Window”-Menü updaten ***/void	DocMenuUpdate(void){REG DocHandle	d = gDocList;			// Handle des ersten DokumentREG short		i = 100;	if (!gWindowMenu) return;			// kein Window-Menü vorhanden	while(--i)		DelMenuItem(gWindowMenu,gWMenuOffset+WINDEXTRA+1);	while (d) {							// Ende der Liste?		(*d)->id = 0;					// Dokument anhängen		DocMenuName(d);					// Eintrag ins “Window”-Menü		d = (*d)->next;					// zum nächsten Dokument	}}/*** *	Floats zum aktuellen Dokument ausschalten ***/void	ResetDocFloats(DocHandle d){	ForAllWindows((ProcPtr)HideFloats,d,true);}/*** *	Floats zum aktuellen Dokument einschalten ***/void	SetDocFloats(DocHandle d){	ResetDocFloats(d);						// Floats ausschalten	if (!gInBackground) {					// Nicht im Hintergrund!//		REG WindPtr ww = gTopFloat;//		if (!ww) return;					// keine Floats vorhanden!//		if ((ww->Doc != gDoc)&&				// paßt Float nicht zum Dokument?//			(!((WindowPeek)ww)->visible)||	// und ist es noch unsichtbar?//			(!IsFloating(ww))) {			// oder evtl. kein Float?			ForAllWindows((ProcPtr)ShowFloats,gDoc,false);	// Floats anschalten//		}	}}/*** *	Dokument schließen ***/OSErr		AppDisposeDocument(REG DocHandle d){REG OSErr	err = noErr;	if (d) {									// Dokument gültig?		if (AppDocumentFile(d))					// Datei offen?			err = FSClose((*d)->f.refNum);		// dann schließen		CloseWindAll(d);						// alle Windows schließen		SetDoc(d);								// das zu schließende Dokument aktivieren		DOC(close,nil);						// Dokument schließen!		if (gDoc == d) SetDoc(nil);				// Dokument ausschalten, wenn aktiv		if (gDocList == d)						// erstes Dokument entfernen?			gDocList = (**d).next;				// dann gDocList direkt ändern		else {			REG DocStruct	**i = gDocList;		// Handle des ersten Dokument			while ((**i).next != d)				// zu löschendes Dokument?			 	i = (**i).next;					// Nein: ein Dokument weiter			(**i).next = (**d).next;			// Dokument aus der Liste entfernen		}		DisposHandle((*d)->data);				// Datenstruktur freigeben		CheckOSError(MemError());		DisposHandle((Handle)d);				// Dokumenten-Struktur freigeben		CheckOSError(MemError());		DocMenuUpdate();						// Windows-Menü updaten		SetDoc(gDocList);						// erstes Dokument aktivieren		AdjustMenus();							// Windows-Menü, etc. ggf. neuzeichnen	}	return(err);}/*** *	true, wenn Dokument dirty ist. ***/Boolean	AppDocumentDirty(DocHandle d,REG short flag){REG short		temp = (*d)->f.fileDirty;	if (flag >= 0) {					// Flag setzen?		(*d)->f.fileDirty = flag;		// ja!		if (flag)			(*d)->f.reallyReadOnly = false;	// nun nicht mehr ReadOnly…	}	return(temp);						// alten Status zurückgeben}/*** *	true, wenn Dokument als Datei existiert ist. ***/Boolean	AppDocumentFile(DocHandle d){	if (!d) return(false);				// kein Dokument	return((*d)->f.fss.vRefNum != kInvalVRefNum);}/*** *	Dokument erzeugen lassen ***/OSErr	AppInitDocument(REG DocHandle d,short m,REG OSErr err){	if (err) return(err);				// ein Fehler => raus	{ G(InitDoc)(d); }					// Struktur auffüllen lassen	SetDoc(d);							// Dokument aktivieren	if (m == iNew)		err = DOC(new,nil);				// Dokument erzeugen lassen	else		err = DOC(open,nil);			// Dokument öffnen lassen	if (err) {							// ein Fehler? Ja!		AppDisposeDocument(d);			// Dokument wieder verwerfen		SetDoc(gLastDoc);				// altes Dokument wieder aktivieren		gLastDoc = nil;					// kein letztes Dokument	}	return(err);}/*** *	eindeutigen Dokumentennamen setzen. Bei Bedarf wird ein " #Nummer" drangehängt. *	Dabei ist auch die Nummer eindeutig! Ist “change” = false, so darf der Name NICHT *	verändert werden. Es wird dann ein Fehler zurückgegeben. ***/OSErr	SetDocName(DocHandle d,Str255 s,Boolean change){DocHandle	i = gDocList;		// Handle des ersten DokumentBoolean		flag = false;		// Name noch nicht belegt!	while (i) {					// alle Dokumente durch?		if (ComparePString((*i)->f.fss.name,s)&&(d != i))	{ // gleiches Dokument gefunden?			if (AppDocumentFile(i)&&!change)	// Name bereits als Datei auf der Platte?				return(dupFNErr);		// => nichts geht mehr			else {				flag = true;			// anderen Namen nehmen!				break;			}		}	 	i = (**i).next;					// Nein: ein Dokument weiter	}	if (flag) {							// gleicher Name schon belegt?		USTR		sp = s + s[0];		// Ptr das Stringende		USTR		se = sp;			// Ptr auf das Stringende		LONG		i;		while((sp > &s[1])&&(*sp != '#'))			--sp;						// bis zur Nummer suchen		if (*sp == '#') {				// Nummer gefunden?			Str255	stemp;			stemp[0] = 0;			*s -= se-sp;				// Gesamtstringlänge runtersetzen			*sp = se-sp;				// Stringlänge einsetzen			StringToNum(sp,&i);			// Zahl auswerten			i++;						// eine Nummer weiter			NumToString(i,sp);			*s += sp[0];				// neue Stringlänge			*sp = '#';					// '#' wieder einsetzen		} else			ConcatPString(s,"\p #1");	// dann Namen erweitern		SetDocName(d,s,change);			// und setzen	} else {		CopyPString((*d)->f.fss.name,s);	// Dummy-Name	}	return(noErr);}/*** *	Neues Dokument anlegen ***/OSErr	AppNewDocument(REG DocHandle *result){REG DocHandle	dh;REG DocPtr		dp;Str255			untitled;Str255			nummer;REG UWORD		i;	*result = nil;						// Default: es hat nicht geklappt	if (dh = (DocHandle)NewHandleClear(sizeof(DocStruct))) {		GetIndString(untitled,STRcommon,strUNTITLED);	// sonst einen “Dummy”-Namen//		NumToString(gDocNummer++,nummer);//		ConcatPString(untitled,nummer);		HLock((Handle)dh);				// Handle sperren		dp = *dh;						// Ptr auf das Dokument		dp->f.fileDirty		= false;	// Dokument nicht dirty		dp->f.readOnly		= false;	// Dokument nicht “read-only“		dp->f.reallyReadOnly = false;	// Dokument nicht “echt” “read-only“!		dp->f.fss.vRefNum	= kInvalVRefNum; // illegale Volume-Reference		for(i=0;i<32;i++)			dp->f.Passwort[i] = 0;		// Passwort löschen		SetDocName(dh,untitled,true);	// Dummy-Name		dp->data = NewHandle(0L);		// noch keine Daten…		dp->id = 0;						// Name noch nicht im Menü		HUnlock((Handle)dh);		{ G(InitDoc)(dh); }				// Struktur auffüllen lassen		if (!dp->data) {				// kein Platz für eine leere Handle?			DisposHandle((Handle)dh);	// Struktur wieder freigeben und raus			return(memFullErr);			// Speicher ist voll		}		gLastDoc = gDoc;				// das zuletzt aktive Dokument#if 1		{	DocHandle	*dhh = &gDocList;			if(*dhh) {					// min. EIN Dokument?				dhh = &(**dhh)->next;				while(*dhh)				// bis zum Ende der Liste					dhh = &(**dhh)->next;			}			*dhh = dh;					// Dokument an die Liste anhängen		}#else		(*dh)->next = gDocList;			// Dokument vor die Liste hängen		gDocList = dh;					// Dokument in die Docliste einhängen#endif		SetDoc(dh);						// Dokument aktivieren		DocMenuName(dh);				// Eintrag ins “Window”-Menü		*result = dh;					// Handle zurückgeben		return(noErr);					// kein Fehler!	}	return(memFullErr);					// Speicher ist voll}/*** *	Dokument laden ***/OSErr	AppOpenDocument(REG DocHandle *result,REG FSSpecPtr fileToOpen,REG char permission){FSSpec				myFileSpec;FSSpec				oldFileSpec;StandardFileReply	reply;REG OSErr			err;DocHandle			d;short				fileRefNum;REG short			item;	*result = nil;						// Default: es hat nicht geklappt	if (!fileToOpen) {					// File bereits vorgegeben?		if (DisplayGetFile(&reply))			myFileSpec = reply.sfFile;		else			return(userCanceledErr);	// User hat “Abbruch” angeklickt	} else {		FInfo	f;		myFileSpec = *fileToOpen;		err = FGetFInfo(fileToOpen,&f);		if (err) return(err);		if (f.fdType != gG.FileTypes[0])// kein Standardformat?			err = fnfErr;				// dann: “File not found!”		if (err == fnfErr)				// Datei nicht gefunden => raus			return(err);		if (CheckOSError(err)) {			reply.sfFlags = f.fdFlags;	// Finder-Flags z.B. Stationary		} else {			reply.sfFlags = 0;			// keine Finder-Flags		}	}	if (err = AppNewDocument(&d))		// neues Dokument anlegen		return(err);					// Fehler bei New (Speicher reicht nicht)	FSetVol(&myFileSpec);				// Ordner setzen	err = FOpenDF(&myFileSpec,permission,&fileRefNum);	if ((err == permErr)||(err == afpAccessDenied)) {	// Permission nicht erteilt? (Datei Locked!?!)		(*d)->f.readOnly = true;		// Dokument “read-only“!		(*d)->f.reallyReadOnly = true;	// Dokument “echt” “read-only“!		err = FOpenDF(&myFileSpec,fsRdPerm,&fileRefNum);	}	if (err == opWrErr) {				// Datei schreibgeschützt?		ParamText(myFileSpec.name,nil,nil,nil);		item = DoDialog(DLOGreadOnly,-1);		if (item < 0) {			AppDisposeDocument(d);			return(err);		}		if (item != 1) {			AppDisposeDocument(d);			return(userCanceledErr);	// User hat “Abbruch” angeklickt		}		(*d)->f.readOnly = true;		// Dokument “read-only“!		err = FOpenDF(&myFileSpec,fsRdPerm,&fileRefNum);	}	if (err) {							// Fehler bei HOpen()?		AppDisposeDocument(d);			// dann das Dokument verwerfen		return(err);					// und raus	}	oldFileSpec = (*d)->f.fss;	(*d)->f.fss = myFileSpec;			// File-Parameter merken	(*d)->f.refNum = fileRefNum;	HLock((Handle)d);	if (SetDocName(d,(*d)->f.fss.name,true)) {	// Name suchen		HUnlock((Handle)d);		AppDisposeDocument(d);			// dann das Dokument verwerfen		return(dupFNErr);				// Name ist bereits belegt!	}	HUnlock((Handle)d);	if (err = AppReadDocument(d)) {		// Dokument einlesen		AppDisposeDocument(d);			// dann das Dokument verwerfen		return(err);					// und raus	}	if (((*d)->f.readOnly)||			// Datei nur lesen?		(reply.sfFlags & (1<<isStationery))) {	// oder ein Stationery?		FSClose((*d)->f.refNum);		// dann die Datei sofort wieder schließen		if (!(*d)->f.reallyReadOnly)	// eh nicht zu schreiben?			(*d)->f.fss = oldFileSpec;	// alter Dateiname: “Untitled”		(*d)->f.readOnly	= true;		// Dokument “read-only“ (wegen Stationary!)		(*d)->f.fss.vRefNum	= kInvalVRefNum; // illegale Volume-Reference	}	DocMenuName(d);						// Dokument-Namen im Menü updaten	*result = d;						// Dokument-Handle zurückgeben	return(noErr);						// kein Fehler}/*** *	 ***/OSErr	AppSaveDocument(REG DocHandle d,REG short saveMode){Str255				closeOrQuit;StandardFileReply	reply;REG OSErr			err;short				fileRefNum;REG short			item;FSSpec				saveOld;short				saveOldrefNum;FInfo				f;Boolean				flag = !AppDocumentFile(d);	// True, wenn kein Filename vorhanden	if (!d) return(noErr);				// kein Dokument => kein Fehler	if (saveMode != iSaveAs) {			// “SaveAs” angewählt		if (!AppDocumentDirty(d,-1))	// Dokument nicht dirty?			return(noErr);				// dann gleich wieder raus	}	CopyPString(reply.sfFile.name,(*d)->f.fss.name); // Dateinamen merken	if ((saveMode == iClose)||(saveMode == iQuit)) { // implizites Speichern		GetIndString(closeOrQuit,STRcommon,(saveMode == iClose)?strCLOSING:strQUITTING);		ParamText(reply.sfFile.name,closeOrQuit,nil,nil);		item = DoDialog(DLOGsaveChanges,kSaveYes);		if (item != kSaveYes) {					// “Don`t Save” bzw “Cancel” angeklickt			err = noErr;			if (item == kSaveCanceled) err = userCanceledErr; // Cancel angeklickt			return(err);		}	}	saveOld = (*d)->f.fss;			// wegen Stationery retten	saveOldrefNum = (*d)->f.refNum;	if ((saveMode == iSaveAs)||					// “Save As” oder			flag) {								// kein Filename vorhanden?		if (!DisplayPutFile(&reply,true))			return(userCanceledErr);			// “Abbruch” angewählt		if (!flag)			FSClose((*d)->f.refNum);			// alte Datei schließen		if (err = CreateOpenFile(&reply.sfFile,&fileRefNum)) {			(*d)->f.fss.vRefNum = kInvalVRefNum;	// Fehler!			return(err);		}		FCopyResource(&reply.sfFile,'STR ',-16396,'STR ',-16396);	// Resource übertragen		(*d)->f.fss = reply.sfFile;		(*d)->f.refNum = fileRefNum;		if (BTstQ(reply.sfFlags,isStationery)) { // Stationery?			err = FGetFInfo(&(*d)->f.fss,&f);			if (err) return(err);			f.fdFlags |= 1<<isStationery;		// Stationery erzeugen			err = FSetFInfo(&(*d)->f.fss,&f);			if (err) return(err);		}	}	err = AppWriteDocument(d);		// Dokument schreiben	FFlushVol(&(*d)->f.fss);		// Volume updaten	FGetFInfo(&(*d)->f.fss,&f);		// Flags holen	if (BTstQ(f.fdFlags,isStationery)) {	// ein Stationery?		(*d)->f.fss = saveOld;		// dann auf alten Namen zurücksetzen		(*d)->f.refNum = saveOldrefNum;		return(err);				// und raus (Dokument bleibt dirty!)	}	if (err)	return(err);		// mit Fehlercode verlassen	AppDocumentDirty(d,false);		// Dokument nun nicht mehr “dirty”	(*d)->f.readOnly = false;		// Dokument nun nicht mehr “read-only”	if ((saveMode == iSaveAs)||		// “SaveAs” angewählt		flag)						// oder wenn noch ohne Filename		SetDocMenuName(d);			// Dokument-Namen im Menü updaten	return(noErr);					// alles ok!}/* ConvertOldToNewSFReply**** struct StandardFileReply {			struct SFReply {** 	Boolean 	sfGood;				<-	Boolean good;** 	Boolean 	sfReplacing;		<-	Boolean copy;** 	OSType 		sfType;				<-	OSType fType;** 	FSSpec		sfFile;** 					vRefNum;		<-	real vRefnum from (short vRefNum)** 					parID;			<-	real dirID from (short vRefNum)** 					name;			<-	Str63 fName;** 	ScriptCode	sfScript;			<-	iuSystemScript** 	short 		sfFlags;			<-	0** 	Boolean 	sfIsFolder;			<-	false** 	Boolean 	sfIsVolume;			<-	false** 	long		sfReserved1;		<-	0** 	short		sfReserved2;		<-	0** };									};*/void	ConvertOldToNewSFReply(REG SFReply *oldReply,REG StandardFileReply *newReply){long	ignoredProcID;	newReply->sfGood		= oldReply->good;	newReply->sfReplacing	= oldReply->copy;		// Correct assignment?	newReply->sfType		= oldReply->fType;	GetWDInfo(oldReply->vRefNum,&newReply->sfFile.vRefNum,&newReply->sfFile.parID,&ignoredProcID);	BlockMove((Ptr)&oldReply->fName,(Ptr)&newReply->sfFile.name,oldReply->fName[0]+1);	// Punt on the rest.	newReply->sfScript		= smSystemScript;	newReply->sfFlags		= 0;	newReply->sfIsFolder	= false;	newReply->sfIsVolume	= false;	newReply->sfReserved1	= 0;	newReply->sfReserved2	= 0;}/*** *	Neue Datei erzeugen und öffnen, dabei eine evtl. alte Datei löschen. ***/OSErr	CreateOpenFile(REG FSSpec *file,REG short *refNum){REG OSErr	err;	FSetVol(file);						// Ordner setzen	err = FCreate(file);	if (err == dupFNErr) {				// Datei schon vorhanden		FDelete(file);					// dann erstmal löschen		err = FCreate(file);	}	if (!err) {							// Datei nun öffnen		err = FOpenDF(file,fsRdWrPerm,refNum);		if (err) FDelete(file);	}	return(err);}/*** *	Dialogbox um eine Datei zum Lesen auszuwählen ***/Boolean DisplayGetFile(REG StandardFileReply *reply){	if (gStandardFileFlag)			// neuer SFReply vorhanden?		StandardGetFile(gGetFileFilter,gG.FileTypesCount,gG.FileTypes,reply);	else {		Point		where;		SFReply		oldReply;		Str255		prompt;		GetIndString(prompt,STRcommon,strGETFILE);		FindDlogPosition('DLOG',getDlgID,&where);		SFGetFile(where,prompt,gGetFileFilter,gG.FileTypesCount,gG.FileTypes,nil,&oldReply);		ConvertOldToNewSFReply(&oldReply,reply);	}	return(reply->sfGood);}/*** *	Unterprogramm für StandardPutFile Funktionen ***/#if !GERDpascal short	myDlgHook6(short item,DialogPtr d);pascal short	myDlgHook7(short item,DialogPtr d,Ptr data);pascal void		ChicagoTextItem(register WindowPtr wind,short item);pascal void		ChicagoTextItem(register WindowPtr wind,short item){register short			fontStore,sizeStore;Handle					itemH;short					itemType;Rect					r;register StringHandle	srsc;Str255					s;Str255					srscP;short					strid;	SetPort(wind);	fontStore = wind->txFont;		// Font und Fontgröße merken	sizeStore = wind->txSize;	TextFont(0);					// Font und Fontgröße auf System-Größe setzen	TextSize(0);	GetDItem(wind,item,&itemType,&itemH,&r);	switch(item) {	case 5:		strid = 128;				break;	case 7:		strid = 129;				break;	}	srsc = GetString(strid);		// Passwort-Text holen	if (srsc) {		HLock((Handle)srsc);		CopyPString(srscP,*srsc);		HUnlock((Handle)srsc);		PtoCstr(srscP);		{			register char	*sp = (char*)srscP;			*s = 0;			while (*sp) {				Str255	temp;				if (*sp == '^') {	// ParamText()-Ersetzung					StringHandle	h = LMGetDAStrings(sp[1]-'0');					if (h) {						HLock((Handle)h);						CopyPString(temp,*h);						HUnlock((Handle)h);						PtoCstr(temp);					} else						*temp = 0;					sp++;				} else {					temp[0] = *sp;					temp[1] = 0;				}				strcat((char*)s,(char*)temp);				sp++;			}		}		TextBox(s,Strlen((char*)s),&r,teJustLeft);// und ausgeben	}	TextFont(fontStore);			// Font und Fontgröße zurücksetzen	TextSize(sizeStore);}short		PasswortDialog(short id){register DialogPtr	dialog;short				font;short				item = 3;			// Abbruch = DefaultStr255				s1,s2;Boolean				retry;	ParamText(AKTDOC.f.fss.name,nil,nil,nil);	// Dokumentname	GetFNum("\p.Pwd",&font);			// Passwort-Font-ID holen	SetDAFont(font);					// und setzen	dialog = GetCenteredDialog(id,nil);	if (dialog) {						// Dialog vorhanden?		SetUserItem(dialog,5,ChicagoTextItem);		if (id == 160) SetUserItem(dialog,7,ChicagoTextItem);		OutlineDialogItem(dialog,1);		SetIText((Handle)GetCH(dialog,4),CtoPstr((STR)AKTDOC.f.Passwort));		if (id == 160) SetIText((Handle)GetCH(dialog,6),AKTDOC.f.Passwort);		SelIText((DialogPtr)dialog,4,0,32767);		ShowWindow(dialog);		do {			ModalDialog((ModalFilterProcPtr)OwnDialogFilter,&item);			GetIText((Handle)GetCH(dialog,4),s1);			retry = false;			if ((item == 1)&&(id == 160)) {			// Passwort-Eingabe				GetIText((Handle)GetCH(dialog,6),s2);				if (!Strpcmp(s1,s2)) retry = true;	// Strings ungleich!			}			if (retry) SysBeep(10);		} while(retry);		if (item == 1)	Strpcpy(AKTDOC.f.Passwort,s1);		PtoCstr(AKTDOC.f.Passwort);		DisposDialog(dialog);	}	SetDAFont(0);						// Dialog-Font zurücksetzen	return(item);}pascal short	myDlgHook6(short item,DialogPtr d){	if (item == 9) {					// Passwort?		PasswortDialog(160);		item = 100;	}	return(item);}pascal short	myDlgHook7(short item,DialogPtr d,Ptr data){DialogPtr		dialog;	if ((((WindowPeek)d)->refCon == sfMainDialogRefCon) &&		(item == 13)) {			// Passwort?		PasswortDialog(160);		item = 100;	}	return(item);}#endif/*** *	Dialogbox um eine Datei zum Schreiben auszuwählen ***/Boolean DisplayPutFile(REG StandardFileReply *reply,Boolean pw){Str255		prompt;	GetIndString(prompt,STRcommon,strSAVEAS);	if (gStandardFileFlag) {	// neuer SFReply vorhanden?		REG Point	p; p.v = -1;p.h = -1;#if !GERD		if (pw == false)#endif			StandardPutFile(prompt,reply->sfFile.name,reply);#if !GERD		else			CustomPutFile(prompt,reply->sfFile.name,reply,DLOGPutFile+1,p,						(DlgHookYDProcPtr)myDlgHook7,nil,nil,nil,nil);#endif	} else {		Point		where;		SFReply		oldReply;		FindDlogPosition('DLOG',putDlgID,&where);#if !GERD		if (pw == false)#endif			SFPutFile(where,prompt,reply->sfFile.name,nil,&oldReply);#if !GERD		else			SFPPutFile(where,prompt,reply->sfFile.name,myDlgHook6,&oldReply,DLOGPutFile,0L);#endif		ConvertOldToNewSFReply(&oldReply,reply);	}	return(reply->sfGood);}/* AppReadDocument**** Reads in specified file into the data portion of a document handle.*/OSErr	AppReadDocument(REG DocHandle d){REG short		fileRefNum = (*d)->f.refNum;REG OSErr		err;REG char		hstate;long			count;WORD			saveCursor = gCurrentCursor;	biene();	hstate = HLockH((Handle)d);	err = GetEOF(fileRefNum,&count);	if (!err) {		err = SetFPos(fileRefNum,fsFromStart,0L);		if (!err)			if (!(*d)->load) {				// Funktion vorhanden?				SetHandleSize((*d)->data,count);				err = MemError();				if (!err)					err = FSRead(fileRefNum,&count,*((*d)->data));			} else {				err = DOC(load,d);			}	}	HSetState((Handle)d,hstate);	DOC(unpack,d);				// Daten auspacken	DoSetCursor(saveCursor);	return(err);}/* AppWriteDocument**** Writes the data portion of a document handle to the specified file.*/OSErr	AppWriteDocument(REG DocHandle d){REG short		fileRefNum = (*d)->f.refNum;REG OSErr		err;REG char		hstate;long			fpos,count;long			seconds;Str255			tempFileName;WORD			saveCursor = gCurrentCursor;	biene();	DOC(pack,d);				// Daten packen	err = SetFPos(fileRefNum,fsFromStart,0);		// an den Dateistart	if (!err) {		hstate = HLockH((Handle)d);		if (!(*d)->save) {				// Funktion vorhanden?			count = GetHandleSize((*d)->data);			err = FSWrite(fileRefNum,&count,*((*d)->data));		} else {			err = DOC(save,d);		}		HSetState((Handle)d,hstate);	}	if (!err) {		err = GetFPos(fileRefNum,&fpos);		if (!err) err = SetEOF(fileRefNum,fpos);	}	DOC(unpack,d);			// Daten wieder auspacken	DoSetCursor(saveCursor);	return(err);}/*** *	Dokument duplizieren ***/OSErr	AppDuplicateDocument(REG DocHandle oldFrHndl,REG DocHandle *newFrHndl){REG OSErr		err;REG Handle		old,new;REG long		oldSize;	err = AppNewDocument(newFrHndl);	if (!err) {		old = (*oldFrHndl)->data;		// alte Handle auf die Daten		new = (**newFrHndl)->data;		// neue Handle auf die Daten		oldSize = GetHandleSize((Handle)old);		SetHandleSize((Handle)new,oldSize);		err = MemError();				// ein Fehler?		if (!err)			BlockMove((Ptr)*old,(Ptr)*new,oldSize); // Daten verdoppeln		else			AppDisposeDocument(*newFrHndl);	// Dokument wieder verwerfen	}	return(err);}/*** *	Dokument erneut laden ***/OSErr	AppRevertDocument(REG DocHandle d){REG	OSErr		err = noErr;		// Default: kein FehlerREG short		item;				// angewähltes Item	ParamText((*d)->f.fss.name,nil,nil,nil);	item = DoDialog(DLOGrevert,kRevertCancel);	if (item == kRevertYes) {		if (AppDocumentFile(d)) {			// Dokument als File vorhanden?			DOC(beforerevert,d);			// vor Revert z.B. IRQs stoppen			err = AppReadDocument(d);		// dann dieses File neu einlesen			if (err == noErr)				// ein Fehler? Nein!				AppDocumentDirty(d,false);	// Dirty-Flag zurücksetzen		}	}	return(err);}