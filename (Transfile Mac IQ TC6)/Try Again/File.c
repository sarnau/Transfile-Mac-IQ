/*** *	File.c * *	allgemeine File-Library für System 6 UND System 7 ***/#include "GlobalStruct.h"#include "File.h"#include "GlobalLib.h"#include "Utilities.h"#include <Script.h>#include <Aliases.h>OSErr	FOpenDF(REG FSSpec *file,SignedByte permission,short *fileRefNum){REG OSErr	err = noErr;	*fileRefNum = -1;				// illegale RefNum	if (gHasAlias) {				// Alias vorhanden?		Boolean	targetIsFolder;		Boolean	wasAliased;		err = ResolveAliasFile(file,true,&targetIsFolder,&wasAliased);		if (targetIsFolder) err = paramErr;	// Ordner kann ich nicht öffnen…	}	if (err) return(err);			// ein Fehler? => raus	if (gFSSpecFlag) {		err = FSpOpenDF(file,permission,fileRefNum);	} else {		if (file->name[1] == '.')	// Punkt am Anfang des Filenamen			file->name[1] = ' ';	// ist nicht erlaubt!		err = HOpen(file->vRefNum,file->parID,file->name,permission,fileRefNum);	}	return(err);					// Fehlercode zurückgeben}OSErr	FCreate(REG FSSpec *file){REG OSErr	err;	if (gFSSpecFlag) {		err = FSpCreate(file,gSignature,gG.FileTypes[0],smSystemScript);	} else {		if (file->name[1] == '.')	// Punkt am Anfang des Filenamen			file->name[1] = ' ';	// ist nicht erlaubt!		err = HCreate(file->vRefNum,file->parID,file->name,gSignature,gG.FileTypes[0]);	}	return(err);					// Fehlercode zurückgeben}OSErr	FDelete(REG FSSpec *file){REG OSErr	err;	if (gFSSpecFlag) {		err = FSpDelete(file);	} else {		err = HDelete(file->vRefNum,file->parID,file->name);	}	return(err);					// Fehlercode zurückgeben}OSErr	FClose(short refnum){REG OSErr	err;	err = FSClose(refnum);			// dann die Datei sofort wieder schließen	return(err);					// Fehlercode zurückgeben}OSErr	FGetFInfo(REG FSSpec *file,FInfo* f){REG OSErr	err;HFileParam	w;	if (gFSSpecFlag) {		err = FSpGetFInfo(file,f);	} else {		w.ioNamePtr = (StringPtr)&file->name;		w.ioVRefNum = file->vRefNum;		w.ioFDirIndex = 0;			// Finder-Flags ermitteln		w.ioDirID = file->parID;		err = PBHGetFInfoSync((HParmBlkPtr)&w);		*f = w.ioFlFndrInfo;		// Finder-Info kopieren	}	return(err);					// Fehlercode zurückgeben}OSErr	FSetFInfo(REG FSSpec *file,FInfo* f){REG OSErr	err;HFileParam	w;	if (gFSSpecFlag) {		err = FSpSetFInfo(file,f);	} else {		w.ioNamePtr = (StringPtr)&file->name;		w.ioVRefNum = file->vRefNum;		w.ioFDirIndex = 0;		w.ioDirID = file->parID;		err = PBHGetFInfoSync((HParmBlkPtr)&w);		if (err) return(err);		// Fehler beim Holen der Parameter		w.ioFlFndrInfo = *f;		// Finder-Struktur neu setzen		err = PBHSetFInfoSync((HParmBlkPtr)&w);	}	return(err);					// Fehlercode zurückgeben}/*** *	Resource-Fork entfernen ***/OSErr	FRemoveResource(REG FSSpec *file){REG OSErr		err;short			fileRefNum;	err = HOpenRF(file->vRefNum,file->parID,(StringPtr)&file->name,fsRdWrPerm,&fileRefNum);	if (!err) {		err = SetEOF(fileRefNum,0L);	// und löschen		FSClose(fileRefNum);			// und wieder schließen	}	return(err);}/*** *	Resource-Fork erzeugen ***/OSErr	FCreateResource(REG FSSpec *file){	HCreateResFile(file->vRefNum,file->parID,(StringPtr)&file->name);	// Resource-Fork erzeugen	return(ResError());}/*** *	Resource-Fork öffnen ***/OSErr	FOpenResFile(REG FSSpec *file,REG short *fileRefNum){REG OSErr		err;	*fileRefNum = HOpenResFile(file->vRefNum,file->parID,(StringPtr)&file->name,fsRdWrPerm);	err = ResError();	if ((*fileRefNum == -1)&&(!err)) err = ioErr;	if (*fileRefNum)		UseResFile(*fileRefNum);	// zur Sicherheit, ist an sich nicht nötig	return(err);}/*** *	Resource-Fork schließen ***/OSErr	FCloseResFile(short fileRefNum){	CloseResFile(fileRefNum);	return(ResError());}/*** *	Resource zur Datei hinzufügen ***/OSErr	FCopyResource(REG FSSpec *file,ResType sType,short sid,ResType dType,short did){REG Handle	h;OSErr		err;REG short	saveRes;short		resid;	h = GetAppResource(sType,sid,&err);// Resource aus der APPL lesen	if ((!h)||(err)) return((err)?err:ioErr);	saveRes = CurResFile();			// aktuelle Resource-Datei retten	err = FCreateResource(file);	// Resource-Datei erzeugen	if (err == dupFNErr)			// Resource-Fork schon vorhanden?		err = noErr;				// dann den Fehler ignorieren	if(!err)		err = FOpenResFile(file,&resid);	// Resource-Fork öffnen	if(!err) {		DetachResource(h);			// Resource => normaler Handle		AddResource(h,dType,did,"\p"); // Resource erzeugen		err = ResError();		if(!err) {			WriteResource(h);		// und schreiben			err = ResError();			ReleaseResource(h);		}		FCloseResFile(resid);	}	UseResFile(saveRes);			// alte Resource-Datei setzen}OSErr	FSetVol(REG FSSpec *file){REG OSErr	err;HFileParam	w;	w.ioNamePtr = nil;	w.ioVRefNum = file->vRefNum;	w.ioDirID = file->parID;	err = PBHSetVolSync((WDPBPtr)&w);	return(err);					// Fehlercode zurückgeben}OSErr	FFlushVol(REG FSSpec *file){REG OSErr	err;HFileParam	w;	w.ioNamePtr = nil;	w.ioVRefNum = file->vRefNum;	err = PBFlushVolSync((ParmBlkPtr)&w);	return(err);					// Fehlercode zurückgeben}OSErr	FFSMakeFSSpec(short vRefNum,Str255 fileName,FSSpec *f){REG OSErr	err;long		ignoredProcID;	// dummy	CopyPString(f->name,fileName);	// Filenamen übertragen	f->parID = 0L;	err = GetWDInfo(vRefNum,&f->vRefNum,&f->parID,&ignoredProcID);	return(err);}