#include "GlobalDefines.h"#include "DoEvent.h"#include "GeosMore.h"#include "GlobalLib.h"#include "File.h"#include "Menus.h"#include "MenuCmd.h"#include "WindowsGlobal.h"#include "GlobalStruct.h"#include "rsrcDefines.h"#include "DialogLib.h"#include "Print.h"#include "Help.h"#include "AEAktion.h"#if !GERD#include "Sharp.h"#endif#include "Install.h"#include <Aliases.h>LONG	GetSleep(VOID);VOID	StartDocuments(VOID);VOID	DefaultDocuments(VOID);VOID	BetaDialog(VOID);VOID	InitAppleEvents(VOID);EventRecord		gTheEvent;				// globaler Event-RecordEventRecord		gLastEvent;				// letzter Maus-up-Event (Doppelklick!)int				gClicks;				// Anzahl der MausklicksBoolean			gQuitApplication;		// true, dann Programmende#if USETEXTEDITTEHandle		gTEHandle = nil;		// Text-EditWindPtr			gTEWindow;				// Window zum Text-Edit#endifWORD			gLastCursor;			// Cursorform bei Suspend (fŸr Resume)/*** *	nŠchsten Event abholen und Variablen fŸr Gerhard initialisieren ***/Boolean	GetEvent(VOID){REG Boolean	flag;VOID		NextCursor(VOID);	if (gHasWaitNextEvent)			// System 6 oder hšher?		flag = WaitNextEvent(everyEvent,&gTheEvent,GetSleep(),nil);	else {		SystemTask();		flag = GetNextEvent(everyEvent,&gTheEvent);	}	NextCursor();					// Mauszeiger-Animation Ÿber eine acur-Resource	SetupGVars(&gTheEvent);			// globale Variablen fŸr Gerhard setzen	return(flag);}Boolean		gFlag;Boolean		CheckDialog(VOID);Boolean		CheckDialog(VOID){DialogPtr		d = (DialogPtr)gMacWind;WORD			item;Point			p;ControlHandle	c;Boolean			aDAIsActive;	if (!BTstQ(gMacWind->Typ,TrueDialog)) return(false);	// kein ÒechterÓ Dialog?	if (gTheEvent.what != mouseDown) return(false);			// Mausklick?	aDAIsActive	= IsDAWindow(FrontWindow());	p = gTheEvent.where;	GlobalToLocal(&p);								// lokale Mausposition	if (!PtInRgn(p,((GrafPtr)gMacWind)->visRgn)) return(false);// Windowbereich nicht sichtbar?	if (((gMacWind != gTopFloat)&&(gMacWind != gTopWindow)) || aDAIsActive)		SelectWind(gMacWind);						// Fenster (mit Klick drin) toppen!	if (!FindControl(p,(WindowPtr)gMacWind,&c)) return(false);	// ein Control an der Stelle?	item = FindDItem(d,p) + 1;						// ItemNo ermitteln	if (item > 0) {		WORD type; Handle h; Rect r;		GetDItem(d,item,&type,&h,&r);				// Info zum Control holen		if((type & itemDisable) == 0) {				// Control disabled?			if (TrackControl(c,p,nil)) {			// Mausaktion mit dem Control				WINDOW(gMacWind,button,(LONG)item);	// dann Button-Event			}		}	}	gFlag = false;			// Mouse-Down o.Š. verwerfen	return(true);			// Windowschleife beenden, da Ursache des Klicks erledigt}/*** *	Close-Routine vom Debug-Float ***/WindPtr		ownFloat = nil;VOID	ownFloatclose(VOID);VOID	ownFloatclose(VOID){	ownFloat = nil;}/*** *	globale Event-Schleife ***/VOID	EventLoop(VOID){GrafPtr		oldGrafPtr;	GetPort(&oldGrafPtr);			// originaler GrafPort	InitAppleEvents();				// AppleEvents anmelden#if BETA	if (gAppTrue) {		BetaDialog();				// Beta-Dialog anzeigen		UnloadSeg(BetaDialog);		// Segment rauswerfen	}#endif	if (gHasAlias)					// Alias vorhanden?		DefaultDocuments();			// Default-Dokumente laden	if (!gHasAppleEvents)			// wenn keine Apple-Events vorhanden		StartDocuments();			// Ÿbergebene Dokumente ohne AppleEvents šffnen	f_SetJump(gJumpBuffer);			// RŸcksprung setzen	while (!gQuitApplication) {		GrafPtr	savePort;		gFlag = GetEvent();		if (!gInBackground) {		// Applikation NICHT im Hintergrund?			REG WindPtr	w = gTopWindow;			if (!w)		w = gTopWindow;			if (!w)		w = (WindPtr)oldGrafPtr;			SetPort((WindowPtr)w);	// GrafPort auf das aktuelle Window		}		if (ownFloat) {			Str255		s;			static LONG	l = 0L;			LONG		totalSize,contigSize;			PurgeSpace(&totalSize,&contigSize);			if (l != totalSize) {				l = totalSize;				NumToString(l,s);				SetIText((Handle)GetCH((DialogPtr)ownFloat,2),s);			}		} else if ((!gAppTrue)&&0) {			Rect	r;			SetRect(&r,10,40,100,100);			ownFloat = OpenWind(TRUEDIALOG+9998|(STDFLOAT & 0xFFFF0000L)|(1L << NoParent),&r,"\pSpeicheranzeige",19,350,300);			WFUNC(ownFloat,close,ownFloatclose);		}		if (!gInBackground) {		// Applikation im Vordergrund?			if (!IsAppWindow(FrontWindow())) {				WindowPeek	w = LMGetWindowList();		// alle alten aktiven Windows unhiliten				while(w) {					if (IsAppWindow((WindowPtr)w) && (w->hilited)) {						WActivate((WindPtr)w,false);					}					w = w->nextWindow;				}			} else {				if (gTopWindow)					if (!((WindowPeek)gTopWindow)->hilited)						HiliteWindow((WindowPtr)gTopWindow,true);			}			BalloonAktion();		// evtl. Balloon-Help verwalten		}		ForAllWindows(CheckDialog,nil,0);		if (gFlag)					// ein Event vorhanden?			DoEvent();				// dann diesen auswerten		else {			DoIdleTasks();			// sonst nur IdleÉ		}	}}/*** *	Vararbeitung von Idle (Null)-Events ***/#if USETEXTEDITvoid	teidle(void);void	teidle(void){	TEIdle(gTEHandle);}#endifVOID	DoIdleTasks(VOID){WindowPeek		w;static Boolean	flag = false;#if !GERD	if (!CheckMem(40000) && !flag) {	// reicht der Speicher noch? (Warnung noch nicht gegeben)		DoDialog(170,1);				// Warnung ausgeben		flag = true;					// Speicher ist knapp!	}	if (CheckMem(50000)) flag = false;	// jetzt haben wir wieder genug SpeicherÉ#endif	if(gFirstWindowFlag)			// schon einmal ein Window gešffnet		{ G(Idle)(); }				// globaler Idle-Event#if USETEXTEDIT	if (gTEHandle && (gTopWindow==gTEWindow))		WindowAktion(gTopWindow,-1,(LONG)teidle);	// Text-Edit aktiv#endif	for(w = LMGetWindowList();w;w = ((WindowPeek)w)->nextWindow) {		if (IsAppWindow((WindowPtr)w)) {			if (((WindPtr)w)->RedrawFlag)			// erster Redraw erfolgt?				WINDOW((WindPtr)w,idle,(LONG)nil);	// dann Idle-Event senden		}	}}/*** *	maximale Zeit zwischen zwei Nullevents ermitteln ***/LONG	GetSleep(VOID){REG LONG	sleep = gG.SleepTime;#if USETEXTEDIT	if (!gInBackground &&			// wenn APPL nicht im Hintergrund		!IsDAWindow((WindowPtr)FrontWindow())) // und kein DA aktiv ist		if (gTEHandle)			if ((**gTEHandle).selStart == (**gTEHandle).selEnd)				sleep = MIN(sleep,GetCaretTime());	// dann die Cursor-Blinkzeit nehmen#endif	return(sleep);					// Zeit zurŸckgeben}/*** *	aktuellen Event verarbeiten ***/#if USETEXTEDITVOID	tekey(VOID);VOID	tekey(VOID){	TEKey(keyascii,gTEHandle);}#endifVOID	DoEvent(VOID){REG WindPtr	window;					// aktives WindowREG LONG	m = gTheEvent.message;	// Message von gTheEvent.messageREG Point	p = gTheEvent.where;	// wohin wurde geklicktREG WORD	part;					// angeklicktes Windowelement	switch(gTheEvent.what) {	case	mouseUp:#if !GERD			gLastEvent = gTheEvent;	// letzten Event fŸr Doppelklick merken#endif			break;	case	mouseDown:				// mit Doppelklick-Verwaltung			if (((gLastEvent.when + GetDblTime()) > gTheEvent.when) &&					(ABS(p.h-gLastEvent.where.h)+				ABS(p.v-gLastEvent.where.v))<6) {				gClicks++;				// ein Mausklick mehr			} else				gClicks = 1;			// ein Mausklick			gLastEvent = gTheEvent;		// letzten Event fŸr Doppelklick merken			{ WindPtr w;				part = FindWindow(p,(WindowPtr*)&w);				window = w;			}			if ((window != gTopWindow)&&(IsDialog(gTopWindow))) {				if (part != inMenuBar) {					SysBeep(10);					break;				}			}#if USETEXTEDIT			if (part != inContent) TEExit();#endif			switch(part) {			case	inDesk:		break;			case	inSysWindow:SystemClick(&gTheEvent,(WindowPtr)window);								break;			case	inMenuBar:	AdjustMenus();								DoMenuCommand(MenuSelect(p));								break;			case	inDrag:		DragWind(window,p,&gDesktopRect);								break;			case	inContent:	WContentClick(window,gTheEvent.where);								break;			case	inGrow:		WGrowClick(window,gTheEvent.where);								break;			case	inZoomIn:			case	inZoomOut:	if(TrackBox((WindowPtr)window,p,part))									WZoomClick(window,part);								break;			case	inGoAway:	if(TrackGoAway((WindowPtr)window,p))									WCloseClick(window);								break;			default:			if (part) {									if (gG.WElement)										{ G(WElement)(window,p,part); }									else										DragWind(window,p,&gDesktopRect);								}			}			break;	case	keyDown:	case	autoKey:			window = gTopWindow;					// das oberste non-Float			if (!WINDOW(window,key,(LONG)nil)) break;// will das Window den Tastendruck?			{ Boolean cont = true;				{ G(Key)(m,&cont); }				// Tastendruck global losgeworden?				if (cont == false) break;			// dann jetzt raus =>			}			if (gTheEvent.modifiers & cmdKey) {		// Command gedrŸckt?				if(gTheEvent.what == keyDown)		// kein Auto-Repeat					if(!IsDialog(window)) {			// Dialog aktiv?						AdjustMenus();				// MenŸs updaten						DoMenuCommand(MenuKey(m & charCodeMask));					} else						SysBeep(10);				// Kommando nicht mgl.			} else {								// kein Command!#if USETEXTEDIT				if (!IsAppWindow((WindowPtr)window)) break;		// nicht unser Window =>				if (gTEHandle && (gTEWindow == gTopWindow)||(gTEWindow == gTopWindow)) {					if ((keyascii == 13)||(keyascii == 3)) 						WindowAktion(window,-1,(LONG)TEExit);	// Text-Edit aktiv					else						WindowAktion(window,-1,(LONG)tekey);	// Text-Edit aktiv				}#endif			}			break;	case	updateEvt:			WUpdate((WindPtr)m);			break;	case	activateEvt:			WActivate((WindPtr)m,gTheEvent.modifiers & activeFlag);			break;	case	diskEvt:			if (HIWord(m) != noErr) {				Point	p;				SetPt(&p,kDILeft,kDITop);				DIBadMount(p,m);			}			break;	case	kHighLevelEvent:			AEProcessAppleEvent(&gTheEvent);			break;	case	kOSEvent:			switch((m>>24) & 0xFF) {//			case	kMouseMovedMessage://					break;			case	kSuspendResumeMessage:					gInBackground = !(m & kResumeMask);					{ G(SuspendResume)(gInBackground); }					if (gInBackground) {						ForAllWindows((ProcPtr)HideFloats,nil,0);						gLastCursor = gCurrentCursor;						pfeil();					} else {						DoSetCursor(gLastCursor);						ForAllWindows((ProcPtr)Show2Floats,nil,0);	// Floats anschalten					}					WActivate(gTopWindow,!gInBackground);			}	}}/*** *	Ÿbergebene Dokumente šffnen (ohne AppleEvents, nur in System 6) ***/VOID	StartDocuments(VOID){REG OSErr		err;			// evtl. OS-FehlercodesWORD			whatToDo;		// Drucken oder …ffnen?WORD			numberOfFiles;	// Anzahl der Ÿbergebenen DateienREG WORD		i;				// SchleifenzŠhlerWORD			j;				// SchleifenzŠhlerAppFile			theAppFile;		// FileparameterFSSpec			fileSpec;		// Dateiparameter fŸr ÒOpenÉÓFInfo			f;				// Creator und Type-Info	CountAppFiles(&whatToDo,&numberOfFiles);		// Anzahl der Ÿbergebenen Dateien	if (numberOfFiles > 0) {		for (i = 1;i <= numberOfFiles;i++) {		// alle Ÿbergebenen Dateien durchgehen			GetAppFiles(i,&theAppFile);			ClrAppFiles(i);			err = FFSMakeFSSpec(theAppFile.vRefNum,theAppFile.fName,&fileSpec);			if (!CheckOSError(err)) break;			// ein Fehler?			err = FGetFInfo(&fileSpec,&f);			if (!CheckOSError(err)) break;			// ein Fehler?			for(j=0;j < gG.AutoLoadCount;j++) {		// Dateityp suchen				if (f.fdType == gG.AutoLoad[j].Filetype) {	// gefunden?					err = (gG.AutoLoad[j].DoLoad)(&fileSpec,i,whatToDo);					break;				}			}			if (!CheckOSError(err)) break;			// ein Fehler?			if (j >= gG.AutoLoadCount)				// Dateityp nicht gefunden?				DoDialog(DLOGillFType,1);		}	} else if(!gDocList) {		DocHandle		d;			// Handle auf das aktuelle Dokument		CopyPString(fileSpec.name,(USTR)"\pAutoload");	// versuchen ÒAutoloadÓ zu laden		fileSpec.vRefNum = 0; fileSpec.parID = 0;		err = AppOpenDocument(&d,&fileSpec,fsRdWrPerm);	// neues Dokument anlegen		if (!err)			err = AppInitDocument(d,iOpen,err);			// und šffnen		if (err) {			KeyMap		theKeys;	// 8 Byte Tastaturmatrix						GetKeys(theKeys);		// aktuelle Tastaturmatrik holen			if (CheckKey(0x3A))		// Option gedrŸckt?				MOpen();			// dann gleich den File-Selector			else				MNew();				// kein Dokument Ÿbergeben => leeres Dokument		}	}	if (whatToDo == appPrint) gQuitApplication = true;	// Programm nach dem Drucken beenden}/*** *	Default-Dokumente laden ***/VOID	DefaultDocuments(VOID){REG OSErr		err;			// evtl. OS-FehlercodesWORD			numberOfFiles;	// Anzahl der Ÿbergebenen DateienREG WORD		i;				// SchleifenzŠhlerWORD			j;				// SchleifenzŠhlerFSSpec			fileSpec;		// Dateiparameter fŸr ÒOpenÉÓFInfo			f;				// Creator und Type-InfoREG WORD		saveRes;WORD			resid;AliasHandle		h;Boolean			wasChanged;		// True, wenn Alias upgedatet werden mu§	saveRes = CurResFile();			// aktuelle Resource-Datei retten	err = FOpenResFile(&gSavePref,&resid);	// Resource-Fork šffnen	if(!err) {		numberOfFiles = Count1Resources(rAliasType);	// Dokumente zŠhlen		if (numberOfFiles > 0) {			for (i = 1;i <= numberOfFiles;i++) {		// alle Ÿbergebenen Dateien durchgehen				h = (AliasHandle)GetResource(rAliasType,i+127);	// Alias-Resource laden				err = ResolveAlias(nil,h,&fileSpec,&wasChanged);				err = FGetFInfo(&fileSpec,&f);				if (!CheckOSError(err)) break;			// ein Fehler?				for(j=0;j < gG.AutoLoadCount;j++) {		// Dateityp suchen					if (f.fdType == gG.AutoLoad[j].Filetype) {	// gefunden?						err = (gG.AutoLoad[j].DoLoad)(&fileSpec,i,appOpen);						break;					}				}				if (!CheckOSError(err)) break;			// ein Fehler?			}		}		FCloseResFile(resid);	}	UseResFile(saveRes);			// alte Resource-Datei setzen}