/*** *	Hier zwei Routinen zum kodieren und dekodieren eines Speicherblockes. *	Nicht besonders schnell, dafŸr sicherÉ ***/#include "code/decode.h"void code_passwort(void);void random(void);void	asm decode_data(void *start,long count,unsigned char *password){Str255	localpw;	// Buffer fŸr lokales (zermŸlltes) Passwort//	asm {				fralloc +				movem.l	8(A6),D0/A0-A1				movem.l D3/D7/A2-A3,-(SP)				lea		localpw,A3				move.l	A3,A2@copypw1:		move.b	(A1)+,(A3)+		// Passwort Ÿbertragen				bne.s	@copypw1				clr.b	(A3)				exg		D0,A0				lea		(A0,D0),A1		// Ptr auf das Ende				moveq   #-74,D1				jsr		code_passwort	// Passwort erstmal mischen				move.l  D1,D7			// Zufallsbasis setzen				moveq   #4,D2				bra.s   @decode_data3@decode_data1:	tst.b   (A3)			// Passwort zuende?				bne.s   @decode_data2	// Nein! =>				jsr		code_passwort	// Passwort neu mischen				eor.l   D1,D7			// Zufallsbasis Šndern@decode_data2:	addq.w  #5,D2			// Positionsoffset				jsr		random				muls    D0,D2			// etwas mischen				add.b   (A3)+,D0		// Passwortbyte holen				muls    D2,D0				eor.b   D1,D0				sub.b   D0,(A0)				rol.l   #8,D1				move.b  (A0)+,D1        // nicht mehr kodiertes Zeichen holen@decode_data3:	cmpa.l  A1,A0				blo.s   @decode_data1				movem.l (SP)+,D3/D7/A2-A3//	}	frfree	rts}void asm code_data(void *start,long count,unsigned char *password){char	localpw[32];	// Buffer fŸr lokales (zermŸlltes) Passwort//	asm {				fralloc +				movem.l	8(A6),D0/A0-A1				movem.l D3/D7/A2-A3,-(SP)				lea		localpw,A3				move.l	A3,A2@copypw1:		move.b	(A1)+,(A3)+		// Passwort Ÿbertragen				bne.s	@copypw1				clr.b	(A3)				exg		D0,A0				lea		(A0,D0),A1		// Ptr auf das Ende				moveq   #-74,D1				jsr		code_passwort	// Passwort erstmal mischen				move.l  D1,D7			// Zufallsbasis setzen				moveq   #4,D2				bra.s   @code_data3@code_data1:	tst.b   (A3)			// Passwort zuende?				bne.s   @code_data2		// Nein! =>				jsr		code_passwort	// Passwort neu mischen				eor.l   D1,D7			// Zufallsbasis Šndern@code_data2:	addq.w  #5,D2			// Positionsoffset				jsr		random				muls    D0,D2			// etwas mischen				add.b   (A3)+,D0		// Passwortbyte holen				muls    D2,D0				eor.b   D1,D0				rol.l   #8,D1				move.b  (A0),D1			// noch nicht kodiertes Zeichen merken				add.b   D0,(A0)+		// Zeichen kodieren@code_data3:	cmpa.l  A1,A0			// Ende erreicht?				blo.s   @code_data1		// Nein! =>				movem.l (SP)+,D3/D7/A2-A3//	}	frfree	rts}void	asm code_passwort(void){//	asm {				movea.l A2,A3@code_passwort1:move.b  (A3),D0			// Zeichen aus dem Passwort holen				beq.s   @code_passwort2	// Ende des Passwortes =>				sub.b   D1,D0				ext.w   D0				muls    #9387,D0				eor.l   D0,D1				rol.l   #5,D1				addq.w  #5,D0				move.b  D0,(A3)+		// Passwort kodieren				bra.s   @code_passwort1@code_passwort2:movea.l A2,A3//	}	rts}void	asm random(void){//	asm {			movem.l D2-D6,-(SP)			move.l  D7,D0			move.l  D7,D6			move.l  #127773,D2			add.l   D6,D6			moveq   #0,D4			moveq   #14,D3			move.w  D6,D5			clr.w   D6			swap    D6@random2:	add.w   D4,D4			add.w   D5,D5			addx.l  D6,D6			cmp.l   D2,D6			bmi.s   @random3			sub.l   D2,D6			addq.w  #1,D4@random3:	dbra    D3,@random2			move.l  D4,D5			muls    #-2836,D5			mulu    #42591,D4			move.l  D4,D6			add.l   D4,D4			add.l   D6,D4			sub.l   D4,D0			moveq   #4,D4@random4:	move.l  D0,D6			lsl.l   #3,D0			sub.l   D6,D0			dbra    D4,@random4			add.l   D5,D0			bpl.s   @random5			add.l   #0x7FFFFFFF,D0@random5:	move.l  D0,D7			movem.l (SP)+,D2-D6//	}	rts}