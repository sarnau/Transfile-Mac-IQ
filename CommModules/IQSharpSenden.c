/*** *	Empfangsroutinen für den Sharp ***/#include "IQSharpSenden.h"#include "IQComm.h"#include "SerialComm.h"#include "Geos.h"#include "List.h"#include "MeterWindow.h"UBYTE	IQGetAttr(ListH l);			// Atttributbyte zusammensetzen und zurückgebenvoid	IQUlFixString(USTR *p);		// exakt EINMAL <CR><LF> an den String anhängen/*** *	Attribut-Byte zusammensetzen ***/UBYTE	IQGetAttr(REG ListH l){REG UBYTE	attr = 0;	if ((*l)->b.marked)			attr |= 0x80;	if ((*l)->b.alarm)			attr |= 0x40;	if ((*l)->b.displaymode)	attr |= 0x20;	return(attr);}/*** *	sorgt dafür, daß am Stringende GARANTIERT nur EIN <CR><LF> stehen! * *	p zeigt dabei hinter das letzte Zeichen im String ***/void	IQUlFixString(REG USTR *p){REG USTR	pp = *p;REG UCHAR	c = *--pp;			// vorletztes Zeichen holen	while (c == 13) c = *--pp;	// erstmal alle <CR> abschneiden	pp++;	*pp++ = '\r'; *pp++ = '\n';	// <CR>,<LF> anhängen	*pp = 0;	*p = pp;}/*** *	Leerfunktion für nicht implementierte Upload-Funktionen ***/OSErr	IQUlNull(ListH l){	return(ioErr);}/*** *	Upload-Funktion für Schedule ***/OSErr	IQUlSchedule(REG ListH l){UBYTE		s[2500];USTR		p;	IQSetHexB(s,IQGetAttr(l));	// Attribut ermitteln	p = IQSetDez(&s[2],4,(*l)->t.schedule.year);	p = IQSetDez(p,2,(*l)->t.schedule.month);	p = IQSetDez(p,2,(*l)->t.schedule.day);	p = IQSetDez(p,2,(*l)->t.schedule.shour);	p = IQSetDez(p,2,(*l)->t.schedule.sminute);	p = IQSetDez(p,2,(*l)->t.schedule.ehour);	p = IQSetDez(p,2,(*l)->t.schedule.eminute);	p = IQSetDez(p,2,(*l)->t.schedule.ahour);	p = IQSetDez(p,2,(*l)->t.schedule.aminute);	*p++ = 13; *p++ = 10;	vStrcpy((STR)p,(*l)->d);		// Description übertragen	IQToSharpIQ(p);					// String ins Sharp-Format wandeln	p = s+Strlen((STR)s);	mWindowUpdate(mWakt + 1);	IQUlFixString(&p);	return(SDWrite(s,p-s));}/*** *	Upload-Funktion für Ann1 ***/OSErr	IQUlAnn1(REG ListH l){UBYTE		s[2500];USTR		p;	IQSetHexB(s,IQGetAttr(l));	// Attribut ermitteln	p = IQSetDez(&s[2],2,(*l)->t.ann1.month);	p = IQSetDez(p,2,(*l)->t.ann1.date);	*p++ = 13; *p++ = 10;	vStrcpy((STR)p,(*l)->d);		// Description übertragen	IQToSharpIQ(p);					// String ins Sharp-Format wandeln	p = s+Strlen((STR)s);	mWindowUpdate(mWakt + 1);	IQUlFixString(&p);	return(SDWrite(s,p-s));			// Fehler!}/*** *	Upload-Funktion für Ann2 ***/OSErr	IQUlAnn2(REG ListH l){UBYTE		s[2500];USTR		p;	IQSetHexB(s,IQGetAttr(l));	// Attribut ermitteln	p = IQSetDez(&s[2],2,(*l)->t.ann2.month);	p = IQSetDez(p,1,(*l)->t.ann2.week);	p = IQSetDez(p,1,(*l)->t.ann2.day);	*p++ = 13; *p++ = 10;	vStrcpy((STR)p,(*l)->d);		// Description übertragen	IQToSharpIQ(p);					// String ins Sharp-Format wandeln	p = s+Strlen((STR)s);	mWindowUpdate(mWakt + 1);	IQUlFixString(&p);	return(SDWrite(s,p-s));			// Fehler!}/*** *	Upload-Funktion für Period Schedule ***/OSErr	IQUlPSchedule(REG ListH l){UBYTE		s[2500];USTR		p;	IQSetHexB(s,IQGetAttr(l));	// Attribut ermitteln	p = IQSetDez(&s[2],4,(*l)->t.psched.syear);	p = IQSetDez(p,2,(*l)->t.psched.smonth);	p = IQSetDez(p,2,(*l)->t.psched.sday);	p = IQSetDez(p,4,(*l)->t.psched.eyear);	p = IQSetDez(p,2,(*l)->t.psched.emonth);	p = IQSetDez(p,2,(*l)->t.psched.eday);	*p++ = 13; *p++ = 10;	vStrcpy((STR)p,(*l)->d);		// Description übertragen	IQToSharpIQ(p);					// String ins Sharp-Format wandeln	p = s+Strlen((STR)s);	mWindowUpdate(mWakt + 1);	IQUlFixString(&p);	return(SDWrite(s,p-s));			// Fehler!}/*** *	Upload-Funktion für Daily alarm ***/OSErr	IQUlDAlarm(REG ListH l){UBYTE		s[16];USTR		p;	IQSetHexB(s,IQGetAttr(l));	// Attribut ermitteln	p = IQSetDez(&s[2],2,(*l)->t.dalarm.hour);	p = IQSetDez(p,2,(*l)->t.dalarm.minute);	mWindowUpdate(mWakt + 1);	IQUlFixString(&p);	return(SDWrite(s,p-s));			// Fehler!}/*** *	Upload-Funktion für Tel ***/OSErr	IQUlTelData(REG ListH l){UBYTE		s[2500];USTR		p;REG USTR	p2;REG UWORD	i,anz;	IQSetHexB(s,IQGetAttr(l));	// Attribut ermitteln	p = &s[2];	p2 = (USTR)&(*l)->d[0];	anz = (!NewLinkFormat(gDoc))?3:3+5;	for(i=0;i<anz;i++) {		if (*p2) {					// folgen noch Daten?			REG UCHAR	c;			while(c = *p2) {		// Stringende erreicht?				p2++;				*p++ = c;			// Zeichen erstmal übertragen				if (c == '\r') break;// alternatives Stringende			}			if (c != '\r') *p++ = '\r';		} else {			*p++ = '\r';			// sonst nur noch CR/LFs anhängen		}		*p++ = '\n';	}	*p = 0;	IQToSharpIQ(&s[2]);				// String ins Sharp-Format wandeln	mWindowUpdate(mWakt + 1);	return(SDWrite(s,p-s));			// Fehler!}/*** *	Upload-Funktion für Tel Free ***/OSErr	IQUlTelFile(REG ListH l){UBYTE	s[15];USTR	p;	IQSetHexB(s,IQGetAttr(l));	// Attribut ermitteln	BlockMoveData((*l)->d,&s[2],10);	// Daten übertragen	IQToSharpIQ(&s[2]);				// String ins Sharp-Format wandeln	p = &s[12];	mWindowUpdate(mWakt + 1);	IQUlFixString(&p);	return(SDWrite(s,14));			// Fehler!}/*** *	Upload-Funktion für Tel File Name ***/OSErr	IQUlTelFree(REG ListH l){UBYTE		s[2500];USTR		p;REG USTR	p2;REG UWORD	i;	IQSetHexB(s,IQGetAttr(l));	// Attribut ermitteln	p = &s[2];	p2 = (USTR)&(*l)->d[0];	for(i=0;i<5;i++) {		if (*p2) {					// folgen noch Daten?			REG UCHAR	c;			while(c = *p2) {		// Stringende erreicht?				p2++;				*p++ = c;			// Zeichen erstmal übertragen				if (c == '\r') break;// alternatives Stringende			}			if (c != '\r') *p++ = '\r';		} else {			*p++ = '\r';			// sonst nur noch CR/LFs anhängen		}		*p++ = '\n';	}	*p = 0;	IQToSharpIQ(&s[2]);				// String ins Sharp-Format wandeln	mWindowUpdate(mWakt + 1);	return(SDWrite(s,p-s));			// Fehler!}/*** *	Upload-Funktion für MEMO ***/OSErr	IQUlMemo(REG ListH l){UBYTE		s[2052];USTR		p;	IQSetHexB(s,IQGetAttr(l));	// Attribut ermitteln	HLock((Handle)l);	vStrcpy((STR)&s[2],(*l)->d);	// Memo übertragen	HUnlock((Handle)(Handle)l);	IQToSharpIQ(&s[2]);				// String ins Sharp-Format wandeln	p = s+Strlen((STR)s);	mWindowUpdate(mWakt + 1);	IQUlFixString(&p);	return(SDWrite(s,p-s));			// Fehler!}/*** *	Upload-Funktion für Business Free Field ***/OSErr	IQUlBusFree(REG ListH l){UBYTE		s[2500];USTR		p;REG USTR	p2;REG UWORD	i;	IQSetHexB(s,IQGetAttr(l));	// Attribut ermitteln	p = &s[2];	p2 = (USTR)&(*l)->d[0];	for(i=0;i<5;i++) {		if (*p2) {					// folgen noch Daten?			REG UCHAR	c;			while(c = *p2) {		// Stringende erreicht?				p2++;				*p++ = c;			// Zeichen erstmal übertragen				if (c == '\r') break;// alternatives Stringende			}			if (c != '\r') *p++ = '\r';		} else {			*p++ = '\r';			// sonst nur noch CR/LFs anhängen		}		*p++ = '\n';	}	*p = 0;	IQToSharpIQ(&s[2]);				// String ins Sharp-Format wandeln	mWindowUpdate(mWakt + 1);	return(SDWrite(s,p-s));			// Fehler!}/*** *	Upload-Funktion für das UserDic ***/OSErr	IQUlUserDic(REG ListH l){UBYTE		s[50];USTR		p;	IQSetHexB(s,IQGetAttr(l));		// Attribut ermitteln	vStrcpy((STR)&s[2],(*l)->d);	// Daten übertragen	IQToSharpIQ(&s[2]);				// String ins Sharp-Format wandeln	p = s+Strlen((STR)s);	mWindowUpdate(mWakt + 1);	IQUlFixString(&p);	return(SDWrite(s,p-s));			// Fehler!}/*** *	Upload-Funktion für DoList ***/VOID	IQPutDezSpez(USTR p,WORD value,WORD len);VOID	IQPutDezSpez(USTR p,WORD value,REG WORD len){UCHAR		s[20];REG WORD	i;	NumToString(value,s);	for(i=0;i<len;i++) p[i] = ' ';	// erstmal mit Leerzeichen füllen	for(i=len-1;(i>=0)&&(s[0]>0);i--)		p[i] = s[s[0]--];			// Zahl übertragen}OSErr	IQUlDoList(REG ListH l){UBYTE		s[2048];REG USTR	p;REG USTR	sp;USTR		p2;	p = s;	*p++ = ((*l)->b.marked)?'1':'0';	*p++ = '2'; *p++ = '\t';	sp = (USTR)&(*l)->d;	while(*sp != '\r') *p++ = *sp++;// Description übertragen	sp++;	*p++ = '\t';	*p++ = (*l)->t.todo.prio >> 8;	// Priorität	*p++ = (*l)->t.todo.prio;	*p++ = '\t';	IQPutDezSpez(p,(*l)->t.todo.day,2); p += 2;	*p++ = '.';	IQPutDezSpez(p,(*l)->t.todo.month,2); p += 2;	*p++ = '.';	IQPutDezSpez(p,(*l)->t.todo.year,4); p += 4;	*p++ = '\t'; *p++ = ((sp[0] == ' ')&&(sp[1] == '\r'))?'0':' ';	while(*sp != '\r') *p++ = *sp++;// Name des Managers übertragen	sp++;	*p++ = '\t'; *p++ = ((sp[0] == ' ')&&(sp[1] == 0))?'0':' ';	while((*sp != '\r')&&(*sp != 0)) *p++ = *sp++;// Projektname übertragen	*p = 0;	IQToSharpIQ(s);					// String ins Sharp-Format wandeln	mWindowUpdate(mWakt + 1);	p2 = s + Strlen((STR)s);	IQUlFixString(&p2);	return(SDWrite(s,p2-s));		// Fehler!}/*** *	Upload-Funktion für Expense ***/OSErr	IQUlExpense(REG ListH l){UBYTE		s[2048];USTR		p;REG USTR	sp;USTR		p2;	p = s;	*p++ = ((*l)->b.marked)?'1':'0';	*p++ = '1'; *p++ = '\t';	sp = (USTR)&(*l)->d;	IQPutDezSpez(p,(*l)->t.expense.day,2); p += 2;	if ((*l)->t.expense.day <= 0) p[-1] = ' ';	*p++ = '.';	IQPutDezSpez(p,(*l)->t.expense.month,2); p += 2;	if ((*l)->t.expense.month <= 0) p[-1] = ' ';	*p++ = '.';	IQPutDezSpez(p,(*l)->t.expense.year,4); p += 4;	if ((*l)->t.expense.year <= 0) p[-1] = ' ';	*p++ = '\t'; *p++ = ((sp[0] == ' ')&&(sp[1] == '\r'))?'0':' ';	while(*sp != '\r') *p++ = *sp++;// “Expense type” übertragen	sp++;	*p++ = '\t';	while(*sp != '\r') *p++ = *sp++;// “Amount” übertragen	sp++;	*p++ = '\t'; *p++ = ((sp[0] == ' ')&&((sp[1] == '\r')||(sp[1] == 0)))?'0':' ';	while((*sp != '\r')&&(*sp != 0)) *p++ = *sp++;// “Payment Type” übertragen	if (*sp) sp++;	*p++ = '\t';	*p++ = ((*l)->b.alarm)?'Y':'N';	// Receipt	*p++ = '\t';	while((*sp != '\r')&&(*sp != 0)) *p++ = *sp++;// “Payment Type” übertragen	*p = 0;	IQToSharpIQ(s);					// String ins Sharp-Format wandeln	mWindowUpdate(mWakt + 1);	p2 = s + Strlen((STR)s);	IQUlFixString(&p2);	return(SDWrite(s,p2-s));		// Fehler!}/*** *	Upload-Funktion für Time Accouting ***/OSErr	IQUlTimeAcc(REG ListH l){UBYTE		s[2048];USTR		p;	p = s;	*p++ = ((*l)->b.marked)?'1':'0';	*p++ = '0'; *p++ = 9;	vStrcpy((STR)p,(*l)->d);		// Daten übertragen	IQToSharpIQ(p);					// String ins Sharp-Format wandeln	p = s+Strlen((STR)s);	mWindowUpdate(mWakt + 1);	IQUlFixString(&p);	return(SDWrite(s,p-s));			// Fehler!}/*** *	Upload-Funktion für Business Card ***/OSErr	IQUlBusiness(REG ListH l){UBYTE		s[2500];USTR		p;REG USTR	p2;REG UWORD	i;	IQSetHexB(s,IQGetAttr(l));	// Attribut ermitteln	p = &s[2];	p2 = (USTR)&(*l)->d;	for(i=0;i<13;i++) {		if (*p2) {					// folgen noch Daten?			REG UCHAR	c;			while(c = *p2) {		// Stringende erreicht?				p2++;				*p++ = c;			// Zeichen erstmal übertragen				if (c == '\r') break;// alternatives Stringende			}			if (c != '\r') *p++ = '\r';		} else {			*p++ = '\r';			// sonst nur noch CR/LFs anhängen		}		*p++ = '\n';	}	*p = 0;	IQToSharpIQ(&s[2]);				// String ins Sharp-Format wandeln	mWindowUpdate(mWakt + 1);	return(SDWrite(s,p-s));			// Fehler!}/*** *	Upload-Funktion für Outline ***/OSErr	IQUlOutline(REG ListH l){REG OSErr	err;UBYTE		s[2500];USTR		p;REG USTR	p2;REG UWORD	i,anz;	IQSetHexB(s,IQGetAttr(l));	// Attribut ermitteln	BlockMoveData((*l)->d,&s[2],10);	err = SDWrite(s,12);	if (err<0) return(err);			// Fehler!	anz = IQGetHexB(&s[8])+(IQGetHexB(&s[10])<<8);	// Anzahl der Datensätze	p2 = (USTR)&((*l)->d[10]);		// ab hier folgen die Topics	while(anz-->0) {		p = s;		if (*p2) {					// folgen noch Daten?			REG UCHAR	c;			while(c = *p2) {		// Stringende erreicht?				p2++;				*p++ = c;			// Zeichen erstmal übertragen				if (c == '\r') break;// alternatives Stringende			}			if (c != '\r') *p++ = '\r';		} else {			*p++ = '\r';			// sonst nur noch CR/LFs anhängen		}		*p++ = '\n';		*p = 0;		IQToSharpIQ(s+2);			// String ins Sharp-Format wandeln		err = SDWrite(s,p-s);		if (err<0) return(err);		// Fehler!	}	mWindowUpdate(mWakt + 1);	return(noErr);}/*** *	Upload-Funktion für USERFILE ***/OSErr	IQUlUserfile(REG ListH l){UBYTE		s[2052];USTR		p;	IQSetHexB(s,IQGetAttr(l));	// Attribut ermitteln	HLock((Handle)l);	vStrcpy((STR)&s[2],(*l)->d);	// Memo übertragen	HUnlock((Handle)(Handle)l);	{		REG STR	ptr = (STR)&s[2];		while(*ptr) {			if (*ptr == '\t')		// CHR$(7) wird in CHR$(0x65) gewandelt, das ist ein Bullet				*ptr = '•';			if (*ptr == '\r')				*ptr = '\t';			ptr++;		}	}	IQToSharpIQ(&s[2]);				// String ins Sharp-Format wandeln	p = s+Strlen((STR)s);	mWindowUpdate(mWakt + 1);	IQUlFixString(&p);	return(SDWrite(s,p-s));			// Fehler!}/*** *	Upload-Funktion für Time ***/OSErr	IQUlTime(REG ListH l){UBYTE		s[2052];USTR		p;	IQSetHexB(s,IQGetAttr(l));	// Attribut ermitteln	HLock((Handle)l);	vStrcpy((STR)&s[2],(*l)->d);	// Memo übertragen	HUnlock((Handle)l);	IQToSharpIQ(&s[2]);				// String ins Sharp-Format wandeln	p = s+Strlen((STR)s);	mWindowUpdate(mWakt + 1);	IQUlFixString(&p);	return(SDWrite(s,p-s));			// Fehler!}/*** *	Upload-Funktion für Aufgaben ***/OSErr	IQUlTodo(REG ListH l){UBYTE		s[2500];REG USTR	p;REG USTR	sp;REG WORD	count = 0;REG CHAR	TempChar;REG WORD	len;UCHAR		c;	IQSetHexB(s,IQGetAttr(l));		// Attribut ermitteln	p = IQSetDez(&s[2],4,(*l)->t.todo.year);	p = IQSetDez(p,2,(*l)->t.todo.month);	p = IQSetDez(p,2,(*l)->t.todo.day);	TempChar = (*l)->t.todo.prio;	if (TempChar == '√') TempChar = '≈';	*p++ = TempChar;	*p++ = ' ';*p++ = ' ';*p++ = ' ';*p++ = ' ';*p++ = ' ';	sp = (USTR)&(*l)->d;	len = 0;	while(c = *sp++) {		*p = c;		if (c == '\r') {			if ((count > 0)&&(len<12)&&(len>0)) {				while(len++<12)		// auf 12 Zeichen auffüllen					*p++ = ' ';				*p = '\r';			// und das überschriebene Return wieder anhängen			}			*++p = '\n';			// an jedes CR ein LF anhängen			count++;				// Anzahl der CR/LFs zählen			len = 0;				// Feldlänge wieder auf 0 setzen		} else {			len++;					// Feldlänge		}		p++;	}	if ((count > 0)&&(len<12)&&(len>0)) {		while(len++<12)				// auf 12 Zeichen auffüllen			*p++ = ' ';	}	while(count++<6) {		*p++ = '\r';				// CR/LFs auffüllen		*p++ = '\n';	}	*p = 0;	IQToSharpIQ(s+16);				// String ins Sharp-Format wandeln	p = s+Strlen((STR)s);	mWindowUpdate(mWakt + 1);	return(SDWrite(s,p-s));			// Fehler!}